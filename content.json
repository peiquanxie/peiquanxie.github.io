{"meta":{"title":"PQ.XIE BLOG","subtitle":"","description":"个人博客","author":"PQ.XIE","url":"https://xie-peiquan.gitee.io","root":"/"},"pages":[{"title":"","date":"2024-04-30T08:07:20.069Z","updated":"2023-07-22T02:40:44.436Z","comments":true,"path":"404.html","permalink":"https://xie-peiquan.gitee.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-04-30T08:07:20.069Z","updated":"2023-09-06T01:59:41.795Z","comments":true,"path":"baidu_verify_codeva-xZof4oMUz5.html","permalink":"https://xie-peiquan.gitee.io/baidu_verify_codeva-xZof4oMUz5.html","excerpt":"","text":"c4b755cea86e877f0ef2d32416419c77"},{"title":"","date":"2024-04-30T08:07:20.069Z","updated":"2023-07-28T09:26:16.461Z","comments":true,"path":"googlef847041eb4e8ca77.html","permalink":"https://xie-peiquan.gitee.io/googlef847041eb4e8ca77.html","excerpt":"","text":"google-site-verification: googlef847041eb4e8ca77.html"},{"title":"","date":"2024-04-30T08:07:20.069Z","updated":"2023-09-19T06:35:33.033Z","comments":false,"path":"about/index.html","permalink":"https://xie-peiquan.gitee.io/about/index.html","excerpt":"","text":"联系方式 邮箱：212951692@qq.com 版权声明 站点内的所有原创内容（包括但不限于文章、图像等）除特别声明外均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，任何人都可以自由传播，但不得用于商用且必须署名并以相同方式分享。 本站部分内容转载于网络，有出处的已在文中署名作者并附加原文链接，出处已不可寻的皆已标注来源于网络。若您认为本站点有部分内容侵犯了您的权益，请在电邮告知，我将认真处理。"},{"title":"所有分类","date":"2024-04-30T08:07:20.069Z","updated":"2023-07-22T02:37:26.591Z","comments":true,"path":"categories/index.html","permalink":"https://xie-peiquan.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-11-21T02:32:12.052Z","updated":"2024-11-21T02:32:12.052Z","comments":true,"path":"friends/index.html","permalink":"https://xie-peiquan.gitee.io/friends/index.html","excerpt":"","text":"Tech Friend kelecnhttps://kelecn.top北辰小栈https://www.mz-zone.cn/恋恋风辰https://gitbookcpp.llfc.club/EdisionYaohttps://www.cnblogs.com/Sweettesting技术前沿https://arthurchiao.artToniBloghttps://tonixwd.github.ioTanShengBloghttps://face2ai.com/program-blog/polariszhaohttps://polariszhao.github.io/zyddorahttps://zyddora.github.io/ Tool Link 清华源pypi 清华ubuntu源 github代理 volantis插件 google编程规范 C++标准库 boost库指南 docker指南"},{"title":"所有标签","date":"2024-04-30T08:07:20.069Z","updated":"2023-07-22T02:37:59.687Z","comments":true,"path":"tags/index.html","permalink":"https://xie-peiquan.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1-基础算法题总结","slug":"数据结构与算法/最小问题","date":"2025-11-28T03:08:18.000Z","updated":"2025-11-28T03:06:09.707Z","comments":true,"path":"2025/11/28/数据结构与算法/最小问题/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"怎么找到两个有序数组的第 k 大个数？对较短的数组 a 切一刀，那么另外一个数组 b 的那一刀的位置也能确定。判断这两刀的边界值是否满足条件，不满足则在a上二分法再寻找一刀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445def findMedianSortedArrays(nums1, nums2): # 确保nums1是较短的数组 if len(nums1) &gt; len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin &lt;= imax: i = (imin + imax) // 2 j = half_len - i # 处理边界情况 if i &lt; m and nums2[j-1] &gt; nums1[i]: # i太小，需要增大 imin = i + 1 elif i &gt; 0 and nums1[i-1] &gt; nums2[j]: # i太大，需要减小 imax = i - 1 else: # 找到合适的分割线，处理中位数计算 # 计算左半部分最大值 if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) # 如果总数是奇数，直接返回左半部分最大值 if (m + n) % 2 == 1: return max_of_left # 计算右半部分最小值 if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) # 如果是偶数，返回平均值 return (max_of_left + min_of_right) / 2.0 数据流中求中位数。思路：维护两个堆，一个最大堆，一个最小堆，并使之尽可能均衡。那么中位数就是两个堆顶元素做运算。 1234567891011121314151617class MedianFinder: def __init__(self): self.minq = [] self.maxq = [] def addNum(self, num: int) -&gt; None: heappush(self.minq, -heappushpop(self.maxq,-num)) if len(self.minq)-len(self.maxq)&gt;1: a = heappop(self.minq) heappush(self.maxq,-a) def findMedian(self) -&gt; float: if len(self.minq) != len(self.maxq): return self.minq[0] else: return (-self.maxq[0]+self.minq[0])/2 数组中抽两根做木桶，求最大容积是多少？双指针法（O(n)），两根指针往中间移动，丢弃较短的边并计算短边面积更新最大值。问题：丢弃短边会不会对后续的边计算面积产生影响？会！后续的边计算出来的面积并不是其客观最大值，但是其客观最大值已经被比他大的边（被抛弃的）计算过了，因而并不会出现漏算的情况。 数组中找到两数之和为目标值。O(n)做法：利用set存历史值，遍历数组的时候判断当前的匹配值是否在set里面。O(nlogn)做法：先排序，双指针向中间夹，这样可寻找非重复对。 数组中寻找某个值的左右边界。借助 bisect_left(target) 快速寻找左边界（不存在则顺位到下一个大值），bisect_left(target+delta)寻找目标值右边界（开区间） 数独填充问题。行列块各维护三个矩阵，合法的数独，填入一个新值时，三个矩阵的对应位应该都为False. 根据这个准则，可通过DFS来填充数独。 完全背包问题求所有合法组合。求组合路径一般用暴搜(DFS)+剪枝. 剪枝：①排序：可将大值区间直接丢弃 ②不回头：之前遍历过的元素不再遍历，只会重复计算。 0-1背包问题求所有合法组合。求组合路径一般用暴搜(DFS)+剪枝. 剪枝：①排序：可将大值区间直接丢弃 ②不回头：之前遍历过的元素不再遍历。③候选值若有重复，但是要求组合不能重复，需进一步剪枝，即同级遍历的时候，重复值需要跳过（if j&gt;i and candidates[j]==candidates[j-1]: continue） 数组中查找缺失的最小正整数。（资源值实现方法）时间O(n)空间O(1)的实现：正整数归位：数组长度为n,则值为1~n的整数可以归位，其他值随便占位。那么第一个值不对位的索引即为最小缺失值。 数组从开始跳到结束，求最小步数。需要求（第i步，第i步所能到的最大距离），当最大距离超过终点，步数即为所求。max_dis[i+1] = max(k+nums[k]) (k &lt; max_dis[i]) 数组全排列去重问题。重复排列是因为数组中有相同元素，只需保证在同级遍历中不重复遍历相同元素即可，可借助set实现。 关于图像翻转那些事。数学本质：两次翻转等于旋转。旋转180度：先左右翻转，再上下翻转。 顺时针90度：先上下翻转，再沿对角线（左上-右下）翻转。 逆时针90度：先左右翻转，再沿对角线翻转（左上-右下） 矩阵中对角线规律问题。反对角线：i+j为非负常数(0~2n-2) 正对角线：i-j为常数(-(n-1)~(n-1)) 因此对角线占位可压缩至一个值（N皇后问题） 连续子数组和的问题。借助前缀和：itertools.accumulate(nums) # initail=0 有序矩阵中查找目标值，行内,列内有序。分段查找：从右上角开始查，小了往下，大了往左。复杂度为O(m+n) 数组三种元素的快速原地排序。借助三指针，一根做移动，两根在两边定界。 DFS/BFS问题的三要素：停止条件，搜索动作空间，剪枝. 剪枝需将重复计算的分支或者不必计算的分支剪掉，利用@cache可起到重复计算剪枝的作用。 单调栈常见模型：找出每个数左/右边离它最近的且比它大/小的索引/数。 1234567stack = []left = [-1]*n for i in range(n): while stack and heights[i] &lt;= stack[-1][1]: stack.pop() if stack: left[i] = stack[-1][0] stack.append((i,heights[i])) 矩阵中(0-1组成)寻找最大的的1-矩形面积。用动态规划的复杂度比较高，若为正方形则适合。利用降维的思想，以每行为底去求此底以上的柱子所能组成的矩形最大面积。 原地合并两个有序数组。从大到小在较长数组后端填起。 从二叉树的前序遍历和中序遍历还原二叉树。借助哈希表和递归完成。若前序被换为后序遍历，原理一致。 12345678910111213def dfs(i,j,len): if len&lt;=0: return None k = i_map[preorder[i]] v = preorder[i] l = dfs(i+1,j,k-j) r = dfs(i+1+k-j,k+1,len-k+j-1) return TreeNode(v,l,r) i_map = &#123;&#125;for i,v in enumerate(inorder): i_map[v]=ireturn dfs(0,0,len(preorder)) 股票最大利润问题。交易次数不受限制，则赚取每相邻的增量必会得到最大值(贪心)。若交易次数(k次)受限制，则可以拆解为子问题，用动态规划求解。理解：股票操作的每一次状态均可以由上一次的动作转换而来。 1234567891011k = 2dp = [[0]*(2*k+1) for _ in range(len(prices))]for j in range(1,2*k+1,2): dp[0][j] = -prices[0]for i in range(1,len(prices)): for j in range(1,2*k+1): if j%2!=0: dp[i][j] = max(dp[i-1][j],dp[i][j-1]-prices[i]) else: dp[i][j] = max(dp[i-1][j],dp[i][j-1]+prices[i])return dp[-1][-1] 无序数组做复杂统计要求O(n)解法，大概率要借助哈希。哈希的构建是O(n)，查找是O(1). 如在复杂数组中统计存在的连续数字的最大长度，需要借助set存下整个数组，借助dict存某个数字为起点的连续数字长度。(dict[begin]=d[end]+(end-begin)) 1234567891011s = set(nums)d = defaultdict(int)ans = 0for v in nums: k = v while k in s: s.remove(k) k += 1 d[v] = d[k] + k-v ans = max(ans,d[v])return ans 环形站点，每个站点同时加油也耗油，求能环一圈的起点。思路：排除起点法。 ①总耗油&gt;总加油，必然无起点。② i点出发，j点亏油，那么i~j-1必然不是起点，且j点最适合作为新一轮起点。O(n)可解决以上问题 数组中某个值出现1次，其他值出现k次，找出该值的问题。bit统计即可： 123456789101112k = 3ans = 0for i in range(32): cnt = 0 for num in nums: cnt += (num&gt;&gt;i)&amp;1 if cnt % k: if i==31: ans -= 1&lt;&lt;i else: ans += 1&lt;&lt;ireturn ans 数组中有多少点在同一条直线的问题。 思路：遍历将每个点当成原点，则在同一条直线上的点斜率必定相同。剪枝：将某点定为原点后，计算斜率的点不考虑前面的点，已经计算过。 乘积最大子数组问题。动态规划：每一个乘积为负的子数组都有可能形成最大的子数组，因此要维护两个dp，一个存最大正值，一个存最小负值。 12dpmax[i] = max(dpmax[i-1]*v, dpmin[i-1]*v, v)dpmin[i] = min(dpmax[i-1]*v, dpmin[i-1]*v, v) 旋转有序数组寻找最小值 / 寻找目标值问题。利用二分法套固定模版即可解决。前提认知：① i-k-j, k的索引永远比j小，k的左移应该保守。 12345678910111213141516171819202122232425262728293031323334353637383940# 寻找最小值模板，i,j不断往最小值夹def findMin(self, nums: List[int]) -&gt; int: i,j=0,len(nums)-1 while i&lt;j: k = (i+j)//2 # k,j位于不同段, i右移 if nums[k]&gt;nums[j]: i = k+1 # k,j位于相同段, j左移 elif nums[k]&lt;nums[j]: j = k # 数组中有重复值情况，j保守左移 else: j -= 1 return nums[j]# 寻找目标值模板，i,j不断往目标值夹def search(self, nums: List[int], target: int) -&gt; int: i,j = 0,len(nums)-1 while i&lt;j: k = (i+j)//2 # k,j位于不同段 if nums[k]&gt;nums[j]: # 判断是否处于有序段 if nums[i]&lt;=target&lt;=nums[k]: j = k else: i = k+1 # k,j位于相同段 elif nums[k]&lt;nums[j]: # 判断是否处于有序段 if nums[k]&lt;target&lt;=nums[j]: i = k+1 else: j = k # 数组中有重复值情况，j保守左移 else: j -= 1 return j 桶排序问题。适用于数据范围比较小的数组且要求复杂度是O(n)的场景。对于桶宽和桶个数，一般定为：bucket_size = max((mx-mi)//(n-1),1) bucket_num = (mx-mi)//bucket_size+1 数组中某个值个数超出一半，需时间O(n) / 空间O(1) 找到他。摩尔投票：遍历数组，假设初始值为目标值，票数=1. 后面遇到相同数票数+1,不相同数票数-1. 最后票数&gt;0的那个数就是目标值。 将数组中的正数拼接，形成最大整数。排序: 规定 str(a)+str(b) &gt; str(b)+str(a) , 则认为str(a) &gt; str(b) 质数问题。质数不能直接递推，只能筛选。如正整数 n 以内的质数,利用埃氏消除法将合数消除掉,剩下的便是质数。 123456789def countPrimes(self, n: int) -&gt; int: primes = [True] * n ans = 0 for i in range(2, n): if primes[i]: ans += 1 for j in range(i + i, n, i): primes[j] = False return ans 二维矩阵搜索多目标字符串问题。若各个搜索目标字符串，会有大量重复搜索。优化思路是将多个字符串合并为一颗前缀树，在二维矩阵上搜索这棵树。 123456789101112131415161718192021222324252627282930313233343536373839404142class Trie: def __init__(self): self.d = &#123;&#125; self.end = &#x27;&#x27; def insert(self, word): node = self for c in word: if not c in node.d: node.d[c] = Trie() node = node.d[c] node.end = worddef findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: trie = Trie() for word in words: trie.insert(word) ans = [] m,n = len(board),len(board[0]) def dfs(i,j,node): c = board[i][j] if not c in node.d: return children = node.d[c] if children.end: ans.append(children.end) children.end = &#x27;&#x27; board[i][j] = &#x27;#&#x27; for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]: x,y = i+dx, j+dy if 0&lt;=x&lt;m and 0&lt;=y&lt;n and board[x][y] != &#x27;#&#x27;: dfs(x,y,children) board[i][j] = c for i in range(m): for j in range(n): dfs(i,j,trie) return ans 环形数组，不可相邻取值，求能取到的最大总和。展平成2个普通数组，一个去掉头，一个去掉尾，分别动态规划在求取最终最大值。 topK问题，要求O(n)实现。利用分治法实现。模板适用于topK问题(第K大/第K小/前K大/前K小/只排前K/只排后K) 12345678910111213141516171819202122232425def partition(nums, left, right): # 随机选择 pivot_index = random.randint(left,right) nums[pivot_index],nums[left] = nums[pivot_index],nums[left] pivot = nums[left] i,j = left, right while(i &lt; j): while(i&lt;j and nums[j]&gt;=pivot): j-=1 nums[i] = nums[j] while(i&lt;j and nums[i]&lt;=pivot): i+=1 nums[j] = nums[i] nums[i] = pivot return idef topk_split(nums, k, left, right): if (left&lt;=right): index = partition(nums, left, right) if index==k: return elif index &lt; k: topk_split(nums, k, index+1, right) else: topk_split(nums, k, left, index-1) 无序数组中寻找一定大小窗口内符合条件的一对数。利用SortedSet维护窗口内的值，并用二分法查找可将O(nk)降为O(nlogk) 无序数组中寻找众数,要求时间O(n),空间O(1). 摩尔投票法：若要求超过 n/k 的票数，则k个不同数依次抵消，最后至多剩余(k-1)个候选值，遍历验证筛选。 1234567891011def majorityElement(self, nums: List[int]) -&gt; List[int]: k = 3 ctr = collections.Counter() for num in nums: ctr[num] += 1 # at most two Majority Elements if len(ctr) &gt; k-1: # minus one for all elements in ctr ctr -= collections.Counter(set(ctr)) return [n for n in ctr if nums.count(n) &gt; len(nums)/3] 无序有重数组，滑窗K向前滚动，求每个滑窗的最大值。 一般用遍历+有序结构可实现O(n*logK),由于存在重复值，维护结构需将索引存入。以下是用有限队列实现。 12345678910def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: q = [(-v,i) for i,v in enumerate(nums[:k-1])] heapify(q) ans = [] for i in range(k-1,len(nums)): heappush((-nums[i],i)) if q[0][1] &lt;= i-k: heappop(q) ans.append(-q[0][0]) return ans 一个连续数数组中出现了一个重复值，找出该值。空间O(1)做法：二分枚举目标值，然后统计左右两边哪一部分个数比预期的大1，目标即在那一边。 1234567891011121314151617def findDuplicate(self, nums: List[int]) -&gt; int: nlen = len(nums) low = 1 high = nlen - 1 while low &lt; high: mid = (high + low) // 2 cnt = 0 for item in nums: if item&lt;=mid: cnt += 1 if cnt &lt;= mid: low = mid + 1 else: high = mid return low 无序数组中寻找最长递增子序列的长度。可用动态规划O(n*n). 或者利用二分查找实现O(nlogn) 12345678d = [nums[0]]for h in nums[1:]: if h &gt; d[-1]: d.append(h) else: idx = bisect_left(d, h) d[idx] = hreturn len(d) leetcode-312 戳气球分析，问题转换为：① 左右补元素1，左右边界不戳破，戳破开区间(0,n+1)能获得的最大值。 ②拆解为子问题，若最后戳破k,则 dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+v[k]∗v[i]∗v[j])dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+v[k]*v[i]*v[j])dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+v[k]∗v[i]∗v[j]) ③ i依赖比它大的值k, j依赖比它小的值k, 则i应该从大往小遍历。 完全背包问题的dp空间缩减法。i代表目标值，j代表前j各物品。i存在前向依赖必须记忆化搜索，而物品由于可重复选择不存在依赖，j这一维可以省去，用for循环代替。 完全背包问题的dp解法，nums[j]只需要考虑0-1的情况，不需要考虑n的情况，因为n可由1递推。 字符串s和p的正则匹配问题。动态规划：关键在于处理 s[j]==’*'的场景,注意 * 的通配能力。且i=0这一行需要初始化计算，应付开头含有p开头含有 *的情况。 123456789101112131415161718def isMatch(self, s: str, p: str) -&gt; bool: m, n = len(s), len(p) f = [[False] * (n + 1) for _ in range(m + 1)] f[0][0] = True for j in range(1,n+1): if p[j - 1] == &quot;*&quot;: f[0][j] = f[0][j - 2] | f[0][j-1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == &quot;*&quot;: # *为0的情况，x*整体去掉 f[i][j] = f[i][j - 2] # *为1的情况, i退1, j不变, 看最后字符是否匹配 if p[j - 2] == &quot;.&quot; or s[i - 1] == p[j - 2]: f[i][j] |= f[i - 1][j] elif p[j - 1] == &quot;.&quot; or s[i - 1] == p[j - 1]: f[i][j] = f[i - 1][j - 1] return f[m][n] w1编辑成w2字符串的最小编辑次数。动态规划：w1[i]=w2[j]时，编辑距离不变。w1[i]!=w2[j]时,需要分别求出增删改那个最小并+1. 初值需要根据实际意义进行初始化。增：i匹配j-1 删：i-1匹配j 改：i-1匹配j-1 1234567891011121314def minDistance(self, word1: str, word2: str) -&gt; int: m,n = len(word1),len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for j in range(1,n+1): dp[0][j] = j for i in range(1,m+1): dp[i][0] = i for i in range(1,m+1): for j in range(1,n+1): if word1[i-1]==word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1 return dp[-1][-1] leetcode-87 扰乱字符串问题。动态规划(区间DP)：把子问题定义为s1从i开始，s2从j开始，长为k个字符是否是扰乱字符串。那么不颠倒：f[i][j][k]=f[i][j][h]∧f[i+h][j+h][k−h],h=[1,k)f[i][j][k] = f[i][j][h] \\land f[i + h][j + h][k - h] ,h=[1,k)f[i][j][k]=f[i][j][h]∧f[i+h][j+h][k−h],h=[1,k) 。 颠倒： $f[i][j][k] = f[i][j + k - h][h] \\land f[i + h][j][k - h] ,h=[1,k) $ 1234567891011121314151617def isScramble(self, s1: str, s2: str) -&gt; bool: n = len(s1) f = [[[False] * (n + 1) for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): f[i][j][1] = s1[i] == s2[j] for k in range(2, n + 1): for i in range(n - k + 1): for j in range(n - k + 1): for h in range(1, k): if f[i][j][h] and f[i + h][j + h][k - h]: f[i][j][k] = True break if f[i + h][j][k - h] and f[i][j + k - h][h]: f[i][j][k] = True break return f[0][0][n] 有序数组组成二叉搜索树。递归建树：选取某个点作为根节点，则左边组为左子树，右边组为右子树。组成二叉搜索树的数目：dp[i] = sum(dp[j-1]*dp[i-j]), j∈[1,i] 动态规划问题拆分：子问题尽可能大，计算复杂度低。dp初值确认问题，根据需求推导：某个子问题最终会依赖这个初值，根据实际情况来推导这个初值是多少。 二叉树的最大路径和问题。二叉树天然适合用DFS, 递归的取每个点为根节点并计算其路径和是否为最大值。DFS返回只能带一颗子树。 回文串问题，可以利用 s[i:j]==s[i:j][::-1] 来原始的解决子问题，如何有效率问题，再考虑用其他方法如动态规划来解决。Leetcode-132 最少切几刀还是回文串的问题，两层动态规划优化效率。 123456789101112131415161718def minCut(self, s: str) -&gt; int: n = len(s) f = [[False]*(n) for _ in range(n)] for i in range(n-1,-1,-1): for j in range(i,n): if j-i&lt;=1: f[i][j] = (s[i]==s[j]) else: f[i][j] = (s[i]==s[j] and f[i+1][j-1]) dp = [inf]*(n+1) dp[0] = -1 for j in range(1,n+1): for i in range(j): if f[i][j-1]: dp[j] = min(dp[j],dp[i]+1) # print(f,dp) return dp[-1] 四则运算表达式，套优先级求所有可能答案。由于表达式能转换为二叉树，因此天然适用于DFS解决。并且DFS会有重复子树计算，利用@cache消除重复。 12345678910111213141516171819202122def diffWaysToCompute(self, expression: str) -&gt; List[int]: @cache def dfs(exp): if exp.isdigit(): return [int(exp)] ans = [] for i,c in enumerate(exp): if c in [&#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;]: left = dfs(exp[:i]) right = dfs(exp[i+1:]) for a in left: for b in right: if c==&#x27;*&#x27;: ans.append(a*b) elif c==&#x27;+&#x27;: ans.append(a+b) elif c==&#x27;-&#x27;: ans.append(a-b) return ans return dfs(expression) 第n个丑数。丑数认知：可由前面数递推计算出来，但是计算出来的值不保证顺序且可能重复。方法：维护一个有序数组，且里面的值不重复，那么优先队列是不错的选择，可借助set去重。 123456789101112def nthUglyNumber(self, n: int) -&gt; int: h = [1] vis = set([1]) for _ in range(n): ans = heappop(h) for f in [2,3,5]: newv = f*ans if not newv in vis: heappush(h,newv) vis.add(newv) return ans 树形DP，二叉树选取点使总和最大，要求点不相邻。思路与数组DP基本一致，但是朴素解法会涉及到孙节点，代码上不好处理。因此可采用技巧，每个节点返回包含和不包含改节点值的最大值，可取消对孙节点的依赖。 123456789def rob(self, root: Optional[TreeNode]) -&gt; int: def dfs(root): if not root: return 0,0 la,lb = dfs(root.left) ra,rb = dfs(root.right) return root.val+lb+rb, max(la,lb)+max(ra,rb) return max(dfs(root)) 轰炸敌人游戏（leetcode361）。原始解法：遍历每个空格，对每个空格进行上下左右延伸, O(m∗n∗(m+n))O(m*n*(m+n))O(m∗n∗(m+n)). 优化：对每个点进行一次上下左右前缀和计算，4个前缀和相加便是目标，O(4∗m∗n)O(4*m*n)O(4∗m∗n) . 最长子序列求最长组合。dp解法：先利用dp找到最长子序列的尾巴，然后顺着dp数组找前一个。 当问题可拆解为某个区间子问题的解时，可用区间dp. 区间dp可能对后值产生依赖，因此得反向遍历。 s1是否s2的子序列问题，子序列不要求连续。双指针：贪心匹配，如果贪心匹配不能满足，那么结果肯定不能满足。 对于目标值，如果跟某个约束条件成单调关系的话，且能check是否符合约束条件，则可以用二分法搜索目标值。 如分割数组成k个子数组，使子数组的最大和最小化，求该值。目标值与k有线性关系。目标值越大，k越小；目标值越小，k越大，那么可以用二分逐渐去逼近答案。 如n个包裹要在m天内送走，求最小运载能力。运载越大，天数越少。运载越小，天数越大。可以用二分法逼近。 12345678910111213141516171819202122def check(target): res = 0 day_sum = 0 for v in weights: day_sum += v if day_sum&gt;target: day_sum = v res += 1 return res + 1 left,right = max(weights),sum(weights)while left&lt;right: mid = (left+right)//2 n = check(mid) if n&lt;days: right = mid elif n&gt;days: left = mid +1 else: right = midreturn left leetcode-446 求等差子序列的组合总数，可重复。动态规划：子问题为：以当前值为等差序列末尾，组合总数 = 每一个前元素为末尾的弱等差序列的总数和。 123456789def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int: f = [defaultdict(int) for _ in nums] ans = 0 for i, x in enumerate(nums): for j, y in enumerate(nums[:i]): d = x - y ans += f[j][d] f[i][d] += f[j][d] + 1 return ans 小猪试毒问题。一只小猪试n次，可检验n+1瓶水。那么两只便是 (n+1)^2 瓶水，三只便是(n+1)^3 瓶水. why？用N进制的角度思考，为每瓶水编号。每只猪负责一个进制位，每个进制位有N个可能值。实验(N-1)次总能试出该进制位哪个值有毒，多只同时试答案就出来了。 博弈问题，一般可以天然拆成子问题，即每一回合最优问题。对于每一回合，若存在一种选择使得下一回合输，便有必胜的把握。如leetcode-464,为了减少搜索次数，尽可能使用状态压缩和记忆化搜索。 123456789101112def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -&gt; bool: @cache def dfs(mask,desired): for i in range(maxChoosableInteger-1,-1,-1): if not mask&amp;(1&lt;&lt;i) and (i+1)&gt;=desired: return True if not mask&amp;(1&lt;&lt;i) and not dfs(mask|(1&lt;&lt;i),desired-(i+1)): return True return False if (1 + maxChoosableInteger) * maxChoosableInteger // 2 &lt; desiredTotal: return False return dfs(0,desiredTotal) 谁的数量多博弈问题。只能在数组的头尾选数字，问最终谁的数量多。子问题：我跟对手的最大差值是多少。善用记忆化搜索，模板如下： 1234567def stoneGame(self, piles: List[int]) -&gt; bool: @cache def dfs(i,j): if i&gt;j: return 0 return max(piles[i]-dfs(i+1,j),piles[j]-dfs(i,j-1)) return dfs(0,len(piles)-1)&gt;0 先手数量最多是多少的博弈问题。子问题：对手数量最多是多少，那么我的数量就是当前可选的总和-对手数量最多。善用记忆化搜索。 火柴拼正方形问题。剪枝技巧：①四条边同时统计 ②若存在两条边相等，那么对第二条不要再次尝试。③排序，先消耗大根可减少回溯次数. 三维0-1背包问题。leetcode-474 目标值多了一维,可用三维dp解决。也可以用记忆化dfs解决。 12345678910111213141516171819202122232425262728def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: dp = [[[0]*(len(strs)+1) for _ in range(n+1)] for _ in range(m+1)] for i in range(m+1): for j in range(n+1): if i==0 and j==0: continue for k in range(1,len(strs)+1): a,b = strs[k-1].count(&#x27;0&#x27;),strs[k-1].count(&#x27;1&#x27;) dp[i][j][k] = dp[i][j][k-1] if i-a&gt;=0 and j-b&gt;=0: dp[i][j][k] = max(dp[i][j][k],dp[i-a][j-b][k-1]+1) return dp[-1][-1][-1]def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: cnt0 = [s.count(&#x27;0&#x27;) for s in strs] @cache # 缓存装饰器，避免重复计算 dfs 的结果（记忆化） def dfs(i: int, j: int, k: int) -&gt; int: if i &lt; 0: return 0 res = dfs(i - 1, j, k) # 不选 strs[i] cnt1 = len(strs[i]) - cnt0[i] if j &gt;= cnt0[i] and k &gt;= cnt1: res = max(res, dfs(i - 1, j - cnt0[i], k - cnt1) + 1) # 选 strs[i] return res return dfs(len(strs) - 1, m, n) 寻找子字符串问题。暴力方法:O(n*m) KMP: O(n+m) 根据子串p算出跳转表。p进行有效跳转，不是傻傻的回到起点。而原串s永远不走回头路，一路走到底。 把跳转表用next数组表示, next[i-1]表示以p[i-1]结尾的子串，其最大公共前后缀长度。那么当p[i]不匹配s时,p[0:i]是与s匹配的, 那么p可以跳转到next[i-1]处，继续与s匹配。对于next数组的构造，同样可以借助上面的思想，以i为后缀结尾，j为前缀结尾，当p[i]!=p[j]时，j退回至next[j-1]继续匹配。 12345678910111213141516171819202122232425def strStr(self, haystack: str, needle: str) -&gt; int: def build_next(p): next = [0]*len(p) j = 0 # 指向前缀末尾 for i in range(1,len(p)): # i指向后缀末尾 while j&gt;0 and p[i]!=p[j]: # 回退到j-1最长公共前后缀处 j = next[j-1] if p[i]==p[j]: j += 1 next[i] = j return next # next表示以当前字符为结尾的最大公共前后缀长度 next = build_next(needle) j = 0 for i in range(len(haystack)): while j&gt;0 and haystack[i]!=needle[j]: j = next[j-1] if haystack[i]==needle[j]: j += 1 if j==len(needle): return i-j+1 return -1 滑动窗口问题。使用滑动窗口时，尽可能处理头尾进出的两个元素，中间元素尽可能不要重复计算。 leetcode-65 检验合法数字。将字符串以 e/E 进行分割后，其实规则十分简单： ① 如果存在 e/E ：左侧可以「整数」或「浮点数」，右侧必须是「整数」 ② 如果不存在 e/E ：整段可以是「整数」或「浮点数」 ③ 关键在于如何实现一个 check 函数用于判断「整数」或「浮点数」： +/- 只能出现在头部 . 最多出现一次 至少存在一个数字 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def check(self,s, start, end, mustInterger): if start &gt; end: return False # 正负号合法位置检验 if s[start] in [&#x27;+&#x27;,&#x27;-&#x27;]: start += 1 hasDot = hasNum = False for i in range(start, end+1): if s[i] == &#x27;.&#x27;: if mustInterger or hasDot: return False hasDot = True elif &#x27;0&#x27;&lt;=s[i]&lt;=&#x27;9&#x27;: hasNum = True else: return False return hasNum def isNumber(self, s: str) -&gt; bool: n = len(s) # 1. 只有一个e idx = -1 for i in range(n): if s[i] in [&#x27;e&#x27;,&#x27;E&#x27;]: if idx==-1: idx=i else: return False ans = True # 2.检查e左边是否是整数或者浮点数 # 3.检查e右边是否是整数 if idx != -1: ans &amp;= self.check(s,0,idx-1,False) ans &amp;= self.check(s,idx+1,n-1,True) # 4.检查是否是整数或者是浮点数 else: ans &amp;= self.check(s,0,n-1,False) return ans 覆盖目标串字符个数的最小子串问题。显然用滑动窗口(双指针)+字符统计可解决。当指针j滑到满足字符统计个数了，就应该收缩i直到刚好满足。那么在滑动的时候如何高效比对是否满足统计？可维护一个need_set加速比对。 12345678910111213141516171819202122232425def minWindow(self, s: str, t: str) -&gt; str: need_set = set([c for c in t]) cnt_t = Counter(t) cnt_s = Counter() i = 0 ans = &#x27;&#x27; for j in range(len(s)): # 维护need_set，减少对字符的需求 cnt_s[s[j]] += 1 if s[j] in need_set and cnt_s[s[j]]&gt;=cnt_t[s[j]]: need_set.remove(s[j]) # 无需求时，则说明到了，缩减起点 i if not need_set: while i&lt;=j: cnt_s[s[i]] -= 1 if s[i] in cnt_t and cnt_s[s[i]]&lt;cnt_t[s[i]]: if not ans: ans = s[i:j+1] else: ans = ans if j-i+1&gt;len(ans) else s[i:j+1] need_set.add(s[i]) i += 1 break i += 1 return ans 交错字符串问题。s1和s2能否任意交错的组成s3. 其子问题便是前i个s1和前j个s2能否交错的组成前i+j个s3, 天然可用动态规划解决。 单词接龙问题，求转化步数。思路：构建邻接转换表，在转换表上进行BFS即可。 12345678910111213141516171819202122232425262728def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int: word_set = set(wordList) if not endWord in word_set: return 0 if not beginWord in word_set: word_set.add(beginWord) n_map = defaultdict(list) for w in word_set: for i in range(len(w)): key = w[:i]+&#x27;_&#x27;+w[i+1:] n_map[key].append(w) q = deque([beginWord]) vis = set([beginWord]) step = 1 while q: for _ in range(len(q)): w = q.popleft() for i in range(len(w)): key = w[:i]+&#x27;_&#x27;+w[i+1:] for next_w in n_map[key]: if next_w==endWord: return step+1 if not next_w in vis: vis.add(next_w) q.append(next_w) step += 1 return 0 leetcode-126 单词接龙进阶版。要求要把所有的最短路径打印出来，且性能卡的比较严。① 一般的，所有路径用DFS，我们搜索所有可转换路径并筛选出最短的。超时，因为分支巨多。 ② 那么我们做一下剪枝，先用BFS求最少步数，再用DFS把符合该步数的所有路径找出来。这样可以把超过目标深度的分支剪掉。遗憾的是，还是超时，因为一旦候选词列表很长，那么这颗树会很宽。③ 额，不对啊，BFS已经帮我走了这么多路了，我DFS怎么还又走一遍。他走到终点我沿着他的路走回去不就好了。那么，BFS走的时候标记反向回溯表，DFS从终点走到起点。 123456789101112131415161718192021222324252627282930313233343536373839def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; List[List[str]]: word_set = set(wordList) if not endWord in word_set: return [] if not beginWord in word_set: word_set.add(beginWord) n_map = defaultdict(list) for w in word_set: for i in range(len(w)): key = w[:i]+&#x27;_&#x27;+w[i+1:] n_map[key].append(w) n = len(beginWord) q=deque([(beginWord,1)]) visited=&#123;beginWord:1&#125; prewords=defaultdict(list) while q: cur_word,level=q.popleft() for i in range(n): directions=cur_word[:i]+&#x27;_&#x27;+cur_word[i+1:] for next_word in n_map[directions]: if next_word not in visited: visited[next_word]=level+1 q.append((next_word,level+1)) if visited[next_word]==level+1: prewords[next_word].append(cur_word) # 注意这里，因为要求出所有路径，需把有终点的那一层全部遍历完 if endWord in visited and visited[endWord]==level: break res=[] def dfs(path,word): if word==beginWord: res.append([word]+path) return for pre in prewords[word]: dfs([word]+path,pre) dfs([],endWord) return res 分割字符串，使所有的子串都为回文串的所有方案。所有方案,显然用DFS,那么DFS总是在每层尝试将当前位置为起点的所有回文子串加入到path中，但是这样判断是否回文子串很费时间，可以借助区间DP先把s[i:j]是否为回文串先存起来，以空间换时间。 10 进制转N进制数，若 N 进制从 1 开始，则求余数前应该减 1 以对齐。 数组的自定义排序，leetcode-179 1234def largestNumber(self, nums: List[int]) -&gt; str: nums = [str(v) for v in nums] nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b &lt; b + a else -1)) return &quot;0&quot; if nums[0] == &quot;0&quot; else &quot;&quot;.join(nums) 比对两字符串是否属于同一模式。思路1：可对字符串进行模式编码，再比对模式。思路2：若属于同一模式，则两字符串可相互映射。即s1可映射到s2, s2可映射到s1, 两个字典即可实现。 123456789101112131415161718192021222324252627def isIsomorphic(self, s: str, t: str) -&gt; bool: def get_p(s): d = &#123;&#125; p = &#x27;&#x27; for c in s: if c not in d: d[c] = chr(ord(&#x27;a&#x27;)+len(d)) p += d[c] return p p1 = get_p(s) p2 = get_p(t) # print(p1,p2) return p1==p2def wordPattern(self, pattern: str, s: str) -&gt; bool: d1 = &#123;&#125; d2 = &#123;&#125; words = s.split() if len(words) != len(pattern): return False for p,w in zip(pattern,words): if (p in d1 and d1[p]!=w) or (w in d2 and d2[w]!=p): return False d1[p] = w d2[w] = p return True 前缀树实现方法。 12345678910111213141516171819202122232425262728293031class Trie: def __init__(self): self.d = &#123;&#125; self.isend = False def insert(self, word: str) -&gt; None: node = self for c in word: if not c in node.d: node.d[c] = Trie() node = node.d[c] node.isend = True def search(self, word: str) -&gt; bool: node = self for c in word: if not c in node.d: return False else: node = node.d[c] return node.isend def startsWith(self, prefix: str) -&gt; bool: node = self for c in prefix: if not c in node.d: return False else: node = node.d[c] return True 求字符串的最长回文串前缀。O(n)做法：回文串特点，翻转仍相等。那么原始字符串翻转形成s2，s1前缀=s2后缀,求的便是最大公共前后缀。可联想至KMP，将s1拼接s2, 求next数组，next[-1]即为所求。 1234567891011121314def shortestPalindrome(self, s: str) -&gt; str: t = s+&#x27;#&#x27;+s[::-1] n = len(t) next = [0]*(n) i = 0 for j in range(1,n): while i and t[j]!=t[i]: i = next[i-1] if t[j]==t[i]: i += 1 next[j] = i return s[next[-1]:][::-1]+s 普通四则运算不带括号，一次遍历做法：栈，遇到乘除则把栈尾部数字拿出来算结果，再压进去。遇到加减则合并该符号成为正数或者负数。最后栈剩下的都是数字，求和即可。 整数转英文表示。按1e3来解构计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def numberToWords(self, num: int) -&gt; str: if num == 0: return &#x27;Zero&#x27; lt20 = [ &#x27;&#x27;, &#x27;One&#x27;, &#x27;Two&#x27;, &#x27;Three&#x27;, &#x27;Four&#x27;, &#x27;Five&#x27;, &#x27;Six&#x27;, &#x27;Seven&#x27;, &#x27;Eight&#x27;, &#x27;Nine&#x27;, &#x27;Ten&#x27;, &#x27;Eleven&#x27;, &#x27;Twelve&#x27;, &#x27;Thirteen&#x27;, &#x27;Fourteen&#x27;, &#x27;Fifteen&#x27;, &#x27;Sixteen&#x27;, &#x27;Seventeen&#x27;, &#x27;Eighteen&#x27;, &#x27;Nineteen&#x27;, ] tens = [ &#x27;&#x27;, &#x27;Ten&#x27;, &#x27;Twenty&#x27;, &#x27;Thirty&#x27;, &#x27;Forty&#x27;, &#x27;Fifty&#x27;, &#x27;Sixty&#x27;, &#x27;Seventy&#x27;, &#x27;Eighty&#x27;, &#x27;Ninety&#x27;, ] thousands = [&#x27;Billion&#x27;, &#x27;Million&#x27;, &#x27;Thousand&#x27;, &#x27;&#x27;] def transfer(num): if num == 0: return &#x27;&#x27; if num &lt; 20: return lt20[num] if num &lt; 100: return tens[num // 10] + &#x27; &#x27; + transfer(num % 10) return lt20[num // 100] + &#x27; Hundred &#x27; + transfer(num % 100) res = [] i,j = 1000000000,0 while i&gt;0: if num//i != 0: res.append(transfer(num//i)) res.append(thousands[j]) num %= i i = i //1000 j += 1 return &#x27; &#x27;.join(res) 去除重复字母，返回最小字典序不重复字符串。leetcode-316. 维护一个最优栈，如果新加字符不在栈内，那么弹出栈顶那些比它大并且后面还会出现的。对于新加字符已经在栈内有的，无需处理，因为栈内已经是最优。需要借助set来维护栈内已经有的元素，需要借助dict来维护元素出现的最后位置以判断后面是否有某个元素再次出现。 12345678910111213def removeDuplicateLetters(self, s: str) -&gt; str: idx_d = &#123;c:i for i,c in enumerate(s)&#125; vis = set() stk = [] for i,c in enumerate(s): if c in vis: continue while stk and stk[-1]&gt;c and idx_d[stk[-1]]&gt;i: k = stk.pop() vis.remove(k) stk.append(c) vis.add(c) return &#x27;&#x27;.join(stk) 验证二叉树前序遍历序列的合法性，leetcode-331. 消除法，借助栈，遇到 x-#-# 则消除为 # , 直到最后栈内只剩下 # 即为合法。 K个有序链表/数组合并成一个。借助最小堆，先取K个头元素压进最小堆。每弹出一个，则取弹出元素的下一个入堆。 12345678910111213def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: ListNode.__lt__ = lambda a,b: a.val&lt;b.val pre = dummy = ListNode() h = [head for head in lists if head] heapify(h) while h: node = heappop(h) if node.next: heappush(h,node.next) pre.next = node pre = node return dummy.next LRU的实现，要求增删查都是O(1). 借助字典和链表实现，字典存储K-V，其中V是链表的node节点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class ListNode: def __init__(self,k=0,v=0,pre=None,next=None): self.val = v self.key = k self.pre = pre self.next = nextclass LRUCache: def __init__(self, capacity: int): self.cnt = 0 self.cap = capacity self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.pre = self.head self.d = &#123;&#125; def get(self, key: int) -&gt; int: if key in self.d: node = self.d[key] node.pre.next = node.next node.next.pre = node.pre node.next = self.head.next node.pre = self.head node.next.pre = node self.head.next = node return node.val return -1 def put(self, key: int, value: int) -&gt; None: if self.get(key)!=-1: self.head.next.val = value return node = ListNode(key,value,self.head,self.head.next) self.d[key] = node self.head.next.pre = node self.head.next = node self.cnt += 1 if self.cnt&gt;self.cap: node = self.tail.pre node.pre.next = self.tail self.tail.pre = node.pre self.d.pop(node.key) self.cnt -= 1","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://xie-peiquan.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://xie-peiquan.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"模型量化相关文章","slug":"机器学习/模型量化相关文章","date":"2025-11-24T06:30:16.000Z","updated":"2025-11-04T10:40:22.251Z","comments":true,"path":"2025/11/24/机器学习/模型量化相关文章/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/11/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/","excerpt":"","text":"章小龙的： Int8量化-介绍（一）：https://zhuanlan.zhihu.com/p/58182172 Int8量化-python实现以及代码分析（二）：https://zhuanlan.zhihu.com/p/58208691 虫叔的： Int8量化-ncnn社区Int8重构之路（三）：https://zhuanlan.zhihu.com/p/61451372 Int8量化-Winograd量化原理及实现（四）：https://zhuanlan.zhihu.com/p/67718316 田子寰的： NCNN Conv量化详解（一）：https://zhuanlan.zhihu.com/p/71881443 NCNN 量化详解（二）：https://zhuanlan.zhihu.com/p/72375164","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"泰迪杯2022电力负荷预测赛题分析","slug":"机器学习/泰迪杯 2022 电力负荷预测","date":"2025-08-20T06:30:16.000Z","updated":"2025-08-21T06:40:32.477Z","comments":true,"path":"2025/08/20/机器学习/泰迪杯 2022 电力负荷预测/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/08/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B3%B0%E8%BF%AA%E6%9D%AF%202022%20%E7%94%B5%E5%8A%9B%E8%B4%9F%E8%8D%B7%E9%A2%84%E6%B5%8B/","excerpt":"","text":"1 基本概念 平稳性：一个序列的均值、方差和协方差不随时间变化。平稳序列更容易被预测。 自回归：一个序列当前时间点的观测值与之前时刻的值存在线性依赖关系。 单位根：一个自回归过程中，yt=byt−1+a+ϵty_{t} = by_{t-1} + a + \\epsilon _{t}yt​=byt−1​+a+ϵt​ ，如果滞后项系数 b 为1，就称为单位根。当单位根存在时，序列的平稳性遭破坏。 ADF检验：（Augmented Dickey-Fuller），是判断序列是否平稳的重要指标。其原理在于判断序列是否存在单位根：存在单位根，序列不平稳；不存在，序列平稳。 一般的，ADF会有 假设H₀：序列存在单位根，并会求出显著性检验统计量 和 p值，当 p 值小于0.05 且 统计量小于三个置信度（10%，5%，1%），则对应有（90%，95，99%）的把握来拒绝原假设，即序列平稳。 ACF自相关：指序列当前时刻值 yty_{t}yt​ 与其自身的滞后值 yt−1,yt−2y_{t-1},y_{t-2}yt−1​,yt−2​ … 之间的线性关系。常用于检测序列的长期依赖和周期性。 PACF偏自相关：yty_{t}yt​ 在排除中间滞后项（yt−1,yt−2,…,yt−k+1y_{t−1},y_{t−2},…,y_{t−k+1}yt−1​,yt−2​,…,yt−k+1​）的干扰后，与 yt−ky_{t−k}yt−k​的“净”相关性。常利用其截尾性确定模型参数。 自相关性在模型中的作用：在PACF截尾，ACF拖尾的情况下，PACF更适合确定AR模型（p值）；而在ACF截尾，PACF拖尾的情况下，ACF更适合确定MA模型（q值）。 2 数据探索 原始数据集： https://tianchi.aliyun.com/dataset/150857 思路：根据经验猜测居民用电与哪些因素有关，拉取相关数据出来进行相关性分析。 猜测，影响居民用电量的相关因素有：①用电周期性（日/周/年 周期性）②节假日 ③天气和温度 拓展，影响网络流量的相关因素：①上网周期性（日/周 周期性）②购物节 ③时事热点 ④节假日 2.1 平稳性&amp;自相关性分析 ADF平稳性检验 12from statsmodels.tsa.stattools import adfulleradfuller(data_plot[&#x27;总有功功率（kw）&#x27;]) Test Statistic -6.674 p-value 4.497e-09 Critical value(1%) -3.437 Critical value(5%) -2.864 Critical value(10%) -2.568 上表可见统计量小于三个置信度，且p值小于0.05，拒绝原假设，时间序列是平稳序列。 自相关性分析 我们取近两个月的数据（96*60个点）分析序列的自相关性，如下图可以发现前600多个点在置信区间以外，即当前点与前600多个点有一定的相关性，这对我们后面做滑窗取点有一定的启发性。 1234from statsmodels.graphics.tsaplots import plot_acffig, ax = plt.subplots(figsize=(12, 4))plot_acf(data.iloc[:5760][&#x27;总有功功率（kw）&#x27;].values, lags=1000, linestyle=&#x27;--&#x27;,ax=ax)plt.show() 2.2 用电周期性探索 我们截取原始数据中 2019/8/12 (星期一)开始的两个星期的用电数据(下图1)，可以发现：用电量有日周期性，符合人每天的作息规律；同时用电量有周周期性，符合企业的每周作息规律；截取原始数据中2019/01~2021/09年的用电数据(下图2)，发现用电量有年周期性，符合人类用电的季节性规律。 2.3 节假日因素影响 我们对每天的用电量进行聚合，并用粉红背景标注出中国的节假日，可以发现：在节假日 (尤其是长假) 前后，用电量有明显的减少，符合节假日企业停工的规律。 2.4 天气温度因素影响 我们对每天的用电量进行聚合，同时拉取每天的最高和最低温度，同时绘图如下，可以发现：每天的用电量和气温呈现极强的正相关性，符合居住环境制冷 或者 企业设备散热的一般规律。 3 预处理&amp;特征工程 重复值处理：去除时间点重复的行，避免时间聚合或者拼表出现问题。 缺失值处理：对时间点缺失的数据进行填补，线性插值即可。 异常值处理：离群点有几种情况：非节假日断电维修、负荷异常跳高、节假日断电。前两种是不可预估异常情况，需处理，剔除并线性插值即可；第三种是负荷的重要特点，无需处理。 序列滤波：对序列进行卷积滤波 / 卡尔曼滤波 / 变分模态分解，得到一个噪声较小的序列，利于预测模型收敛。 归一化：消除量纲，利于模型收敛；相应的，模型输出需要进行反归一化，还原出有实际意义的预测值。 滑窗取输入输出：(可选) 对于一些模型如LSTM，需要利用滑窗构造输入输出点；在自相关性分析中，当前点与前672个点有关，则滑窗可设置为【672,1】滑动选取。 文本编码：对天气状况，风向等文本进行量化编码。如天气状况：【‘晴’, ‘多云’, ‘阴’, ‘小雨’, ‘小雨-中雨’, ‘中雨’, ‘中雨-大雨’,‘大雨’ 】 其中隐藏状况由好到坏的情况直接进行数值编码 0~7 即可。风向同理。另外，对于节假日，我们可以根据【‘大长假’，‘小长假’，‘短假’，平常日】进行数值3~0的编码。 综上，我们会得到一组多维时序，包括用电量、天气情况、最高温度、最低温度、风向等级、节假日标识。根据多维信息预测单维序列。 4 预测模型 时序预测类任务挺考验模型自身能力，我们可以多尝试一些模型来评估拟合效果。比如传统机器学习的LGBM回归器 / Prophet / ARIMA，基于CNN或RNN的一些时序模型。如果不考虑算力，还可以尝试基于transformer的一些时序模型。在本题中，基于LSTM的优化模型已经可以取的不错的成绩，我们可以借鉴优秀队伍的模型调优思路。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"DCIC2020 智慧海洋建设赛题分析","slug":"机器学习/DCIC 2020 智慧海洋建设","date":"2025-08-16T06:30:16.000Z","updated":"2025-08-16T07:10:53.455Z","comments":true,"path":"2025/08/16/机器学习/DCIC 2020 智慧海洋建设/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DCIC%202020%20%E6%99%BA%E6%85%A7%E6%B5%B7%E6%B4%8B%E5%BB%BA%E8%AE%BE/","excerpt":"","text":"1 赛题任务 本赛题为智能算法赛，主题是基于位置数据对海上目标进行智能识别和作业行为分析，要求选手通过分析渔船北斗设备位置数据，得出该船的生产作业行为，具体判断出是拖网作业、围网作业还是流刺网作业。 赛题链接：https://tianchi.aliyun.com/competition/entrance/231768/introduction?spm=a2c22.21852664.0.0.1cbc6975cQNixf 2 数据探索 原始数据：比赛提供的数据为每艘渔船在作业时间段内的时序数据(csv文件)，内容包括经纬度、速度、方向和上报时间点，需根据时序判断渔船的作业类型。 2.1 初识数据 我们对其中的一艘拖网渔船数据进行绘制，如下可以发现： 渔船轨迹存在异常离群点，速度和方向角数据存在较大噪声，且上报有断点。 海洋运动不受道路几何结构的约束，其运动模式更为多样和复杂。 2.2 提出问题 同一种作业类型是否有相似的轨迹模式？ 作业类型与经纬度位置是否有一定关系？ 速度和转角是否代表一定的行为模式？ 2.3 数据探索 问题1：同一种作业类型是否有相似的轨迹模式？ 对三种作业方式的渔船进行抽样画图如下(拖网作业–Class 0、围网作业–Class 1、流刺网作业–Class 2)，可发现同一种作业类型的活动轨迹相当随机，没有较为明显的模式。这意味着通过轨迹图来进行图片分类的方法大概率走不通。 问题2：作业类型与经纬度位置是否有一定关系？ 对三种作业方式的活动经纬度进行绘制（左中右分别对应刺网、拖网、围网），发现两者存在一定的关系，猜测可能不同的渔场有其主要的作业方式。由于刺网作业方式的限制，其主要分布在我国的东南沿海的近海区域；拖网渔船相对于刺网来说，活动范围稍广，个别会航行在远洋区域；围网渔船一般在远洋作业，需要的捕鱼周期较长。 可见经纬度的信息有用，那么对轨迹数据处理时不宜归一化，这会导致信息的丢失。 问题3：速度和转角是否代表一定的行为模式？ 对三种作业方式的速度和转角分布进行绘制（上图为转角分布，下图为速度分布），发现三种作业方式在速度和转角分布上有些许不同，猜测刺网捕鱼时船往往会静止或随着海风或海流缓慢前进，移动范围较小；拖网捕鱼时需要依靠渔船拖曳渔具进行捕鱼，大部分时间处于直行状态，转弯次数较少；围网捕鱼时捕鱼的过程中通常需要兜圈子，转弯幅度较大。 基于以上猜测，对整个轨迹过程的速度和转角做统计特征可能比较有效。 2.4 EDA 总结 轨迹数据中存在异常值：坐标序列与轨迹序列均存在异常值，需对异常值进行修复。 轨迹的当中存在重要的 POI 点：轨迹中应当存在POI点以及POI 点组成的ROI(Region of Interested)区域，需要通过特殊方法深入挖掘这类信息。 不同类别轨迹速度存在明显差异性：不同行为的轨迹，速度明显存在显著差异性，对应于拖网围网与刺网的不同运动特性，这样的数据可直接通过每条轨迹的分位数特征捕获。 不同类别的轨迹方向的分布差异性不明显：不同行为的轨迹，其方向的分布特性不明显，因此最后组织特征时，方向特征需要特殊处理。 坐标可直接作为区分不同行为轨迹的标准：不同行为的渔船有不同的活动海域，可能对应于不同的渔场，可以直接使用坐标对这样的信息进行捕获。 统计特征建模并不足够描述轨迹的特性：单纯从统计的角度，并未捕获渔船运动的时序性，需要用特殊方法对渔船的运动特性进行建模。 3 预处理&amp;特征工程 数据清洗：对异常坐标点和异常速度剔除，并进行插值。 ①坐标转换： 将轨迹经纬度坐标由WGS-84坐标转到墨卡托坐标系(EPSG: 3395)，便于距离计算。②异常坐标滤除：计算坐标差分haversine距离，并计算局部差分速度，基于速度阈值剔除异常点并进行插值。③异常速度滤除：基于预设的最大速度阈值，对超过阈值的速度进行多项式插值补全。 POI挖掘：基于聚类方法挖掘 POI 特征，为每一条样本附加 POI 特征。 ①网格投射：将墨卡托坐标系下的每条轨迹投射到700m*700m的网格上，成为网格轨迹。②筛选港口网格：筛选船只长时间停留（2h），并且频繁（120次以上）的被不同船只（5艘以上）访问的网格，做为潜在POI。③DBSCAN聚类：通过DBSCAN聚类，合并具有相似坐标的网格，滤除密度不满足条件的网格。 轨迹embedding：基于word2vec对渔船轨迹进行向量化。 ①组轨迹sentence：基于以上的网格映射，每个轨迹点所属的网格编号作为一个token，那么多个token组成一个sentence. ②训练词向量：利用CBOW方法训练词向量，embedding_size=70，前后窗口window_size=25。③轨迹向量化：对token进行embedding，并对token向量求平均得到sentence向量。 问题：这里为什么要用embedding的方法来对轨迹提取特征？因为前面的特征探索中我们知道渔船轨迹没有一个明显的轨迹模式，且其经纬度信息很重要。这会让基于统计的特征，基于图片识别算法的特征，基于RNN或基于时序卷积的特征难以捕捉其潜在的含义。而经纬度与渔场，港口等POI 挂钩，其内涵语义特征，所以可以尝试用embedding的方式来挖掘其潜在的语义特征。 速度统计特征：基于数学统计方法提取速度时序的特征。 ①速度的均值、方差、偏度、峰度等 ②速度&gt;0时的统计特征 ③速度一阶差分统计特征 转角统计特征：基于数学统计方法提取转角的统计特征。 ①方向的方差 ②方向离散化后的占比特征（可分为8个bin，计算每个bin的占比） 4 分类算法 如果特征做的充分，那么流行的梯度提升树如 LightGBM、XGboost、Catboost 足够把分类器做好。如果不考虑算力因素，还可以对多个梯度提升树做 Stacking 以提高鲁棒性。 5 TOP方案分享 https://github.com/MichaelYin1994/tianchi-trajectory-data-mining.git https://github.com/ycd2016/DCIC2020-IOC.git","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"openmp使用总结","slug":"并行计算/openmp使用总结","date":"2025-05-17T07:30:16.000Z","updated":"2025-10-12T03:32:14.476Z","comments":true,"path":"2025/05/17/并行计算/openmp使用总结/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/05/17/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/openmp%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"现代 CPU 往往具备多个核，我们除了可以在单核上使用SIMD进行计算加速，还可以利用多核并发，让一块大的数据分配到各个核上跑起来。openmp 在这个领域提供了很大方便。 1 快速使用 假设我们要对一个规模为100万的数组的元素取绝对值，最原始的做法如下： 123for(int i=0; i&lt;size; i++)&#123; a[i] = abs(a[i]);&#125; 如何加速？两个思路，现代CPU的单核一般有向量寄存器，我们可以同时将几个元素组成向量让单个核运算，即SIMD。另外我们也可以利用现代CPU的多核来进行多线程并发计算。SIMD在NEON指令篇已经介绍过，现在我们主要讨论如何利用openMP进行多线程计算加速，代码如下： 123456#include &lt;omp.h&gt;#pragma omp parallel forfor(int i=0; i&lt;size; i++)&#123; a[i] = abs(a[i]);&#125; 编译方法： 1gcc -fopenmp test.c -o test 2 fork / join 并行执行模式的概念 OpenMP 是一个编译器指令和库函数的集合，主要是为共享式存储计算机上的并行程序设计使用的。OpenMP 并行块内并行执行的程序要全部结束后才能执行后面的非并行部分的代码。这就是标准的并行模式 fork/join 式并行模式，共享存储式并行程序就是使用 fork/join 式并行的。 3 openmp 语句和用法 基本格式： 12＃pragma omp 指令 [子句[子句]…]......用户代码 3.1 openmp指令 parallel ：用在一个代码段前，创建一个线程束，表示这段代码将被这个线程束并行执行。作用域会用{}包起来。 for ：用于 for 循环前，将循环分配到 parallel 创建的线程束，必须保证每次循环无前后依赖。 parallel for ： parallel 和 for 语句的结合，也是用在一个 for 循环前，创建一个线程束并分配执行。 section ：任务分块，用于指示该代码块被一个线程执行。依赖于外部创建的线程束。 sections ：用于包住多个section块，sections 里面的一个section被一个线程执行，section之间并行。sections 间有隐式同步，是串行执行的。 parallel sections ：创建线程束，并并行执行下文创建的section任务块。注意这种方式需要保证各个 section 里的代码执行时间相差不大，否则有短板效应。 critical ：用在一段代码临界区前，只有一个线程能进入该区域。作用与互斥锁类似。 single ：只能由一个线程执行并且只会执行一次，常用于资源的初始化。 barrier ：用于并行区内代码的线程同步，所有线程执行到 barrier 时要停止，直到所有线程都执行到 barrier 时才继续往下执行。 atomic ：原子保护，相比于critical 的锁机制，在频繁操作共享资源时更高效。 master ：用于指定一段代码块由主线程执行。 ordered ： 用于指定并行区域的循环按顺序执行。可以让代码块的某一部分串行，比总体串行好一点。 threadprivate ：用于指定一个变量是线程私有的。 3.2 openmp 子句 private ：指定每个线程都有它自己的变量私有副本。 firstprivate ：指定每个线程都有它自己的变量私有副本，并且变量要继承主线程中的初值。 lastprivate ：指定将线程中的私有变量的值在并行处理结束后复制回主线程中的对应变量。 reduction ： 指定一个或多个变量是私有的，并且在并行处理结束后这些变量要执行指定的运算。 nowait ： 忽略指定中暗含的等待。 num_threads ： 指定线程的个数。 schedule ：指定如何调度 for 循环迭代。 shared ：指定一个或多个变量为多个线程间的共享变量。 copyprivate ：用于 single 指令中的指定变量为多个线程的共享变量。 copyin ：指定一个 threadprivate 的变量的值要用主线程的值进行初始化。 default ：指定并行处理区域内的变量的使用方式，缺省是 shared。 3.3 openmp 库函数 omp_get_num_procs, 返回运行本线程的多处理机的处理器个数。 omp_get_num_threads, 返回当前并行区域中的活动线程数。 omp_set_num_threads, 设置并行执行代码时的线程个数。 omp_get_thread_num, 返回线程号。 omp_init_lock, 初始化一个简单锁。 omp_destroy_lock，销毁一个锁。 omp_set_lock，上锁操作。 omp_unset_lock， 解锁操作。 4 openmp子句详解 4.1 private子句 private 子句用于将一个或多个变量声明成线程私有的变量，类似于 pthread中的ThreadLocal概念。注意该子句声明的私有变量不会继承外部变量初值，其初值未定义，并且该副本与外部变量无关。 12345678示例：int k = 100;#pragma omp parallel for private(k)for ( k=0; k &lt; 10; k++)&#123; printf(&quot;k=%d\\n&quot;, k);&#125;printf(&quot;last k=%d\\n&quot;, k); 4.2 firstprivate 子句 与private 子句功能类似，但是可以从外部变量继承初值。 12345678int k = 100;#pragma omp parallel for firstprivate(k)for (int i=0; i &lt; 4; i++)&#123; k+=i; printf(&quot;k=%d\\n&quot;,k);&#125;printf(&quot;last k=%d\\n&quot;, k); 4.3 lastprivate 子句 lastprivate 子句用于将线程私有变量赋值给外部共享变量。那么当有多个线程运行时，到底是哪个线程最终赋值给外部共享变量？openMP规定：① 如果是for循环，那么是最后一个迭代赋值。② 如果是section块，那么是代码中的最后一个section块赋值。 12345678int k = 100;#pragma omp parallel for firstprivate(k),lastprivate(k)for (int i=0; i &lt; 4; i++)&#123; k+=i; printf(&quot;k=%d\\n&quot;,k);&#125;printf(&quot;last k=%d\\n&quot;, k); 4.4 threadprivate 子句 threadprivate 子句用来指定全局的对象被各个线程各自复制了一个私有的拷贝，即各个线程具有各自私有的全局对象。注意以下几点： threadprivate 声明的变量通常是全局范围内有效的，而 private 声明的变量只在它所属的并行构造中有效。 threadprivate 只能用于 copyin，copyprivate，schedule，num_threads 和 if 子句中，不能用于其他子句中。 对于 C++的类（class）类型变量，用作 threadprivate 的参数时，必须具有明确的拷贝构造函数。 对于 windows 系统，threadprivate 不能用于动态装载的 DLL 中，可以用于静态装载的 DLL 中。 4.5 shared 子句 shared 子句用来声明一个戒多个变量是共享变量。 需要注意的是，在并行区域内使用共享变量时，如果存在写操作，必须对共享变量加以保护。 否则不要轻易使用共享变量，尽量将共享变量的访问转化为私有变量的访问。 4.6 reduction 子句 reduction 子句主要用来对一个或多个参数条目指定一个操作符，每个线程将创建参数条目的一个私有拷贝，在区域的结束处，将私有的值通过指定的运行符运算，外部的参数条目被运算结果的值更新。 1234567int i, sum = 100;#pragma omp parallel for reduction(+: sum)for ( i = 0; i &lt; 1000; i++ )&#123; sum += i;&#125;printf( &quot;sum = %d\\n&quot;, sum); 如以上代码，外部 sum 值先被拷贝为线程私有变量，线程运算结束后，所有私有sum被 reduction 接收并执行 + 操作。这样可避免并行线程对共享变量 sum 同时写入带来的竞争问题。 4.7 copyin 子句 copyin 子句用来将主线程中 threadprivate 变量的值拷贝到执行并行区域的各个线程的 threadprivate 变量中，便于线程可以访问主线程中的变量值。 注意：copyin 中的参数必须被声明成 threadprivate ，对于 class 类型的变量，必须带有明确的拷贝赋值操作符。 12345678910111213141516171819202122232425262728293031323334int counter = 1;#pragma omp threadprivate(counter)int increment_counter()&#123; counter++; return(counter);&#125;int main()&#123; #pragma omp parallel sections copyin(counter) &#123; #pragma omp section &#123; int count1; for (int iterator = 0; iterator &lt; 100; iterator++ ) &#123; count1 = increment_counter(); &#125; printf(&quot;count1 = %d\\n&quot;, count1); &#125; #pragma omp section &#123; int count2; for (int iterator = 0; iterator &lt; 200; iterator++ ) &#123; count2 = increment_counter(); &#125; printf(&quot;count2 = %d\\n&quot;, count2); &#125; &#125; printf(&quot;counter = %d\\n&quot;, counter);&#125; 4.8 copyprivate 子句 copyprivate 子句提供了一种机制用一个私有变量将一个值从一个线程广播到执行同一并行区域的其他线程。 copyprivate 子句可以关联 single 构造，在 single 构造的 barrier 到达之前就完成了广播工作。copyprivate 可以对 private 和 threadprivate 子句中的变量进行操作，但是当使用 single 构造时，copyprivate 的变量不能用于 private 和 firstprivate 子句中。 123456789101112131415161718192021int counter = 0;#pragma omp threadprivate(counter)int increment_counter()&#123; counter++; return(counter);&#125;int main()&#123; #pragma omp parallel &#123; int count; #pragma omp single copyprivate(counter) &#123; counter = 50; &#125; count = increment_counter(); printf(&quot;ThreadId: %ld, count = %ld\\n&quot;, omp_get_thread_num(), count); &#125;&#125; 5 openmp 任务调度 openMP的任务调度要考虑如何分配才能做到负载均衡，openMP的任务调度主要是通过schedule 子句来实现的。schedule 子句的使用格式如下： 1schedule(type[,size]) type 是调度类型，有 static、dynamic 、guided、runtime几个选项。runtime 实际上是根据环境变量来选择前三种中的某中类型。 size (可选) 分配给线程的循环迭代次数，每次按 size 次分配。 5.1 静态调度(static) 当 parallel for 编译指导语句没有带 schedule 子句时，大部分系统中默认采用 static 调度方式，这种调度方式非常简单。假设有 n 次循环迭代，t 个线程，那么给每个线程静态分配大约 n/t 次迭代计算。这里为什么说大约分配 n/t 次呢？因为 n/t 不一定是整数，因此实际分配的迭代次数可能存在差 1 的情况，如果指定了 size 参数的话，那么可能相差一个 size。 不使用size时，分配给每个线程的是 n/t 次连续的迭代，如： 12345#pragma omp parallel for schedule(static)for(i = 0; i &lt; 10; i++ )&#123; printf(&quot;i=%d, thread_id=%d\\n&quot;, i, omp_get_thread_num());&#125; 假设 t=2, 则1 ~ 5次迭代分配给线程 0，6 ~ 10 次迭代分配给线程 1。 使用 size 时，同样分配给每个线程的是 n/t 次连续的迭代，但是不是简单的一刀切，而是按 size 一片一片分配，如： 12345#pragma omp parallel for schedule(static, 2)for(i = 0; i &lt; 10; i++ )&#123; printf(&quot;i=%d, thread_id=%d\\n&quot;, i, omp_get_thread_num());&#125; 假设 t=2, 则分配给线程 0 的迭代是：1，2，5，6，9，10 ；分配给线程 1 的迭代是：3，4，7，8。 5.2 动态调度(dynamic) 动态调度是动态地将迭代分配到各个线程，何为动态？不预先分配，谁先做完给谁分配。这样可以解决负载不均衡的问题。 不使用 size 参数时是将迭代逐个地分配到各个线程，使用 size 参数时，每次分配给线程的迭代次数为指定的 size 次。 5.3 guided 调度(guided) guided 调度是一种采用指导性的启发式自调度方法。**开始时每个线程会分配到较大的迭代块，之后分配到的迭代块会逐渐递减。**迭代块的大小会按指数级下降到指定的 size 大小，如果没有指定 size 参数，那么迭代块大小最小会降到 1。 5.4 runtime 调度(runtime) runtime 调度是在运行时根据 环境变量 OMP_SCHEDULE 来确定调度类型，最终使用的调度类型仍然是上述三种调度方式中的一种。 例如：在 unix 系统中，可以使用 setenv 命令来设置 OMP_SCHEDULE 环境变量： setenv OMP_SCHEDULE &quot;dynamic, 2&quot; 在 windows 环境中，可以在 “系统属性|高级|环境变量” 对话框中进行设置环境变量。 6 Tips 6.1 计算合适的并行线程数 设定的 for 循环执行线程数时，不能太大，否则线程切换的开销会降低整体效率。也不能太小，否则提升不明显。我们可以根据CPU核数选择合适的并行数。一般来讲： 每个线程运行的循环次数不低于 4 次。 总的运行线程数最大不超过 2 倍 CPU 核数。 12345// 合适的并行数计算const int MIN_ITERATOR_NUM = 4;int ncore = omp_get_num_procs(); //CPU核数int max_tn = n / MIN_ITERATOR_NUM;int tn = max_tn &gt; 2*ncore ? 2*ncore : max_tn; //tn 表示要设置的线程数量 https://lemon-412.github.io/imgs/20200516OpenMP_simple_Program.pdf","categories":[{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}]},{"title":"ARMv7-A neon指令总结","slug":"并行计算/armv7-A_neon指令总结","date":"2025-05-17T03:30:16.000Z","updated":"2025-05-17T07:16:00.434Z","comments":true,"path":"2025/05/17/并行计算/armv7-A_neon指令总结/","link":"","permalink":"https://xie-peiquan.gitee.io/2025/05/17/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/armv7-A_neon%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"","text":"搞高性能计算是会上瘾的，此话果然不假，真让人难以释怀。关于HPC，推荐斯坦福入门课程 CS149，Kayvon的课程还挺通俗易懂的，看完会对整个并行计算领域有个整体的认识。这里也推荐 Toni 关于Cs149的课程笔记：https://tonixwd.github.io/categories/CS课程笔记/CS149/ ARM NEON 是 ARM CPU 架构中的 SIMD（单指令多数据）扩展指令集，主要用于加速多媒体处理、信号计算、图形渲染等需要高度并行化的任务。其核心目标是通过单条指令同时处理多个数据元素，从而显著提升计算效率。 如下图，现代 CPU 中往往有多个计算单元（ALU），取指/解码单元 可以将同一指令广播给所有的ALU，这样就可以同时运行多次运算。对于armv7-A架构，每个CPU核里面有128bit 的向量寄存器，也就是可以同时进行 4x32bit 的向量运算，或者8x16bit，或者16x8bit。其对应的运算效率也是线性的增长。 1 Intrinsics 接口格式 1.1 数据类型命名规则 基本类型 12345&lt;type&gt; x &lt;channels&gt;_t示例：int8x16_t (16通道8位有符号整数)float32x4_t (4通道单精度浮点) 数组类型 1234&lt;type&gt; x &lt;channels&gt; x &lt;array_length&gt;_t示例：uint8x16x3_t (3个16通道8位无符号整数数组) 1.2 函数命名规则 12345v &#123;&lt;mod&gt;&#125; &lt;op&gt; &#123;&lt;shape&gt;&#125; &#123;&lt;flags&gt;&#125;_&lt;type&gt; ( &#123;&#125; 表示可选的参数)示例:int8x8_t vadd_s8 (int8x8_t a, int8x8_t b) // 两个类型为int8的向量之和uint16x8_t vaddl_u8(uint8x8_t a, uint8x8_t b); // 两个类型为uint8的向量之和,输出向量为uint16 v 表示向量，固定前缀。 &lt;mod&gt; - 修饰符 q：使用饱和算术运算，结果会被限制在指定数据类型的范围内。 h：对结果进行减半操作 (通过右移1位实现，相当于截断除法)。 d：对结果进行加倍操作。 r：对结果进行舍入操作（等效于截断前加0.5）。 p: 将两向量的相邻数据进行两两和操作。 &lt;op&gt; - 操作类型 表示具体的运算（例如 add（加）、sub（减）、mul（乘））。 &lt;shape&gt; - 数据形状 l ：表示 long，输出向量的元素长度是输入长度的 2 倍。 w：表示 wide，第一个输入向量和输出向量类型一样，且是第二个输入向量元素长度的 2 倍。 n：表示 narrow，输出向量的元素长度是输入长度的 1/2 倍。 flags： q 表示 quad word，四字，指定函数对 128 位 Q 寄存器进行操作，不带 q 则对 64 位 D 寄存器进行操作。 &lt;type&gt; ：表示函数运算的参数类型。 2 汇编格式 1V &#123;&lt;mod&gt;&#125; &lt;op&gt; &#123;&lt;shape&gt;&#125; &#123;&lt;cond&gt;&#125; &#123;.&lt;dt&gt;&#125; &#123;&lt;dest&gt;&#125;, src1, src2 ( &#123;&#125; 表示可选的参数) 123示例：VADD.I16 D0, D1, D2 @ 16位加法VMLAL.S16 Q2, D8, D9 @ 有符号16位乘加 v 表示向量，固定前缀。 &lt;mod&gt; - 修饰符 Q：使用饱和算术运算，结果会被限制在指定数据类型的范围内（如 VQABS、VQSHL）。 H：对结果进行减半操作（通过右移1位实现，相当于截断除法），如 VHADD、VHSUB。 D：对结果进行加倍操作，如 VQDMULL、VQDMLAL、VQDMLSL 和 VQ&#123;R&#125;DMULH。 R：对结果进行舍入操作（等效于截断前加0.5），如 VRHADD、VRSHR。 &lt;op&gt; - 操作类型 表示具体的运算（例如 ADD（加）、SUB（减）、MUL（乘））。 &lt;shape&gt; - 数据形状 即前文定义的 ​​长型（L）​​、​​宽型（W）​​、​​窄型（N）​​。 &lt;cond&gt; - 条件码 需与 IT 指令配合使用的条件标志。 &lt;.dt&gt; - 数据类型 指定操作数的数据类型（如 s8（有符号8位整型）、u8（无符号8位整型）、f32（32位浮点型））。 &lt;dest&gt; - 目标操作数 存储运算结果的寄存器或内存地址。 &lt;src1&gt; - 源操作数1 参与运算的第一个输入操作数。 &lt;src2&gt; - 源操作数2 参与运算的第二个输入操作数。 3 神经网络加速应用 3.1 absval算子 123456for (; i + 3 &lt; size; i += 4) &#123; float32x4_t _p = vld1q_f32(ptr); //ld1 即load1,顺序加载 _p = vabsq_f32(_p); vst1q_f32(ptr, _p); //st1 即store1,顺序存储 ptr += 4;&#125; 3.2 activation算子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Reluconst float32x4_t _zero = vdupq_n_f32(0.f); //dup 即目标值赋值给向量，n表示为标量_v = vmaxq_f32(_v, _zero);// leakyReluconst float32x4_t _zero = vdupq_n_f32(0.f);const float32x4_t _slope = vdupq_n_f32(params[0]);const uint32x4_t _lemask = vcleq_f32(_v, _zero); //cle 即 Compare Less than or Equal (小于等于)float32x4_t _ps = vmulq_f32(_v, _slope);_v = vbslq_f32(_lemask, _ps, _v); //bsl 即 Bitwise Select (按位选择)// clip const float32x4_t _min = vdupq_n_f32(params[0]);const float32x4_t _max = vdupq_n_f32(params[1]);_v = vmaxq_f32(_v, _min);_v = vminq_f32(_v, _max);// sigmoidstatic inline float32x4_t exp_ps(float32x4_t x)&#123; float32x4_t tmp, fx; float32x4_t one = vdupq_n_f32(1); x = vminq_f32(x, vdupq_n_f32(c_exp_hi)); x = vmaxq_f32(x, vdupq_n_f32(c_exp_lo)); /* express exp(x) as exp(g + n*log(2)) */ fx = vmlaq_f32(vdupq_n_f32(0.5f), x, vdupq_n_f32(c_cephes_LOG2EF)); /* perform a floorf */ tmp = vcvtq_f32_s32(vcvtq_s32_f32(fx)); /* if greater, substract 1 */ uint32x4_t mask = vcgtq_f32(tmp, fx); mask = vandq_u32(mask, vreinterpretq_u32_f32(one)); fx = vsubq_f32(tmp, vreinterpretq_f32_u32(mask)); tmp = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C1)); float32x4_t z = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C2)); x = vsubq_f32(x, tmp); x = vsubq_f32(x, z); z = vmulq_f32(x, x); float32x4_t y = vdupq_n_f32(c_cephes_exp_p0); y = vmlaq_f32(vdupq_n_f32(c_cephes_exp_p1), y, x); y = vmlaq_f32(vdupq_n_f32(c_cephes_exp_p2), y, x); y = vmlaq_f32(vdupq_n_f32(c_cephes_exp_p3), y, x); y = vmlaq_f32(vdupq_n_f32(c_cephes_exp_p4), y, x); y = vmlaq_f32(vdupq_n_f32(c_cephes_exp_p5), y, x); y = vmlaq_f32(x, y, z); y = vaddq_f32(y, one); /* build 2^n */ int32x4_t mm; mm = vcvtq_s32_f32(fx); mm = vaddq_s32(mm, vdupq_n_s32(0x7f)); mm = vshlq_n_s32(mm, 23); float32x4_t pow2n = vreinterpretq_f32_s32(mm); y = vmulq_f32(y, pow2n); return y;&#125;float32x4_t _one = vdupq_n_f32(1.f);_v = vnegq_f32(_v); //neg 即对向量取负_v = exp_ps(_v); _v = vaddq_f32(_v, _one);float32x4_t _outp = vrecpeq_f32(_v); //recpe 即Reciprocal Estimate (倒数近似)_outp = vmulq_f32(vrecpsq_f32(_v, _outp), _outp); //recps 即Reciprocal Step (计算倒数步长，用于修正倒数)return vmulq_f32(vrecpsq_f32(_v, _outp), _outp); //再次修正 4 编译使用 步骤一：用到neon指令的源文件需包含头文件 #include &lt;arm_neon.h&gt; 步骤二：gcc编译时加上neon使能，如： 1gcc -mfpu=neon -mfloat-abi=hard source.c -o output","categories":[{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}]},{"title":"笔记-湖南农民运动考察报告","slug":"毛泽东选集/2-湖南农民运动考察报告","date":"2024-11-18T14:59:18.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/11/18/毛泽东选集/2-湖南农民运动考察报告/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/18/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/2-%E6%B9%96%E5%8D%97%E5%86%9C%E6%B0%91%E8%BF%90%E5%8A%A8%E8%80%83%E5%AF%9F%E6%8A%A5%E5%91%8A/","excerpt":"","text":"1 原文链接 https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-192703.htm 2 文章背景 此文是教员为了答复当时党内党外对于农民革命斗争的责难而写的。为了这个目的，教员到湖南做了三十二天的考察工作，并写了这一篇报告。当时党内以陈独秀为首的右倾机会主义者，不愿意接受毛泽东的意见，为了迁就国民党，他们宁愿抛弃农民这个最主要的同盟军，使工人阶级和共产党处于孤立无援的地位。 教员在《中国社会各阶级的分析》中，指出了农民是革命最广大和最忠实的同盟军，但是并没有指出农民应该以何种方式加入到革命中来，他们要怎么样去斗争？这一篇便是要回答这样的问题。 3 原文摘录 很短的时间内，将有几万万农民从中国中部、南部和北部各省起来，其势如暴风骤雨，迅猛异常，无论什么大的力量都将压抑不住。他们将冲决一切束缚他们的罗网，朝着解放的路上迅跑。一切帝国主义、军阀、贪官污吏、土豪劣绅，都将被他们葬入坟墓。一切革命的党派、革命的同志，都将在他们面前受他们的检验而决定弃取。 宗法封建性的土豪劣绅，不法地主阶级，是几千年专制政治的基础，帝国主义、军阀、贪官污吏的墙脚。打翻这个封建势力，乃是国民革命的真正目标。孙中山先生致力国民革命凡四十年，所要做而没有做到的事，农民在几个月内做到了。这是四十年乃至几千年未曾成就过的奇勋。 凡是反抗最力、乱子闹得最大的地方，都是土豪劣绅、不法地主为恶最甚的地方。农民的眼睛，全然没有错的。谁个劣，谁个不劣，谁个最甚，谁个稍次，谁个惩办要严，谁个处罚从轻，农民都有极明白的计算，罚不当罪的极少。 4 理解&amp;启发 关于历史观。群众创造了历史？还是英雄创造了历史？这怕是个永远争论不休的论题，但是一旦代入到某个具体的背景，就会变的清晰起来。农民运动，作为一种反封建地主剥削压迫和农民自发组织起来的运动，显然是推动了历史的进步，是这段历史的创造者。而英雄则将农民运动更好的组织管理，使得其成长和发展成为一个政权组织。 关于组织问题。文章中列出的十四件大事，是农会使得加入到农会的成员，获得非常实际利益的大事。农民们自发的组织起来，清盗匪保护耕牛，保护农具，维持生产，减租减息，所有的工作都是在维持一个更好的治安环境和生产环境，这是一种良性的可持续发展的组织活动。这也是农会为什么能够发展壮大的原因。相反如果他们打着替天行道的旗子，对着土豪劣绅打家劫舍，最后这种暴力就只会演变成恃强凌弱的暴动，且不可持续。 关于立场问题。农民运动到底是“好得很”还是“糟得很”，到底是“痞子运动”还是“革命运动”，到底是“过分了”还是就得这么干。说白了，就是立场问题。我们对矛盾的估计，他到底是对抗性的矛盾，还是非对抗性的矛盾。如果是非对抗性的矛盾，那么我们得到的解决方法自然是温和改良的，如果是对抗性的矛盾，那革命就是最合适的方法。（来源于《矛盾论》）农民运动是一个阶级推翻一个阶级的暴烈的行动，非如此决不能镇压农村反革命派的活动，决不能打倒绅权，矫枉必须过正。 映射到我们的生活，有时我们背后争论的到底是什么？争论的是方案策略问题还是立场问题。如果是前者，争论是好事，真理不辩不明。如果是后者，那么争论不会有任何结果。 关于调查。一切如果不了解实际情况，没有掌握一定的信息，得到的结论和策略往往是错误的。就像我们创业或者投资，如果没有搞清楚市场的供需情况，消费者的心理。没有站在一定的信息高地，盲目跟随，结果往往是不尽如人意。 《湖南农民运动考察报告》毛泽东选集第一卷","categories":[{"name":"社会科学","slug":"社会科学","permalink":"https://xie-peiquan.gitee.io/categories/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"毛泽东选集","slug":"毛泽东选集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/"}]},{"title":"毛泽东诗词","slug":"先贤文集/毛泽东诗词","date":"2024-11-18T13:22:57.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2024/11/18/先贤文集/毛泽东诗词/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/18/%E5%85%88%E8%B4%A4%E6%96%87%E9%9B%86/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E8%AF%97%E8%AF%8D/","excerpt":"","text":"忆秦娥 · 娄山关 毛泽东（此词写于1935年，描写了红军铁血长征中征战娄山关的紧张场景） 西风烈，长空雁叫霜晨月。 霜晨月，马蹄声碎，喇叭声咽。 雄关漫道真如铁，而今迈步从头越。 从头越，苍山如海，残阳如血。 清平乐 · 六盘山 毛泽东（此词写于1935年，为翻越六盘山到达陕北时的咏怀之作） 天高云淡，望断南飞雁。 不到长城非好汉，屈指行程二万。 六盘山上高峰，红旗漫卷西风。 今日长缨在手，何时缚住苍龙？ 沁园春 · 雪 毛泽东 （写于1936年，毛泽东率红军抗日，来到西北高原） 北国风光，千里冰封，万里雪飘。 望长城内外，惟余莽莽。大河上下，顿失滔滔。山舞银蛇，原驰蜡象，欲与天公试比高。 须晴日，看红装素裹，分外妖娆。 江山如此多娇，引无数英雄竞折腰。 惜秦皇汉武，略输文采。唐宗宋祖，稍逊风骚。一代天骄，成吉思汗，只识弯弓射大雕。 俱往矣，数风流人物，还看今朝。","categories":[{"name":"先贤文集","slug":"先贤文集","permalink":"https://xie-peiquan.gitee.io/categories/%E5%85%88%E8%B4%A4%E6%96%87%E9%9B%86/"}],"tags":[{"name":"文集","slug":"文集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%96%87%E9%9B%86/"}]},{"title":"笔记-中国社会各阶级的分析","slug":"毛泽东选集/1-中国社会各阶级的分析","date":"2024-11-17T14:59:22.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/11/17/毛泽东选集/1-中国社会各阶级的分析/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/17/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/1-%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E5%90%84%E9%98%B6%E7%BA%A7%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"","text":"1 原文链接 https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm 2 文章背景 此文是为了解决党内面对的大难题而写的，这个大难题便是找不到革命的力量。就好比我们创业/工作，大目标有了，却找不到着力点。当时党内的第一种倾向，以陈独秀为代表，只注意同国民党合作，忘记了农民，这是右倾机会主义。第二种倾向，以张国焘为代表，只注意工人运动，同样忘记了农民，这是“左”倾机会主义。这两种机会主义都感觉自己力量不足，而不知道到何处去寻找力量，到何处去取得广大的同盟军。 3 原文摘录 谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。 我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 中产阶级主要是指民族资产阶级，他们对于中国革命具有矛盾的态度：他们在受外资打击、军阀压迫感觉痛苦时，需要革命，赞成反帝国主义反军阀的革命运动；但是当着革命在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展感觉到威胁时，他们又怀疑革命。 4 理解&amp;启发 这篇文章对当时的中国各阶级做出了理论分析，指出了什么阶级是我们的敌人，什么阶级是我们的朋友，弄清楚了这一点，我们才知道上哪里去寻找我们的革命力量。教员指出中国无产阶级的最广大和最忠实的同盟军是农民。 社会上各层力量对于中国革命的态度，根本上是由其经济地位决定的。因此，**分析谁是革命的力量，其实是在分析哪些经济地位的人内生地渴望革命去改变自己的经济地位。**方法论上，对于一个问题，开始先弄清楚事物的特点性质，其办法自然而然也就有了。 我们每个人都在一定的阶级中生活，其思想无不打上这个阶级的烙印。一个阶级对于革命/政策是否赞同，归根结底都在于是否合乎他们的利益。而区别在于，落实到具体的人身上，每个人对于利益这两个字的衡量是不一样的。有的人只看重自己的私利，有的人则把大义放在前面。 5 提出问题 如果说，农民是革命最坚实可靠的力量，那么农民应该以怎么样的形式去斗争？应该如何去组织这股力量？ 《中国社会各阶级的分析》毛泽东选集第一卷","categories":[{"name":"社会科学","slug":"社会科学","permalink":"https://xie-peiquan.gitee.io/categories/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"}],"tags":[{"name":"毛泽东选集","slug":"毛泽东选集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/"}]},{"title":"3-离散傅里叶变换","slug":"数字信号处理/3-离散傅里叶变换","date":"2024-11-12T10:58:49.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/11/12/数字信号处理/3-离散傅里叶变换/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/12/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3-%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"","text":"这一章讲离散傅里叶变换，为什么我们需要离散傅里叶变换？我们先回顾上一章讲的连续函数傅里叶变换，整理如下： 对于非周期的连续函数傅里叶变换公式如下： F(w)=∫−∞+∞f(t)⋅e−jwt⋅dt,t∈(−∞,∞),w∈(−∞,∞)①\\begin{aligned} F(w) &amp; = \\int_{-\\infty }^{+\\infty } f(t)\\cdot e^{-jwt}\\cdot dt \\qquad ,t\\in (-\\infty ,\\infty ), w\\in (-\\infty ,\\infty )\\qquad ① \\end{aligned} F(w)​=∫−∞+∞​f(t)⋅e−jwt⋅dt,t∈(−∞,∞),w∈(−∞,∞)①​ 对于周期的连续函数傅里叶级数公式如下： Cn=1T∫0Tf(t)⋅e−jnw0t⋅dt,t∈[0,T],n=0,±1,±2,....±∞②\\begin{aligned} C_{n}=\\frac{1}{T} \\int_{0}^{T} f(t)\\cdot e^{-jnw_{0}t} \\cdot dt \\qquad ,t\\in [0,T], n=0,\\pm 1,\\pm 2,....\\pm \\infty \\qquad ② \\end{aligned} Cn​=T1​∫0T​f(t)⋅e−jnw0​t⋅dt,t∈[0,T],n=0,±1,±2,....±∞②​ 连续，无穷运算对于计算机来讲是噩梦，因此离散化的最终目的就是消灭连续和无穷计算这两个特点，让公式可在计算机中高效运算。工程中，相当一部分信号是采样得到的，他们是离散信号。我们对非周期的离散函数进行傅里叶变换，即①式离散化，称为DTFT； 我们对周期的离散函数进行傅里叶变换，即② 式离散化，称为DFT。 以下进行具体推导。 1 DTFT DTFT，Discrete-time Fourier Transform ，离散时间傅里叶变换。其对非周期的离散函数进行傅里叶变换，可以由①式进行离散化得到。那么首先，我们如何将一个连续函数转换为一个离散函数？假设我们有一个采样器对连续信号进行采样，其采样频率为 fsf_{s}fs​，则采样点时间间隔为 Ts=1fsT_{s}=\\frac{1}{fs}Ts​=fs1​ , 则冲击采样序列为： δs=∑n=−∞∞δ(t−nTs)\\delta _{s}=\\sum_{n=-\\infty}^{\\infty} \\delta (t-nT_{s}) δs​=n=−∞∑∞​δ(t−nTs​) 则我们的连续信号f(t)f(t)f(t)可由以下计算变为离散信号fs(t)f_{s}(t)fs​(t) : fs(t)=f(t)⋅δs=∑n=−∞∞f(t)⋅δ(t−nTs)③f_{s}(t)=f(t)\\cdot \\delta _{s} =\\sum_{n=-\\infty}^{\\infty} f(t)\\cdot \\delta (t-nT_{s}) \\quad ③ fs​(t)=f(t)⋅δs​=n=−∞∑∞​f(t)⋅δ(t−nTs​)③ 我们将fs(t)f_{s}(t)fs​(t)代入①式得： Fs(w)=∫−∞+∞[∑n=−∞∞f(t)⋅δ(t−nTs)]⋅e−jwt⋅dt=∑n=−∞∞∫−∞+∞f(t)⋅δ(t−nTs)⋅e−jwt⋅dt由δ(t)的筛选性：∫−∞+∞f(t)⋅δ(t−t0)⋅dt=f(t0) 得：Fs(w)=∑n=−∞∞f(nTs)⋅e−jwnTs=∑n=−∞∞f(n)⋅e−jwnTs,w∈(−∞,∞),n=0,±1,...±∞④\\begin{aligned} F_{s}(w) &amp; = \\int_{-\\infty }^{+\\infty } [\\sum_{n=-\\infty}^{\\infty} f(t)\\cdot \\delta (t-nT_{s})]\\cdot e^{-jwt}\\cdot dt \\\\ &amp;= \\sum_{n=-\\infty}^{\\infty} \\int_{-\\infty }^{+\\infty }f(t)\\cdot \\delta (t-nT_{s}) \\cdot e^{-jwt}\\cdot dt \\\\ 由 \\delta(t)的筛选性：\\\\ \\int_{-\\infty }^{+\\infty }f(t)\\cdot \\delta (t-t_{0}) \\cdot dt = f(t_{0}) \\ 得：\\\\ \\\\ F_{s}(w) &amp;= \\sum_{n=-\\infty}^{\\infty} f(nT_{s}) \\cdot e^{-jwnT_{s}} \\\\ &amp;= \\sum_{n=-\\infty}^{\\infty} f(n) \\cdot e^{-jwnT_{s}} \\quad ,w\\in (-\\infty ,\\infty ),n=0,\\pm 1,...\\pm \\infty \\quad ④ \\end{aligned} Fs​(w)由δ(t)的筛选性：∫−∞+∞​f(t)⋅δ(t−t0​)⋅dt=f(t0​) 得：Fs​(w)​=∫−∞+∞​[n=−∞∑∞​f(t)⋅δ(t−nTs​)]⋅e−jwt⋅dt=n=−∞∑∞​∫−∞+∞​f(t)⋅δ(t−nTs​)⋅e−jwt⋅dt=n=−∞∑∞​f(nTs​)⋅e−jwnTs​=n=−∞∑∞​f(n)⋅e−jwnTs​,w∈(−∞,∞),n=0,±1,...±∞④​ ④式便是 DTFT 的公式，跟①式极为相像。然而我们还是看到了无穷的计算。 2 DFT DFT，Discrete Fourier Transform ，离散傅里叶变换。其对周期的离散函数进行傅里叶变换，可以由②式进行离散化得到。假设我们的周期离散信号是采样时间间隔为TsT_{s}Ts​ ,周期为T的 N 个点，则离散信号可表示为如下： fs(t)=f(t)⋅δs=∑n=0N−1f(t)⋅δ(t−nTs)⑤f_{s}(t)=f(t)\\cdot \\delta _{s} =\\sum_{n=0}^{N-1} f(t)\\cdot \\delta (t-nT_{s}) \\quad ⑤ fs​(t)=f(t)⋅δs​=n=0∑N−1​f(t)⋅δ(t−nTs​)⑤ 注意：这里认为 T=NTsT=NT_{s}T=NTs​，即T个点刚好是一个周期，以下推导会用到此性质。 同样的，我们将⑤式代入②式得： Ckw0=1T∫0T[∑n=0N−1f(t)⋅δ(t−nTs)]⋅e−jkw0t⋅dt=1T∑n=0N−1f(nTs)⋅e−jkw0nTs=1T∑n=0N−1f(nTs)⋅e−jk⋅2πNTs⋅nTs=1T∑n=0N−1f(nTs)⋅e−j2πnNk=1T∑n=0N−1f(n)⋅e−j2πnNk令Ckw0⋅Ts=Ck,则两边乘以Ts得：Ck=TsT∑n=0N−1f(n)⋅e−j2πnNk=1N∑n=0N−1f(n)⋅e−j2πnNk,(n=0,1,..N−1; k=0,1,...N−1) ⑥\\begin{aligned} C_{kw_{0}} &amp;=\\frac{1}{T} \\int_{0}^{T} [\\sum_{n=0}^{N-1} f(t)\\cdot \\delta (t-nT_{s})]\\cdot e^{-jkw_{0}t} \\cdot dt \\\\ &amp;= \\frac{1}{T} \\sum_{n=0}^{N-1} f(nT_{s}) \\cdot e^{-jkw_{0}nT_{s}} \\\\ &amp;= \\frac{1}{T} \\sum_{n=0}^{N-1} f(nT_{s}) \\cdot e^{-jk \\cdot \\frac{2\\pi}{NT_{s}}\\cdot nT_{s}} \\\\ &amp;= \\frac{1}{T} \\sum_{n=0}^{N-1} f(nT_{s}) \\cdot e^{-j \\frac{2\\pi n}{N} k} \\\\ &amp;= \\frac{1}{T} \\sum_{n=0}^{N-1} f(n) \\cdot e^{-j \\frac{2\\pi n}{N} k} \\\\ 令C_{kw_{0}}\\cdot T_{s} = C_{k}, 则两边乘以T_{s}得：\\\\ \\\\ C_{k} &amp;= \\frac{T_{s}}{T} \\sum_{n=0}^{N-1} f(n) \\cdot e^{-j \\frac{2\\pi n}{N} k} \\\\ &amp;= \\frac{1}{N} \\sum_{n=0}^{N-1} f(n) \\cdot e^{-j \\frac{2\\pi n}{N} k} \\quad ,(n=0,1,..N-1;\\ k=0,1,...N-1)\\ ⑥ \\\\ \\end{aligned} Ckw0​​令Ckw0​​⋅Ts​=Ck​,则两边乘以Ts​得：Ck​​=T1​∫0T​[n=0∑N−1​f(t)⋅δ(t−nTs​)]⋅e−jkw0​t⋅dt=T1​n=0∑N−1​f(nTs​)⋅e−jkw0​nTs​=T1​n=0∑N−1​f(nTs​)⋅e−jk⋅NTs​2π​⋅nTs​=T1​n=0∑N−1​f(nTs​)⋅e−jN2πn​k=T1​n=0∑N−1​f(n)⋅e−jN2πn​k=TTs​​n=0∑N−1​f(n)⋅e−jN2πn​k=N1​n=0∑N−1​f(n)⋅e−jN2πn​k,(n=0,1,..N−1; k=0,1,...N−1) ⑥​ 以上⑥式便是DFT的公式，啊这，跟②式还是很像。注意这里的1N\\frac{1}{N}N1​ 是归一化因子，有些公式没有1N\\frac{1}{N}N1​ ，但会在IDFT里出现。有没有发现至此连续和无穷计算已经被我们消灭掉了。因此DFT也成为工程领域中有力的工具。但是，还不够！你会发现如果我们用计算机语言实现以上式子，算法的复杂度是O(n2)O(n^{2})O(n2) ，能不能进行优化呢？ 补充：这里额外插入IDFT（Inverse Discrete Fourier Transform，离散傅里叶逆变换）的公式，推导略。 f(n)=∑k=0N−1Ck⋅ej2πnNk⑦f(n)=\\sum_{k=0}^{N-1} C_{k} \\cdot e^{j \\frac{2\\pi n}{N} k} \\quad ⑦ f(n)=k=0∑N−1​Ck​⋅ejN2πn​k⑦ 3 FFT FFT，Fast Fourier Transform ，快速傅里叶变换，DFT的优化版本。推导如下，我们把DFT ⑥式写为： Ck=∑n=0N−1f(n)⋅e−j2πnNk=∑n=0N−1f(n)⋅WNkn,(Wn=e−j2πN)=∑n=0N2−1f(2n)⋅WN2nk+∑n=0N2−1f(2n+1)⋅WN(2n+1)k=∑n=0N2−1f(2n)⋅WN2nk+WNk⋅∑n=0N2−1f(2n+1)⋅WN2nk由WN2nk=e−j2πN⋅2nk=WN2nk得：Ck=∑n=0N2−1f(2n)⋅WN2nk+WNk⋅∑n=0N2−1f(2n+1)⋅WN2nk,(k=0,1,...,N−1)=C奇k+C偶k⋅WNk,(k=0,1,...,N2−1)\\begin{aligned} C_{k} &amp;= \\sum_{n=0}^{N-1} f(n) \\cdot e^{-j \\frac{2\\pi n}{N}k} \\\\ &amp;= \\sum_{n=0}^{N-1} f(n) \\cdot W^{kn}_{N} \\quad ,(Wn=e^{-j \\frac{2\\pi}{N}}) \\\\ &amp;= \\sum_{n=0}^{\\frac{N}{2}-1} f(2n) \\cdot W^{2nk}_{N} + \\sum_{n=0}^{\\frac{N}{2}-1} f(2n+1) \\cdot W^{(2n+1)k}_{N} \\\\ &amp;= \\sum_{n=0}^{\\frac{N}{2}-1} f(2n) \\cdot W^{2nk}_{N} + W^{k}_{N} \\cdot \\sum_{n=0}^{\\frac{N}{2}-1} f(2n+1) \\cdot W^{2nk}_{N} \\\\ 由W^{2nk}_{N}=e^{-j \\frac{2\\pi}{N}\\cdot 2nk}= W^{nk}_{\\frac{N}{2}}得：\\\\ \\\\ C_{k} &amp;= \\sum_{n=0}^{\\frac{N}{2}-1} f(2n) \\cdot W^{nk}_{\\frac{N}{2}} + W^{k}_{N} \\cdot \\sum_{n=0}^{\\frac{N}{2}-1} f(2n+1) \\cdot W^{nk}_{\\frac{N}{2}} \\quad ,(k=0,1,...,N-1)\\\\ &amp;= C_{奇k}+C_{偶k}\\cdot W^{k}_{N} \\quad ,(k=0,1,...,\\frac{N}{2}-1) \\end{aligned} Ck​由WN2nk​=e−jN2π​⋅2nk=W2N​nk​得：Ck​​=n=0∑N−1​f(n)⋅e−jN2πn​k=n=0∑N−1​f(n)⋅WNkn​,(Wn=e−jN2π​)=n=0∑2N​−1​f(2n)⋅WN2nk​+n=0∑2N​−1​f(2n+1)⋅WN(2n+1)k​=n=0∑2N​−1​f(2n)⋅WN2nk​+WNk​⋅n=0∑2N​−1​f(2n+1)⋅WN2nk​=n=0∑2N​−1​f(2n)⋅W2N​nk​+WNk​⋅n=0∑2N​−1​f(2n+1)⋅W2N​nk​,(k=0,1,...,N−1)=C奇k​+C偶k​⋅WNk​,(k=0,1,...,2N​−1)​ 也就是，周期的离散信号的 DFT 总是能分解为两段子信号的 DFT 的综合。那就递归拆解呗，先由上到下拆解奇序列和偶序列，再由下到上把奇序列和偶序列的 DFT 结果拼接起来。这就是基2FFT算法。 基2 FFT 算法 : 把长度N的序列一分为二，将N点DFT 表示为两个 N/2 点DFT的线性组合，然后再把 N/2 点DFT一分为二，表示为4个 N/4点的 DFT；如此重复下去，直至分解成两点 DFT 的运算，两点 DFT 实际上只是加减运算 。这样的算法复杂度就由O(n2)O(n^{2})O(n2) 变为O(nlogn)O(nlogn)O(nlogn) . 经过这么多数学推导，我们终于得到了工程中最常使用的FFT算法。不过我们发现，基2 FFT算法总是希望将序列拆分为对称的奇偶序列，也就是希望信号的长度N为2的幂次方。那如果我的信号长度不是2的幂次方怎么办？补全咯，或者信号够长的话，做截断也可以。但是 补全/截断 都会让原始信号失真，导致计算出来的结果也会失真。所以一般建议输入FFT算法的离散信号长度为2的幂次方。 终于讲完FFT，scipy中的一句话，背后居然是这么多的数学推导和对仗美丽的公式。因为不愿做调包侠，所以总想去探求API背后的东西是什么。就像侯捷先生讲的，使用一个东西，却不明白他的道理，不高明。","categories":[{"name":"信号处理算法","slug":"信号处理算法","permalink":"https://xie-peiquan.gitee.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"通俗信号处理","slug":"通俗信号处理","permalink":"https://xie-peiquan.gitee.io/tags/%E9%80%9A%E4%BF%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"2-傅里叶变换","slug":"数字信号处理/2-傅里叶变换","date":"2024-11-10T11:31:59.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/11/10/数字信号处理/2-傅里叶变换/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/10/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"","text":"果然出来混总要还的，大学没认真学的知识，到头来还得再翻一翻。好在有了一些工作经验的加持，对傅里叶变换有了新的理解。这里把傅里叶变换的理论知识给整理出来，为后续的离散傅里叶变换和快速傅里叶变换打打基础。 我们知道，平面内的任何一个点可以用两个正交基来表示，比如我们熟悉的笛卡尔坐标系，其中x轴和y轴就是两个正交的基底，其内积为零。那么傅里叶变换在寻求什么？他在寻求平面上的函数（连续的点），用若干个正交基来表示。只不过这个基底比较特殊，它是三角函数。我们先理解傅里叶级数，再逐步推导到傅里叶变换。 1 傅里叶级数 19世纪初，傅里叶在研究热传导问题的时候，发现了在有限区间内可以用三角函数来表示一般函数，即任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示： f(x)=a02+∑n=1∞(an⋅cosnw0x+bn⋅sinnw0x)f(x) = \\frac{a_{0}}{2} +\\sum_{n=1}^{\\infty } (a_{n} \\cdot cosnw_{0}x+b_{n} \\cdot sinnw_{0}x ) f(x)=2a0​​+n=1∑∞​(an​⋅cosnw0​x+bn​⋅sinnw0​x) 其中，w0=2πTw_{0}=\\frac{2\\pi}{T}w0​=T2π​ ，即函数周期所对应的角频率；简单理解以上公式，可以理解为一个函数可以用 n对 不同角频率的正余弦基来表示。当然如果函数简单，n则为有限个。所以求解傅里叶级数便是将这些正交的基函数的系数给求出来，有点像把点的坐标给求出来。 如何求解？我们以** 2π2\\pi2π为周期的函数f(x)f(x)f(x) **为例，2π2\\pi2π周期的函数，其w0=2π2π=1w_{0}=\\frac{2\\pi}{2\\pi}=1w0​=2π2π​=1 ,其傅里叶级数公式为： f(x)=a02+∑n=1∞(an⋅cosnx+bn⋅sinnx)f(x) = \\frac{a_{0}}{2} +\\sum_{n=1}^{\\infty } (a_{n} \\cdot cosnx+b_{n} \\cdot sinnx ) f(x)=2a0​​+n=1∑∞​(an​⋅cosnx+bn​⋅sinnx) 由正交基内积为0的性质，我们可以知道cosnx与非自己的正交基做内积，结果都为0，sinnx同理。所以我们可以做以下推导： 1.两边乘以cosnx：f(x)⋅cosnx=[a02+∑n=1∞(an⋅cosnx+bn⋅sinnx)]⋅consnx=a02⋅cosnx+an⋅cosnx⋅cosnx2.两边对周期求积分：∫−ππf(x)cosnx⋅dx=∫−ππancosnx⋅cosnx⋅dx=an∫−ππcosnx⋅cosnx⋅dx=an⋅π3.求系数an:an=1π∫−ππf(x)⋅cosnx⋅dx4.同理求系数bn:bn=1π∫−ππf(x)⋅sinnx⋅dx5.同理求系数a0:a0=1π∫−ππf(x)⋅dx\\begin{aligned} 1.两边乘以cosnx：\\qquad f(x)\\cdot cosnx &amp;= [\\frac{a_{0}}{2} +\\sum_{n=1}^{\\infty } (a_{n} \\cdot cosnx+b_{n} \\cdot sinnx )]\\cdot consnx \\\\ &amp; = \\frac{a_{0}}{2}\\cdot cosnx + a_{n} \\cdot cosnx\\cdot cosnx \\\\ \\\\ 2.两边对周期求积分：\\qquad \\int_{-\\pi }^{\\pi} f(x)cosnx\\cdot dx &amp;= \\int_{-\\pi }^{\\pi} a_{n}cosnx\\cdot cosnx\\cdot dx \\\\ &amp;= a_{n}\\int_{-\\pi }^{\\pi} cosnx\\cdot cosnx\\cdot dx \\\\ &amp;= a_{n}\\cdot \\pi \\\\ \\\\ 3.求系数a_{n}: \\qquad a_{n} &amp; = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x)\\cdot cosnx\\cdot dx \\\\ 4.同理求系数b_{n}: \\qquad b_{n} &amp; = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x)\\cdot sinnx\\cdot dx \\\\ 5.同理求系数a_{0}: \\qquad a_{0} &amp; = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x)\\cdot dx \\end{aligned} 1.两边乘以cosnx：f(x)⋅cosnx2.两边对周期求积分：∫−ππ​f(x)cosnx⋅dx3.求系数an​:an​4.同理求系数bn​:bn​5.同理求系数a0​:a0​​=[2a0​​+n=1∑∞​(an​⋅cosnx+bn​⋅sinnx)]⋅consnx=2a0​​⋅cosnx+an​⋅cosnx⋅cosnx=∫−ππ​an​cosnx⋅cosnx⋅dx=an​∫−ππ​cosnx⋅cosnx⋅dx=an​⋅π=π1​∫−ππ​f(x)⋅cosnx⋅dx=π1​∫−ππ​f(x)⋅sinnx⋅dx=π1​∫−ππ​f(x)⋅dx​ 2 求解傅里叶级数 根据以上2π2\\pi2π为周期函数的推导，进一步地，我们可以得到求解傅里叶级数的一般公式： 原式：f(x)=a02+∑n=1∞(an⋅cosn2πTx+bn⋅sinn2πTx)求解：an=2T∫−T2T2f(x)⋅cosn2πTx⋅dxbn=2T∫−T2T2f(x)⋅sinn2πTx⋅dxa0=2T∫−T2T2f(x)⋅dx\\begin{aligned} 原式：\\qquad f(x) &amp;= \\frac{a_{0}}{2} +\\sum_{n=1}^{\\infty } (a_{n} \\cdot cosn\\frac{2\\pi}{T} x+ b_{n} \\cdot sinn\\frac{2\\pi}{T}x ) \\\\ 求解： \\qquad a_{n} &amp; = \\frac{2}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2} } f(x)\\cdot cosn\\frac{2\\pi}{T} x\\cdot dx \\\\ b_{n} &amp; = \\frac{2}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2} } f(x)\\cdot sinn\\frac{2\\pi}{T} x\\cdot dx \\\\ a_{0} &amp; = \\frac{2}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2} } f(x)\\cdot dx \\end{aligned} 原式：f(x)求解：an​bn​a0​​=2a0​​+n=1∑∞​(an​⋅cosnT2π​x+bn​⋅sinnT2π​x)=T2​∫−2T​2T​​f(x)⋅cosnT2π​x⋅dx=T2​∫−2T​2T​​f(x)⋅sinnT2π​x⋅dx=T2​∫−2T​2T​​f(x)⋅dx​ 如何简单理解以上求解公式？原式表示任意周期函数可以若干成分的三角函数叠加去拟合，而求解公式在于如何求解这些成分的三角函数的含量。如何算出这些含量？有点像拿着某个角频率的三角函数去与原函数做周期内的积分（求相似度），值越大，越相似，含量越高。 3 狄利克雷条件 你是否也怀疑过傅里叶级数公式，如果我的函数里面含有阶跃成分，凭什么一堆光滑的函数能最终合成那个突变点？emmm，你的怀疑没有错！拉格朗日生前也否认傅里叶级数公式，因为对于有棱角的函数，傅里叶级数确实没法做到完美拟合。但是，它也可以无限逼近，做到接近完美，如下图： 但是，如果原函数存在大量的离谱变点，那么傅里叶也无力回天。所以，函数想较好展开成傅里叶级数，需要满足以下条件，也被称为狄利克雷充分非必要条件：（说白了就是有界有限） 周期内有无穷断点的情况不适用 周期内有无穷极值点的情况不适用 （无限震荡） 周期内非绝对可积的情况不适用 （上天入地） 4 傅里叶级数的复指数形式 不难发现，一般的傅里叶级数公式，sin和cos总是成对出现。我们能否站在更高的维度将公式简化？有！用上帝公式嘻嘻！ 欧拉公式（上帝公式）： ejwx=coswx+j⋅sinwxe^{jwx} = coswx+j\\cdot sinwxejwx=coswx+j⋅sinwx 则: coswx=ejwx+e−jwx2sinwx=e−jwx−ejwx2⋅j\\begin{aligned} coswx &amp; = \\frac{e^{jwx}+e^{-jwx}}{2} \\\\ sinwx &amp; = \\frac{e^{-jwx}-e^{jwx}}{2} \\cdot j \\end{aligned} coswxsinwx​=2ejwx+e−jwx​=2e−jwx−ejwx​⋅j​ 以上代入傅里叶级数公式可得傅里叶级数的复指数形式： f(x)=a02+∑n=1∞(ancosnw0x+bnsinnw0x)=a02+∑n=1∞(an−jbn2)ejnw0x+∑n=−∞−1(an−jbn2)ejnw0x=∑n=−∞∞(an−jbn2)ejnw0x=∑n=−∞∞Cnejnw0x,(Cn=an−jbn2)\\begin{aligned} f(x) &amp; = \\frac{a_{0}}{2} +\\sum_{n = 1}^{\\infty} (a_{n} cosnw_{0}x+b_{n} sinnw_{0}x) \\\\ &amp; = \\frac{a_{0}}{2} +\\sum_{n = 1}^{\\infty} (\\frac{a_{n}-jb_{n}}{2})e^{jnw_{0}x} + \\sum_{n = -\\infty}^{-1} (\\frac{a_{n}-jb_{n}}{2})e^{jnw_{0}x} \\\\ &amp; = \\sum_{n = -\\infty}^{\\infty}(\\frac{a_{n}-jb_{n}}{2})e^{jnw_{0}x} \\\\ &amp;= \\sum_{n = -\\infty}^{\\infty} C_{n}e^{jnw_{0}x} \\qquad ,(C_{n}=\\frac{a_{n}-jb_{n}}{2}) \\end{aligned} f(x)​=2a0​​+n=1∑∞​(an​cosnw0​x+bn​sinnw0​x)=2a0​​+n=1∑∞​(2an​−jbn​​)ejnw0​x+n=−∞∑−1​(2an​−jbn​​)ejnw0​x=n=−∞∑∞​(2an​−jbn​​)ejnw0​x=n=−∞∑∞​Cn​ejnw0​x,(Cn​=2an​−jbn​​)​ 其复指数形式的求解方程可由以下推导得出： 1T∫−T2T2f(x)⋅e−jnw0x⋅dx=1T∫−T2T2∑n=−∞∞Cn⋅ejnw0x⋅e−jnw0x⋅dx=1TCnT=Cn\\begin{aligned} \\frac{1}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2}} f(x)\\cdot e^{-jnw_{0}x} \\cdot dx &amp;= \\frac{1}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2}}\\sum_{n = -\\infty}^{\\infty} C_{n} \\cdot e^{jnw_{0}x} \\cdot e^{-jnw_{0}x} \\cdot dx \\\\ &amp; = \\frac{1}{T} C_{n}T \\\\ &amp; = C_{n} \\end{aligned} T1​∫−2T​2T​​f(x)⋅e−jnw0​x⋅dx​=T1​∫−2T​2T​​n=−∞∑∞​Cn​⋅ejnw0​x⋅e−jnw0​x⋅dx=T1​Cn​T=Cn​​ 其中，CnC_{n}Cn​ 的n的取值从 −∞到∞-\\infty 到\\infty−∞到∞ ，具有共轭的性质，这可以解释频谱在正半轴和负半轴的对称(共轭)现象，这种双边对称的频谱图一般会出现在实数信号的分解中，而复数信号的分解频谱不一定是双边对称的。 如何简单理解以上公式？其实跟一般公式的理解方式差不多，只不过之前的观察基是coswx和sinwx，现在站在更高的维度，观察基变成了 e−jwxe^{-jwx}e−jwx 。 5 傅里叶变换&amp;逆变换 以上方程的求解都是基于周期函数，那么，如果我的函数周期是无穷大呢（非周期函数）？由w0=2πTw_{0}=\\frac{2\\pi}{T}w0​=T2π​ 可知，当T接近于无穷，我们得到w0w_{0}w0​会趋向于无穷小，则频谱变成连续。因此对于非周期函数的表示，也从原来的傅里叶级数变成傅里叶变换公式，我们看下如何推导。 傅里叶级数公式：f(t)=∑n=−∞∞Cnejwnt①Cn=1T∫−T2T2f(t)⋅e−jwnt⋅dt②将②式代入①式得：f(t)=∑n=−∞∞[1T∫−T2T2f(t)⋅e−jwnt⋅dt]⋅ejwnt=1T∑n=−∞∞[∫−T2T2f(t)⋅e−jwnt⋅dt]⋅ejwnt③对非周期函数，T→∞,则Δwn=2πT→0,则1T=Δwn2π,则将③式非周期化可得到：f(t)=lim⁡T→∞Δwn2π∑n=−∞+∞[∫−T2T2f(t)⋅e−jwnt⋅dt]⋅ejwnt=12πlim⁡Δwn→0∑n=−∞+∞[∫−∞+∞f(t)⋅e−jwnt⋅dt]⋅ejwntΔwn=12π∫−∞+∞[∫−∞+∞f(t)⋅e−jwnt⋅dt]⋅ejwnt⋅dwn④令F(wn)=∫−∞+∞f(t)⋅e−jwnt⋅dt⑤则f(t)=12π∫−∞+∞F(wn)ejwnt⋅dwn⑥\\begin{aligned} 傅里叶级数公式：\\qquad f(t) &amp;= \\sum_{n = -\\infty}^{\\infty} C_{n}e^{jw_{n}t} \\qquad ① \\\\ C_{n} &amp; = \\frac{1}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2}} f(t)\\cdot e^{-jw_{n}t} \\cdot dt \\qquad ② \\\\ 将②式代入①式得：\\qquad f(t) &amp;= \\sum_{n = -\\infty}^{\\infty} [\\frac{1}{T} \\int_{-\\frac{T}{2} }^{\\frac{T}{2}} f(t)\\cdot e^{-jw_{n}t} \\cdot dt] \\cdot e^{jw_{n}t} \\\\ &amp;= \\frac{1}{T}\\sum_{n = -\\infty}^{\\infty} [ \\int_{-\\frac{T}{2} }^{\\frac{T}{2}} f(t)\\cdot e^{-jw_{n}t} \\cdot dt] \\cdot e^{jw_{n}t} \\qquad ③ \\\\ 对非周期函数，T\\to \\infty,则\\Delta w_{n}=\\frac{2\\pi}{T}\\to 0,\\\\则\\frac{1}{T}=\\frac{\\Delta w_{n}}{2\\pi},则将③式非周期化可得到：\\\\ f(t) &amp;= \\lim_{T \\to \\infty} \\frac{\\Delta w_{n}}{2\\pi}\\sum_{n = -\\infty}^{+\\infty} [ \\int_{-\\frac{T}{2} }^{\\frac{T}{2}} f(t)\\cdot e^{-jw_{n}t} \\cdot dt] \\cdot e^{jw_{n}t} \\\\ &amp;= \\frac{1}{2\\pi}\\lim_{\\Delta w_{n} \\to 0} \\sum_{n = -\\infty}^{+\\infty} [ \\int_{-\\infty}^{+\\infty} f(t)\\cdot e^{-jw_{n}t} \\cdot dt] \\cdot e^{jw_{n}t} \\Delta w_{n} \\\\ &amp;= \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty} [ \\int_{-\\infty}^{+\\infty} f(t)\\cdot e^{-jw_{n}t} \\cdot dt] \\cdot e^{jw_{n}t} \\cdot d w_{n} \\qquad ④\\\\ \\\\ \\\\ 令 \\qquad F(w_{n}) &amp;=\\int_{-\\infty}^{+\\infty} f(t)\\cdot e^{-jw_{n}t} \\cdot dt \\qquad ⑤\\\\ 则 \\qquad f(t)&amp;= \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty} F(w_{n}) e^{jw_{n}t} \\cdot d w_{n} \\qquad ⑥ \\end{aligned} 傅里叶级数公式：f(t)Cn​将②式代入①式得：f(t)对非周期函数，T→∞,则Δwn​=T2π​→0,则T1​=2πΔwn​​,则将③式非周期化可得到：f(t)令F(wn​)则f(t)​=n=−∞∑∞​Cn​ejwn​t①=T1​∫−2T​2T​​f(t)⋅e−jwn​t⋅dt②=n=−∞∑∞​[T1​∫−2T​2T​​f(t)⋅e−jwn​t⋅dt]⋅ejwn​t=T1​n=−∞∑∞​[∫−2T​2T​​f(t)⋅e−jwn​t⋅dt]⋅ejwn​t③=T→∞lim​2πΔwn​​n=−∞∑+∞​[∫−2T​2T​​f(t)⋅e−jwn​t⋅dt]⋅ejwn​t=2π1​Δwn​→0lim​n=−∞∑+∞​[∫−∞+∞​f(t)⋅e−jwn​t⋅dt]⋅ejwn​tΔwn​=2π1​∫−∞+∞​[∫−∞+∞​f(t)⋅e−jwn​t⋅dt]⋅ejwn​t⋅dwn​④=∫−∞+∞​f(t)⋅e−jwn​t⋅dt⑤=2π1​∫−∞+∞​F(wn​)ejwn​t⋅dwn​⑥​ 以上的⑥式和⑤式就是非周期函数的傅里叶变换和傅里叶逆变换公式，非常漂亮简洁的公式！！！重写如下： f(t)=12π∫−∞+∞F(w)ejwt⋅dwF(w)=∫−∞+∞f(t)⋅e−jwt⋅dt\\begin{aligned} f(t) &amp; = \\frac{1}{2\\pi}\\int_{-\\infty }^{+\\infty } F(w)e^{jwt}\\cdot dw \\\\ F(w) &amp; = \\int_{-\\infty }^{+\\infty } f(t)\\cdot e^{-jwt}\\cdot dt \\\\ \\end{aligned} f(t)F(w)​=2π1​∫−∞+∞​F(w)ejwt⋅dw=∫−∞+∞​f(t)⋅e−jwt⋅dt​ 6 傅里叶变换的缺点 利用傅里叶变换，我们可以将函数从时域变换到频域去观察，这在工程中有极大的应用。特别是电力信号，交流电就是发电机旋转产生的，其信号天然含有三角波成分。亦或是通信系统中，无线波信号由载波承载，其天然也含有三角波成分。但是函数一旦从时域变换到频域，原信号在时间上的变换信息也就丢失了。这被称为时频不确定性，即时域和频域的信息无法同时高分辨率获得。类似于量子中的海森堡不确定性原理。 为了克服以上缺陷，人们发明了时频谱图，即将一段长信号切片成n段短信号，再将这n段短信号的频谱拼接到一起，这样就可以在频域上观察信号在时间上的变化。但是话说回来，短信号也不能太短，否则分解出来的频谱也有问题，说白了还是时频不确定性（测不准原理）。关于时频谱图，后续会详细讲。另外针对这个问题，还有一种大名鼎鼎的函数变换——小波变换，这个也在后面讲（咕叽咕叽）。 还有一个问题，以上的变换都是针对连续信号的啊，对于现实中的信号处理系统，绝大部分是离散信号。那么我们如何将以上公式离散化计算呢？下一章，离散傅里叶变换。","categories":[{"name":"信号处理算法","slug":"信号处理算法","permalink":"https://xie-peiquan.gitee.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"通俗信号处理","slug":"通俗信号处理","permalink":"https://xie-peiquan.gitee.io/tags/%E9%80%9A%E4%BF%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"1-动态时间规整","slug":"数字信号处理/1-动态时间规整算法","date":"2024-11-08T05:36:30.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/11/08/数字信号处理/1-动态时间规整算法/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/11/08/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1-%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4%E7%AE%97%E6%B3%95/","excerpt":"","text":"1 算法背景 如何计算两个序列的相似性？这方面有很多方法，各有各的利弊，我们举最简单的方法，通过计算两个序列的欧式距离来衡量序列的相似性。如下图： 两个序列的欧式距离等于相同索引的对应点的距离之和，这种算法有明显缺陷，当存在时间轴上的伸缩或偏移时，即使两个序列在形状上很相似，计算出来的距离也会很大。这便是DTW算法要针对解决的问题，更客观地计算出形状相似的两序列距离。 2 DTW的思想 如下右图，下面序列某时刻的点可以对应上面序列非同一时刻的点，即一个点可以对应多个点，多个点也可以对应一个点，也就是说每个点尽可能找离它距离最小的点，允许时间轴上的伸缩。显而易见的，这种情况下DTW计算的距离比欧氏距离更小。因此对于时间上有拉伸或压缩的序列，使用DTW计算的序列距离更加合理，因此该算法在语音序列匹配中使用十分广泛。 3 DTW的实现 我们对以上的思想进行抽象，DTW让两个序列上的点分别找到最佳的对应位置，使得总体距离最小。好了，我们假设现在有序列 C~n~ 和 Q~m~，他们目前的DTW距离是 DTW(C~n~ , Q~m~)= d1. ① 那么如果 C~n~ 在尾巴增加一个点，这个点与 Q~m~的对应点必然是尾对尾，其DTW距离是d1加上两个尾点的距离，即 DTW(C~n+1~ , Q~m~) = d1+distance(C(n+1),Q(m))；② 同理，那么如果 Q~m~ 在尾巴增加一个点，这个点与 C~n~的对应点必然是尾对尾，其DTW距离是d1加上两个尾点的距离，即 DTW(C~n~ , Q~m+1~) = d1+distance(C(n),Q(m+1))；③ 那如果两个序列都在尾巴添加一个点，这时候的DTW距离是多少？这时候的尾点对应关系无非只有3种情况，取这3种情况的最小值即可，即 DTW(C~n+1~ , Q~m+1~) = min[ DTW(C~n~ , Q~m+1~), DTW(C~n+1~ , Q~m~), DTW(C~n~ , Q~m~))]+distance(C(n+1),Q(m+1)) . 也就是说，DTW的计算过程中，问题最优解总是可以分解为子问题的最优解，那么用动态规划求解咯。列出该问题的动态规划三要素： 状态定义： 用 dp[i][j]来表示长度为 i 的序列和长度为 j 的序列的DTW值，用 dist(i,j)来表示第i点和第j点的距离，这里简单定义为差值的一阶范数。 状态转移方程： dp[i][j]=min(dp[i−1][j],dp[i,j−1],dp[i−1,j−1])+dist(i,j) dp[i][j] = min(dp[i-1][j], dp[i,j-1], dp[i-1,j-1]) + dist(i,j) dp[i][j]=min(dp[i−1][j],dp[i,j−1],dp[i−1,j−1])+dist(i,j) 初始状态： 初始值 dp[1][1] = dist(1,1) 3.1 代码实现 12345678910111213141516171819202122232425def distance(w1, w2): # 可以是其他距离计算方法 d = abs(w2 - w1) return ddef DTW(s1, s2): m = len(s1) n = len(s2) # 构建二位dp矩阵,存储对应每个子问题的最小距离 dp = [[0]*n for _ in range(m)] # 起始条件,计算单个字符与一个序列的距离 dp[0][0] = distance(s1[0],s2[0]) for i in range(1,m): dp[i][0] = distance(s1[i-1],s2[0]) + distance(s1[i],s2[0]) for j in range(1,n): dp[0][j] = distance(s1[0],s2[j-1]) + distance(s1[0],s2[j]) # 利用递推公式,计算每个子问题的最小距离,矩阵最右下角的元素即位最终两个序列的最小值 for i in range(1,m): for j in range(1,n): dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + distance(s1[i],s2[j]) return dp[-1][-1] 4 DTW的问题 尽管DTW已经被成功应用到很多领域中，DTW依然存在缺点：有时DTW会在对齐时产生不自然的扭曲/翘曲。如下图4所示： A中实线、虚线所展示的是两条合成信号（均值、方差都相同），B中展示的是自然的“feature to feature”的对应，而C中展示的则是DTW的结果。不难发现，DTW没能自然地将图形中的波峰与波峰相对应，反而产生了一个序列中的一个点对应另外一个序列中的多个点的情况，这种情况被称为“Singularities”。出现这种情况的原因是DTW算法试图通过扭曲X轴来解释Y轴上的变化。 为了解决“Singularities”问题，过去的研究提出了很多方案，有以下方法： Windowing：归根结底，出现singularities就是因为两个时间序列上相隔很远的点仅因为值相同/相近容易被warping到一起。可以限制DTW在warping过程中的能选择的范围来解决singularities，具体可以通过设置一个warping window来实现，故称之为Windowing方法。 Slope weighting: 当传统DTW中的递归式改为下式时，即可实现slope weighting。 dp[i][j]=min(X∗dp[i−1][j],X∗dp[i,j−1],dp[i−1,j−1])+dist(i,j)dp[i][j] = min(X*dp[i-1][j], X*dp[i,j-1], dp[i-1,j-1]) + dist(i,j) dp[i][j]=min(X∗dp[i−1][j],X∗dp[i,j−1],dp[i−1,j−1])+dist(i,j) 不难发现，唯一的区别在于在min函数中的后两项前加了 X ， X 为一个正实数。当对 X 的值进行调整时，可以使得warping path的方向（slope）会有一定的调整。 X 取较大值时，warping path的选择会更多的朝向对角线方向。 5 FastDTW 不难发现DTW的时间和空间复杂度是O(n^2^)，这种优化复杂度，FastDTW出现了，其拥有O(n)的时间和空间复杂度。FastDTW使用下面三种方法进行改进： 粗化——将时间序列缩小为更小的时间序列，以更少的数据点尽可能准确地表示相同的曲线。 投影——在较低分辨率下找到最小距离扭曲路径，并将其用作更高分辨率最小距离扭曲路径的初始猜测。 细化——通过局部调整扭曲路径来优化从较低分辨率投影的扭曲路径。 FastDTW中的细化使用半径参数控制，弥补原来的Band的方法那种不灵活性，因为Band的方法需要依靠先验知识判断最优路径大概在那些位置；而半径参数只是作为分级粗化投影的一个补充。确实很巧妙！！！ 如图所示具体如下：粗化通过平均相邻的点对来减少时间序列的长度（或分辨率）。生成的时间序列比原始时间序列小两倍。粗化运行多次以产生时间序列的不同分辨率。投影采用以较低分辨率计算的扭曲路径，并以较高的分辨率确定它通过的单元格。由于分辨率增加了两倍，因此低分辨率扭曲路径中的单个点将映射到更高分辨率的至少四个点（如果 |X| = |Y |，则可能 &gt; 4）。然后在细化过程中将此投影路径用作启发式方法，以找到更高分辨率的扭曲路径。细化在投影路径的邻域中找到最佳的扭曲路径，其中邻域的大小由半径参数控制。在我们的多级方法中，成本矩阵仅填充在从先前分辨率投影的路径的附近。由于扭曲路径的长度随着时间序列的长度线性增长，我们的多级方法是 O(N) 算法。 FastDTW 算法首先使用粗化来创建将被评估的所有分辨率。图中显示了一个时间序列上的例子在运行 FastDTW 算法时创建的四个分辨率（使用多少个分辨率的粗化矩阵按照实际序列长度确定）。 在图 中，从 1/8 分辨率的扭曲路径的投影显示为 1/4 分辨率的重度阴影单元。为了细化投影路径，使用非常具体的约束运行受约束的 DTW 算法，即仅评估投影扭曲路径中的单元格。这将通过从较低分辨率投影的扭曲路径区域找到最佳扭曲路径。然而，全局最优扭曲路径可能不完全包含在投影路径中。为了增加找到全局最优解的可能性，有一个半径参数来控制投影路径每一侧上的额外单元数，这些单元格也将在优化扭曲路径时进行评估。在图 中，半径参数设置为 1。由于半径而在扭曲路径细化过程中包含的单元格被轻微着色。一旦以 1/4 分辨率细化扭曲路径，该扭曲路径将投影到 1/2 分辨率，扩大半径 1，然后再次细化。最后，将扭曲路径投影到图 中的全分辨率 (1/1) 矩阵。投影被半径扩展并最后一次细化。这个细化的扭曲路径是算法的输出。 FastDTW 在所有分辨率下评估了 4 + 16 + 44 + 100 = 164 个单元，而 DTW 评估了 256 (162) 个单元。对于这个小问题，效率的提高并不是很显着，尤其是考虑到创建所有四个分辨率的开销，在长序列有很大差距。然而，FastDTW 评估的单元数与时间序列的长度成线性关系，而经典的动态时间扭曲算法总是评估N^2^个单元（如果两个时间序列的长度均为 N）。 5.1 FastDTW使用 123456!pip3 install fastdtwfrom fastdtw import fastdtwts1 = ....ts2 = ....similarity, _ = fastdtw(ts1, ts2) https://zhuanlan.zhihu.com/p/389388258 https://blog.csdn.net/KPer_Yang/article/details/126678842","categories":[{"name":"信号处理算法","slug":"信号处理算法","permalink":"https://xie-peiquan.gitee.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"通俗信号处理","slug":"通俗信号处理","permalink":"https://xie-peiquan.gitee.io/tags/%E9%80%9A%E4%BF%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"诸葛亮集","slug":"先贤文集/诸葛亮集","date":"2024-10-14T02:40:37.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2024/10/14/先贤文集/诸葛亮集/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/14/%E5%85%88%E8%B4%A4%E6%96%87%E9%9B%86/%E8%AF%B8%E8%91%9B%E4%BA%AE%E9%9B%86/","excerpt":"","text":"富贵不可求，尽人事而听天命耳。凡举大事，非励精图治不可成。 隆中对 自董卓已来，豪杰并起，跨州连郡者不可胜数。曹操比於袁绍，则名微而众寡，然操遂能克绍，以弱为强者，非惟天命，抑亦人谋也。今操已拥百万之众，挟天子以令诸侯，此诚不可与争雄。孙权据有江东，已历三世，国险而民附，贤能为之用，此可以为援而不可图也。 荆州北据汉、沔，利尽南海，东连吴会，西通巴、蜀，此用武之国，而其主不能守，此殆天所以资将军，将军岂有意乎？益州险塞，沃野千里，天府之土，高祖因之以成帝业。刘璋闇弱，张鲁在北，民殷国富而不知存恤，智能之士思得明君。将军既帝室之胄，信义著於四海，总揽英雄，思贤如渴，若跨有荆、益，保其岩阻，西和诸戎，南抚夷越，外结好孙权，内修政理，天下有变，则命一上将将荆州之军以向宛、洛，将军身率益州之众以出秦川，百姓孰敢不箪食壶浆以迎将军者乎？诚如是，则霸业可成，汉室可兴矣。 前出师表 臣亮言：先帝创业未半而中道崩殂，今天下三分，益州疲敝，此诚危急存亡之秋也。然侍卫之臣不懈於内，忠志之士忘身於外者，盖追先帝之殊遇，欲报之於陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之治，不宜偏私，使内外异法也。侍中、侍郎敦攸之、费禕、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然後施行，必能裨补阙漏，有所广益也。将军向宠，性行淑均，晓畅军事，试用於昔日，先帝称之曰能，是以众议举宠以为督。愚以为营中之事，事无大小，悉以咨之，必能使行陈和穆，优劣得所也。亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此後汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨於桓、灵也。侍中、尚书、长史、参军，此悉贞亮死节之臣也，愿陛下亲之信之，则汉室之隆，可指日而待也。 臣本布衣，躬耕南阳，苟全性命於乱世，不求闻达於诸侯。先帝不以臣卑鄙，猥（白）〔自〕枉屈，三顾臣於草庐之中，咨臣以当世之事，由是感激，遂许先帝以驰驱。後值倾覆，受任於败军之际，奉命於危难之间，迩来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧惧，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，甲兵已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都，（北）〔此〕臣所以报先帝，而忠陛下之职分也。至於斟酌损益，进尽忠言，则攸之、禕、允之任也。愿陛下托臣以讨贼兴复之效；不效，则治臣之罪，以告先帝之灵。若无兴德之言，则戮允等，以章其慢。陛下亦宜自谋，以谘诹善道，察纳雅言。追惟先帝遗诏，臣不胜受恩感激。今当远离，临表涕泣，不知所云。○《蜀志》本传。 诫子书 夫君子之行，静以修身，俭以养德，非澹薄无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非静无以成学。**淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！**○《太平御览》卷四百五十九。 又诫子书 夫酒之设，合礼致情，适体归性，礼终而退，此和之至也。主意未殚，宾有余倦，可以至醉，无致於乱。○《太平御览》卷四百九十七。 诫外生书 夫志当存高远，慕先贤，绝情欲，弃凝滞，使庶几之志，揭然有所存，恻然有所感；忍屈伸，去细碎，广咨问，除嫌吝，虽有淹留，何损於美趣，何患於不济。若志不强毅，意不慷慨，徒碌碌滞於俗，默默束於情，永窜伏於凡庸，不免於下流矣！○《太平御览》卷四百五十 九。","categories":[{"name":"先贤文集","slug":"先贤文集","permalink":"https://xie-peiquan.gitee.io/categories/%E5%85%88%E8%B4%A4%E6%96%87%E9%9B%86/"}],"tags":[{"name":"文集","slug":"文集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%96%87%E9%9B%86/"}]},{"title":"8-STL源码笔记-零散","slug":"STL源码笔记/8-STL源码笔记-零散","date":"2024-10-10T12:45:26.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2024/10/10/STL源码笔记/8-STL源码笔记-零散/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/10/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/8-STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0-%E9%9B%B6%E6%95%A3/","excerpt":"","text":"1 万能Hash 自定义hash function的形式 123456789101112131415161718#include &lt;functional&gt;class Customer&#123; ...&#125;;//仿函数形式class CustomerHash&#123;public: std::size_t operator()(const Customer&amp; c) const &#123; return ... &#125; &#125;unordered_set&lt;Customer,CustomerHash&gt; custset;//普通函数形式size_t customer_hash_func(const Customer&amp; c)&#123; return ...&#125;unordered_set&lt;Customer,size_t(*)(const Customer&amp;)&gt; custset(20,customer_hash_func); 一般来讲，Customer 结构体由若干基本类型组成，每个基本类型都能在STL中找到对应的哈希函数。但是如何将这若干个基本类型的哈希值合理地结合起来，形成一个足够分散的哈希值，这就是万能哈希函数要做的事。 本质上，通过一个seed(初始值为0)不断与各个基本类型的哈希值做运算（seed^=std::hash&lt;T&gt;()(val)+0x9e3779b9+(seed&lt;&lt;6)+(seed&gt;&gt;2)），最终得到的seed即为综合哈希值。为什么这么运算就足够散乱？emmm，或许是经验，或许是随意（9e3779b9是黄金比例的小数点后几位）。 2 tuple 元组，元之组合，可以包含任意类型的元素。使用示例如下： 1234567tuple&lt;int,float,string&gt; t1(41,8.3,&quot;nico&quot;);auto val0 = get&lt;0&gt;(t1);auto val1 = get&lt;1&gt;(t1);auto t2 = make_tuple(22,44,&quot;stacy&quot;);get&lt;1&gt;(t1) = get&lt;1&gt;(t2);typedef tuple&lt;int,float,string&gt; TupleType;typedef tuple_element&lt;1,TupleType&gt;::type T; //T为float 利用逐部分递归继承的方法，将多个类型的元素一步一步的继承下来。 3 type_traits 利用泛化偏特化的方法获取类的若干属性，C++11调用type_traits相关方法可得到的类型属性可由以下链接查看： https://cplusplus.com/reference/type_traits/?kw=type_traits 如查看类是否是POD类型的使用示例如下： 12345678910111213141516171819// is_pod example#include &lt;iostream&gt;#include &lt;type_traits&gt;struct A &#123; int i; &#125;; // C-struct (POD)class B : public A &#123;&#125;; // still POD (no data members added)struct C : B &#123; void fn()&#123;&#125; &#125;; // still POD (member function)struct D : C &#123; D()&#123;&#125; &#125;; // no POD (custom default constructor)int main() &#123; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;is_pod:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; std::is_pod&lt;int&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;A: &quot; &lt;&lt; std::is_pod&lt;A&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;B: &quot; &lt;&lt; std::is_pod&lt;B&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;C: &quot; &lt;&lt; std::is_pod&lt;C&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;D: &quot; &lt;&lt; std::is_pod&lt;D&gt;::value &lt;&lt; std::endl; return 0;&#125; 4 moveable元素 moveable元素可实现在拷贝时，直接接管当前元素，不走构造函数。即拷贝旧对象地址，旧对象作废。其实现如下： 当使用MyString S2(std::move(S1)) 其调用的是move constructor函数，拷贝地址(浅拷贝)，旧对象作废。 当使用MyString S2 = std::move(S1) 其调用的是move assignment函数，拷贝地址(浅拷贝)，旧对象作废。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"7-仿函数&适配器","slug":"STL源码笔记/7-仿函数&适配器","date":"2024-10-09T09:12:54.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2024/10/09/STL源码笔记/7-仿函数&适配器/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/09/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/7-%E4%BB%BF%E5%87%BD%E6%95%B0&%E9%80%82%E9%85%8D%E5%99%A8/","excerpt":"","text":"1 仿函数 仿函数（functors），可认为重载了operator()的类，表现上类似函数，为算法服务。 仿函数重载了 operator()操作符，以供算法调用。 仿函数继承 unary_function 或 binary_function，以记录入参和返回值类型供算法提问。 仿函数传给算法时，应该传入一个仿函数对象，如：less&lt;int&gt;(). 2 适配器 STL中存在多种适配器，有容器适配器，有迭代器适配器，有仿函数适配器。 2.1 函数适配器 binder2nd binder2nd可以将二元函数的第二个参数写死，包装成一个一元仿函数。 bind2nd函数是binder2nd的辅助函数，也是真正提供给用户使用的函数。为什么要额外再提供一个函数呢？因为仿函数得指定模板类型，麻烦！而辅助函数可借助参数类型推倒，使用起来简单。如上：bind2nd(less&lt;int&gt;(), 40). 新型适配器 bind C++11使用了更加灵活而清晰的std::bind函数，函数签名如下： 12template &lt;class Fn, class... Args&gt; std::function bind (Fn&amp;&amp; fn, Args&amp;&amp;... args); 对于Fn，可以是普通函数、函数对象，类成员函数；对于Args，可以是固定值，也可以是占位符（_1, _2）. bind风格的函数适配器代码如下，其使得新函数的使用变得清晰。 12auto lessfn = bind(less&lt;int&gt;(), _1, 50);bool flag = lessfn(70); 2.2 迭代器适配器 inserter将iterator的赋值 (assign) 操作改变为插入 (insert) 操作，并将iterator右移一个位置。 可以看到 insert_iterator是对容器的iterator的一个包装，其重载原来iterator的operator=操作符，将其改为插入并有意的操作。 insert_iterator的类型是个output_iterator_tag，注意其适用范围。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"6-迭代器&算法","slug":"STL源码笔记/6-迭代器&算法","date":"2024-10-09T09:12:53.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2024/10/09/STL源码笔记/6-迭代器&算法/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/09/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/6-%E8%BF%AD%E4%BB%A3%E5%99%A8&%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法是STL六大部件中重要的一个，其是个function template. 算法看不见容器，对其一无所知，一切信息都需要从Iterator中取得，所以Iterator需要具备能回答算法询问的东西。 算法的典型形式如下所示： 123456789template &lt;typename Iterator&gt;Algorithm(Iterator iter1, Iterator iter2)&#123; ...&#125;template &lt;typename Iterator,typename Cmp&gt;Algorithm(Iterator iter1, Iterator iter2, Cmp comp)&#123; ...&#125; 1 迭代器分类 由于算法跟迭代器实在是密不可分，因而这里要花部分章节再讲讲迭代器。由于算法通常并非适用于所有数据结构，其有一定的适用范围。因此将迭代器进行分类，以跟算法适用范围相匹配。 迭代器有以上五大分类，各个类别存在继承关系，以实现适用范围上的包含关系。 以STL中的容器的迭代器为例，array / vector / deque 的迭代器都属于random_access_iterator；list的迭代器属于bidirectional_iterator；forward-list的迭代器属于forward_iterator；rb_tree的迭代器属于bidirectional_iterator；hashtable的迭代器属于forward_iterator / bidirectional_iterator(取决于list)。而像ostream，其迭代器则属于output_iterator. 迭代器类型对于算法的影响，具体表现在同一个算法对于不同的迭代器类型，有不同的实现（重载），如下图的distance算法： 2 算法的暗示 之前提到，每种算法都有自己的适用范围，其适用范围体现在模板参数的命名中。当入参的迭代器命名越低阶，则其适用范围越广。 3 copy算法 copy第一层，利用重载分辨出const char* 和 const wchar_t*，对其调用memmove()进行高效拷贝。 copy第二层，利用偏特化分辨出普通指针 T* 和 const T*，进一步分辨其是否是“平凡” 类型，是即调用memmove，不是则调用for(...; n&lt;last-first; ...)逐个赋值。 copy第二层，若入参是iterator类型，进一步分辨其是否是RandomAccessIterator，是即调用 for(...; n&lt;last-first; ...)，不是即调用 for(; first!=last; ...)(速度慢一点)。 4 其他算法 注意，使用binary_search的前提一定是元素有序。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"7-简单的CLI","slug":"C++那些事/7-简单的CLI","date":"2024-10-09T09:05:35.000Z","updated":"2025-05-14T02:14:15.256Z","comments":true,"path":"2024/10/09/C++那些事/7-简单的CLI/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/09/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/7-%E7%AE%80%E5%8D%95%E7%9A%84CLI/","excerpt":"","text":"最近写了一个简单又好用的 CLI 程序，在这里分享出来。所谓的 CLI ，就是让我们的C++程序拥有命令行操作界面，类似于MySQL的命令行操作数据库。当你的程序复杂到一定程度，我想你可能需要一些诊断命令来查看程序的运行状态，抑或是通过命令来临时设置一些变量（比如：动态设置日志打印等级）。或许有一些框架已经具备以上功能，但简单实现这个并不难，以下是具体的分析和实现。 1 需求分析 拥有命令行交互界面，输入超时释放连接。 能够解析输入函数名和参数，并回调对应的函数。 第一点我们通过创建一个TCP Server就可以实现，对于建立连接的TCP会话，我们可以设置接收超时时间。对于函数回调打印的一些信息，我们通过字符串的形式发给 Client 作为回显。 第二点相对麻烦，但并不复杂。如果用Python实现，也就是几句话的事。但由于C++是静态编译语言，在一些操作上比较绕。首先，我们需要将不同函数签名的函数指针/对象 存入到容器里面，以便后期回调，那么 ① 如何将不同函数签名的函数包装成统一对象？ 然后，我们 ② 如何将解析到的参数数组展开传递给函数对象？注意这里的数组长度并不确定。另外，③ 参数展开的时候 值字符串 如何转换成正确的类型？ 对于问题①，目前能想到的比较好的方法是将普通函数包装成 lambda 表达式，然后再将lambda表达式转换成一个固定形式的std::function 函数对象存于容器中。对于问题②，利用泛型编程里面的容器展开，把容器元素展开成 n 个入参传递给函数指针。对于问题③，通过指定类型隐式转换函数，将字符串转换成正确类型。 2 代码实现 2.1 cli.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#ifndef _CLI_H#define _CLI_H#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;utility&gt;#include &lt;functional&gt;#define CLI_SRV_PORT 8000struct DiagVariantType&#123; std::string rawStr; explicit DiagVariantType(std::string str)&#123; rawStr = str; &#125; operator int() const &#123; return std::stoi(rawStr); &#125; operator float() const &#123; return std::stof(rawStr); &#125; operator const char*() const &#123; return rawStr.c_str(); &#125;&#125;;template&lt;typename Func, typename T, std::size_t... I&gt;auto call_func(Func&amp;&amp; func, std::vector&lt;T&gt;&amp; vec, std::index_sequence&lt;I...&gt;) &#123; return func(vec[I]...);&#125;#define REGISTER_BEGIN \\ FUNC_MAP_TYPE XCLI::s_funcMap=&#123; #define REGISTER_END &#125;;#define REGISTER_FUNC(name,func,param_n) \\ &#123;name,([](std::vector&lt;DiagVariantType&gt; vec)-&gt;std::string&#123; \\ std::string ret; \\ if(vec.size()!=param_n)&#123; \\ return &quot;error params.\\n\\n&quot;;&#125; \\ ret += call_func(func, vec, std::make_index_sequence&lt;param_n&gt;&#123;&#125;); \\ ret += &quot;function called.\\n\\n&quot;; \\ return ret; \\ &#125;)&#125;, \\typedef std::map&lt;std::string, std::function&lt;std::string(std::vector&lt;DiagVariantType&gt;)&gt;&gt; FUNC_MAP_TYPE;class XCLI&#123;public: XCLI(); ~XCLI(); void threadFunc(); static FUNC_MAP_TYPE s_funcMap;private: int createCliServer(const char* psvr_ip, uint16_t svr_port); int parseInput(const std::string&amp; input,std::string&amp; output, std::string&amp; func_name,std::vector&lt;DiagVariantType&gt;&amp; v_params); void listenCmd(int clientfd); int sockfd_;&#125;;#endif 2.2 cli.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt; #include &lt;regex&gt; #include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;exception&gt;#include &quot;cli.h&quot;XCLI::XCLI() :sockfd_(-1)&#123;&#125;XCLI::~XCLI()&#123;&#125;int XCLI::parseInput(const std::string&amp; input,std::string&amp; output, std::string&amp; func_name,std::vector&lt;DiagVariantType&gt;&amp; v_params) &#123; std::regex funcPattern(R&quot;((\\w+)\\((\\S*)\\))&quot;); std::smatch match; // std::stringstream ss; v_params.clear(); if (std::regex_search(input, match, funcPattern)) &#123; func_name = match[1]; std::string paramsStr = match[2]; if(paramsStr.empty()) return 0; std::regex paramSplitter(&quot;,&quot;); std::sregex_token_iterator iter(paramsStr.begin(), paramsStr.end(), paramSplitter, -1); std::vector&lt;std::string&gt; params(iter, &#123;&#125;); for (const auto&amp; param : params) &#123; v_params.push_back(DiagVariantType(param)); &#125; &#125; else &#123; output += &quot;Please input as follow format: func(a,b, ...) .\\n\\n&quot;; return -1; &#125; return 0; &#125; int XCLI::createCliServer(const char* psvr_ip, uint16_t svr_port)&#123; if((sockfd_ = socket(AF_INET, SOCK_STREAM , 0)) &lt; 0) &#123; perror(&quot;create CLI server error!\\n&quot;); pthread_exit(nullptr); &#125; sockaddr_in svrAddr; memset(&amp;svrAddr, 0, sizeof(svrAddr)); svrAddr.sin_family = AF_INET; svrAddr.sin_port = htons(svr_port); svrAddr.sin_addr.s_addr = inet_addr(psvr_ip); if (bind(sockfd_, (const sockaddr *)&amp;svrAddr, sizeof(svrAddr)) &lt; 0) &#123; perror(&quot;socket server bind error!&quot;); pthread_exit(nullptr); &#125; if(listen(sockfd_, 5) &lt; 0) &#123; perror(&quot;listen socket error!&quot;); pthread_exit(nullptr); &#125; printf(&quot;create cli server success.\\n&quot;); return 0;&#125;void XCLI::listenCmd(int clientfd)&#123; char buffer[1024]; struct timeval timeout; timeout.tv_sec = 300; timeout.tv_usec = 0; if (setsockopt(clientfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout)) == -1) &#123; perror(&quot;set clientfd recv timeout error!\\n&quot;); return; &#125; while(1) &#123; memset(buffer,0,sizeof(buffer)); int recv_cnt = recv(clientfd, buffer, 1024, 0); if(recv_cnt &lt;= 0) break; buffer[recv_cnt] = &#x27;\\0&#x27;; std::string input(buffer); if(input==std::string(&quot;\\n&quot;)) continue; printf(&quot;cli input: %s&quot;,input.c_str()); if(input==std::string(&quot;exit\\n&quot;)) break; try &#123; std::string func_name; std::string output; std::vector&lt;DiagVariantType&gt; t_vector; if(0 != parseInput(input,output,func_name,t_vector))&#123; send(clientfd, output.c_str(), output.size(), 0); continue; &#125; if(s_funcMap.end() == s_funcMap.find(func_name))&#123; output += &quot;function not found.\\n\\n&quot;; send(clientfd, output.c_str(), output.size(), 0); continue; &#125; output += s_funcMap[func_name](t_vector); send(clientfd, output.c_str(), output.size(), 0); &#125; catch (const std::exception&amp; e) &#123; std::stringstream ss; ss &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; send(clientfd, ss.str().c_str(), ss.str().size(), 0); &#125; &#125; &#125;void XCLI::threadFunc() &#123; createCliServer(&quot;127.0.0.1&quot;,CLI_SRV_PORT); while(1) &#123; int clientfd = accept(sockfd_, (sockaddr *)NULL, NULL); if(clientfd &lt; 0) continue; printf(&quot;cli client %d access.\\n&quot;,clientfd); listenCmd(clientfd); printf(&quot;cli client %d close.\\n&quot;,clientfd); close(clientfd); &#125; close(sockfd_);&#125; 2.3 diagFunc.cpp 123456789101112131415161718192021222324252627282930#include &lt;string&gt;#include &lt;sstream&gt; #include &quot;cli.h&quot;std::string help() &#123; std::stringstream ss; ss &lt;&lt; &quot;----- help -----&quot; &lt;&lt; std::endl &lt;&lt; &quot;func1(int a)&quot; &lt;&lt; std::endl &lt;&lt; &quot;func2(int a, double b)&quot; &lt;&lt; std::endl; return ss.str();&#125;std::string func1(int a) &#123; std::stringstream ss; ss &lt;&lt; &quot;----------func1: &quot; &lt;&lt; a &lt;&lt; std::endl; return ss.str();&#125;std::string func2(int a, double b) &#123; std::stringstream ss; ss &lt;&lt; &quot;----------func2: &quot; &lt;&lt; a &lt;&lt; &#x27;,&#x27;&lt;&lt; b &lt;&lt; std::endl; return ss.str();&#125;REGISTER_BEGIN REGISTER_FUNC(&quot;help&quot;, help, 0) REGISTER_FUNC(&quot;func1&quot;, func1, 1) REGISTER_FUNC(&quot;func2&quot;, func2, 2)REGISTER_END 3 编译测试 3.1 test.cpp 12345678910#include &quot;Thread.h&quot;#include &quot;cli.h&quot;int main()&#123; XCLI cli; Thread cli_thread(&quot;CLI&quot;, std::bind(&amp;XCLI::threadFunc,&amp;cli)); cli_thread.start(); cli_thread.join();&#125; 3.2 编译运行 12g++ ./test.cpp ./cli.cpp ./diagFunc.cpp -o test -lpthread./test 看到 create cli server success. 打印就说明 cli 后端服务已经起来了。然后在 linux 环境下，我们可以利用命令 nc localhost 端口号 与后端服务交互。 到此简单地完成一个CLI 程序，需要说明的是，这并非是一个符合工业要求的程序，还欠缺很多安全性考虑，以上。","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"CLI程序","slug":"CLI程序","permalink":"https://xie-peiquan.gitee.io/tags/CLI%E7%A8%8B%E5%BA%8F/"}]},{"title":"5-STL源码笔记-关联式容器","slug":"STL源码笔记/5-STL源码笔记-关联式容器","date":"2024-10-08T16:08:35.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2024/10/09/STL源码笔记/5-STL源码笔记-关联式容器/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/09/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/5-STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/","excerpt":"","text":"关联式容器对数据按一定的规则进行存储，因而擅长对数据进行查找，可以认为关联式容器是一个小型的内存数据库。STL的关联式容器依赖两个重要的数据结构，一个是红黑树，一个是哈希表。 1 rb_tree 红黑树是一种平衡的二叉搜索树，红黑树提供遍历操作及iterator，按照正常规则（++iter）遍历（中序遍历），便能获得排序状态。 不应该改变红黑树节点中的 key 部分，因为红黑树依赖其进行排序。 红黑树提供两种 insert 操作：insert_unique() 和 insert_equal() .前者表示节点的 key 在整棵树中独一无二，后者表示节点的 key 可重复。 模板中，Key是键的类型，Value是(key | data)的合体类型，KeyOfValue是从Value中提取 key 的方法，Compare是比较 key 大小的方法。 KeyOfValue 和 Compare 通常要继承 unary_function 或 binary_function，其包含函数对象的入参类型和返回类型。 红黑树的实现同样也借助了dummy_node，简化代码。 2 set &amp; multiset set &amp; multiset 是以红黑树为底层结构的，因此这两个容器都是有序的。 set &amp; multiset 的 key 即是 value, value 即是 key。因此无法对其 value 进行更改。（set / multiset 的 iterator是const-iterator） set 的 key 是独一无二的，因此其插入使用 rb_tree的 insert_unique()；multiset的 key 是可以重复的，其插入使用的是 rb_tree的 insert_equal()。 技术上，set / multiset 均是rb_tree的 container_adapter。对于rb_tree的模版参数，key_type 和 value_type 均取自于外部Key，KeyOfValue方法取自于identity仿函数，Compare方法默认取自于less&lt;Key&gt;。 注意，若传入set / multiset 的key不是简单类型，需要重载 &lt; 操作符以告知容器如何比较key 大小。 3 map &amp; multimap map &amp; multimap 是以红黑树为底层结构的，因此这两个容器都是有序的。 map &amp; multimap 的节点值是(key | data)的结合体, 因此节点的 data 部分可以更改，但 key 部分不能更改。(借助 std::pair&lt;const Key, T&gt;) map 的 key 是独一无二的，因此其插入使用 rb_tree的 insert_unique()；multimap的 key 是可以重复的，其插入使用的是 rb_tree的 insert_equal()。 技术上，map / multimap 均是rb_tree的 container_adapter。对于rb_tree的模版参数，key_type 取自于外部Key，value_type取自于pair&lt;const Key,T&gt;，KeyOfValue方法取自于 select1st&lt;value_type&gt; 仿函数，Compare方法默认取自于less&lt;Key&gt;。 注意，若传入map / multimap 的key不是简单类型，需要重载 &lt; 操作符以告知容器如何比较 key 大小。 operator[] 操作符，如果key不存在，则&lt;key,default-value&gt; 会被插入到map中。 lower_bound 是二分查找的一个版本，其返回的结果指向第一个大于等于 key 的元素的迭代器（左边界）。 4 hash_table STL中的hashtable采用buckets+list的结构，当发生哈希碰撞时，相同哈希值的value挂在同一链表上。 GNU C的hashtable默认buckets数为53，buckets扩充时选用53倍数附近的质数（经验值）. 当元素个数大于buckets数时，发生rehash. 为避免rehash，在hashtable初始化时指定buckets数量大小。 模板参数中，Value是 (key | data)结合体类型，Key是键类型，HashFcn是哈希函数，ExtractKey是指明如何从Value中提取key的方法，EqualKey是判断key是否相等的方法。 hashtable 的 buckets是个vector，其元素是指向链表节点的指针，链表节点也叫hashtable_node. hashtable_iterator 包含两根指针，*cur指向当前遍历的链表节点，*ht指向当前节点所属的bucket. 5 hash-function &amp; hash-code hash function的目的，就是要对元素映射到一个足够散乱的值（hash code）. hash code越是散乱，越不容易发生哈希冲突。 得到hash code后，还需经过mod操作计算出该元素最终应该放置于哪个bucket. 6 unordered容器 使用unordered_set / unordered_multiset 时，如果key是基本类型，则模板参数只需要指定 类型 T 即可。 使用unordered_map / unordered_multimap 时，如果key是基本类型，则模板参数只需要指定 类型 Key和T 即可。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"4-迭代器&序列式容器","slug":"STL源码笔记/4-迭代器&序列式容器","date":"2024-10-07T13:04:46.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2024/10/07/STL源码笔记/4-迭代器&序列式容器/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/10/07/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/4-%E8%BF%AD%E4%BB%A3%E5%99%A8&%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/","excerpt":"","text":"1 容器的分类 STL容器从内存结构上可分为序列式容器和关联性容器，序列式容器更关注于快速存取，而关联性容器更关注于快速查找。两大类容器分支又有一些内含关系，具体如下。 2 list 先从简单的链表说起，以说明容器与迭代器的关系。每个容器都有自己的专属迭代器，正是迭代器的出现，帮助容器屏蔽了内存存储上的差异。list的结构和源码如下，由于侯捷先生的胶片展示的不能再清晰，这里不做更多解释。（懒得打字:joy:） list是个双向的环状链表，为了实现前闭后开区间，其拥有dummy_node。list初始化时begin()和end()均指向这个dummy_node. list类只有一个成员，其是指向节点（__list_node）的指针。那么，list的size函数时间复杂度是多少？答：C++98，O(n); C++11，O(1). 3 Iterator 所有的 Iterator 都要有以下的五个属性（typedef）, 以适配 algorithm 的查询。如 __list_iterator 的定义： 12345678910template&lt;class T,class Ref, class Ptr&gt;struct __list_iterator &#123;typedef bidirectional_iterator_tag \\ iterator_category;typedef T value_type;typedef Ptr pointer;typedef Ref reference;typedef ptrdiff_t difference_type;...&#125;; 那 algorithm 如何获取 Iterator 的以上属性？利用 Iterator_traits，迭代器萃取代码如下： 1typedef typename iterator_traits&lt;_Iter&gt;::value_type _ValueType; 4 Iterator_traits 为什么需要要用到 traits ? 直接获取迭代器的属性不行吗？因为裸指针也是一种特殊的迭代器啊，不能放弃它。所以traits相当于是一个中间类，把迭代器与裸指针的属性给拿出来，放到一个新的结构体中，屏蔽迭代器与裸指针的区别。 那么对于裸指针，traits如何萃取？如下，其用到了偏特化的技术，对T* 和 const T* 分别做特殊处理，构造出五个必要属性放到结构体中去。 5 vector 由于vector的空间会发生成长，新增元素时可能会发生大量的拷贝。如何避免？在vector初始化时，预留空间大小（reserve函数）。 由于vector是连续空间容器，其迭代器类型是random_access类型，可以是普通指针，iterator_tarits萃取时走的是偏特化路径。 6 array array可以认为是对C数组的包装，此容器的出现是为了让传统数组适配 STL 规则。 array的迭代器类型也是random_access类型，可以是普通指针。 7 deque deque是一个分段连续的双向队列，为了维持“连续”的假象，需要控制中心（vector）和迭代器的支撑。 BufSiz指的是每个buffer容纳的元素的的个数，当没有指定时，按 sz&lt;512 ? size_t(sz / 512) : size_t(1) 计算。 deque是如何模拟连续空间的呢？全靠迭代器的操作符重载，如下： 8 queue &amp; stack 技术上，queue 和 stack 不是真正的容器，而是一个包装了 deque 的适配器。 queue 和 stack 都不允许遍历，且都不提供迭代器。如果对遍历有要求，请转而使用deque. queue 和 stack 可以指定 list 或 deque 作为底层容器；stack可以指定vector作为底层容器，但是queue不可以。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"3-STL源码笔记-分配器","slug":"STL源码笔记/3-STL源码笔记-分配器","date":"2024-09-30T03:58:10.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2024/09/30/STL源码笔记/3-STL源码笔记-分配器/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/09/30/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/3-STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0-%E5%88%86%E9%85%8D%E5%99%A8/","excerpt":"","text":"1 内存的申请和释放 C++内存管理的都是堆（Heap）内存，C++中全局的内存申请和释放函数是 operator new和 operator delete可以被重载（但不推荐）. operator new用于申请裸空间（注意区别于new，并不调用构造函数），其最终会调用 malloc；内存释放的动作是 operator delete，最终调用 free。但是malloc在申请内存会产生额外开销(cookie)来存放这块内存信息，所以当申请小内存时，这种开销甚至比数据本身还要大。因此，SGI STL对于小内存的申请有自己的一套方法，用于减小malloc所带来的开销。 2 SGI std::alloc SGI标准的空间配置器（allocator）在频繁分配小块内存时效率不佳，因此，SGI使用的是特殊的空间配置器 std::alloc。 std::alloc利用了内存池的思想，但它并不是分散的维护一个个的小的内存池，而是维护一个内存池的链表(长度为16)，间隔8byte的维护16种不同大小的内存池。当需要一次性分配的内存超过了128byte，std::alloc()本身就不会为其服务，而会将这个需求转给其他函数去处理。 注意，新版本的STL版本已经不采用这种内存分配方式，这种分配方式被挪至 __gnu_cxx::__pool_alloc中。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"2-STL源码笔记-前置基础","slug":"STL源码笔记/2-STL源码笔记-前置基础","date":"2024-09-28T15:05:29.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2024/09/28/STL源码笔记/2-STL源码笔记-前置基础/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/09/28/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/2-STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0-%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1 操作符重载 对某个对象运行某个操作符时，希望该对象表现出对应的行为，需要重载操作符。以下是list的迭代器的操作符重载例子： 2 模板方法 2.1 泛化 对于类定义或者函数定义，不指定内含的数据类型，允许用户在使用时才指定具体的数据类型。即是对类定义和函数定义进行泛化。 一种是对类进行泛化，形成类模板。具体类型需在使用时指定，如图中的 complex c2(2,6), &lt;&gt;内的类型即为指定类型。 另一种是对函数进行泛化，形成函数模板。使用时不需要用户指定，编译器可自行进行类型推倒。 2.2 特化 如果发现泛化出来的类或函数太泛，需要对一些特殊类型进行特殊处理，则可使用特化的方法，编译器会选择最匹配的模板。 2.2.1 全特化 如对以上complex类的 int 类型进行特殊处理，则特化类定义如下。当用户指定类型为 int，编译器会去匹配这个最佳版本。由于是对所有待定类型进行了特化，template&lt;&gt; 中的&lt;&gt;为空，因此也被叫做全特化。 1234template&lt;&gt; class complex&lt;int&gt;&#123; ...... &#125;; 2.2.2 偏特化 如果泛化版本中的 template&lt;…&gt; 中有多个待定类型，而我想特化其中的某个，这叫偏特化。（待定类型数量上的减少） 1234567891011//泛化版本template &lt;class T, class Alloc=alloc&gt;class vector&#123; ...... &#125;;//偏特化template &lt;class Alloc&gt;class vector&lt;bool, Alloc&gt;&#123; ...... &#125;; 如果我对某个待定类型不是指定，而是将其适用范围缩小，也是一种偏特化。（待定类型范围上的减少） 1234567891011121314151617//泛化版本template &lt;class Iterator&gt;struct iterator_traits&#123; ... &#125;;//偏特化为普通指针template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; ... &#125;;//偏特化为常指针template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; ... &#125;; 3 GP 泛型编程 我们对OOP（面向对象编程）很熟悉，总是习惯于将具体的数据和函数都绑定到一个类中。而GP则是倾向于将数据和函数分开，将函数尽可能泛化为适用于多种数据，将不一样的细节上交给数据上的重载，如下： 12345//GP风格的min函数template &lt;class T&gt;inline const T&amp; min(const T&amp; a, const T&amp; b)&#123; return b &lt; a ? b : a;&#125; 以上函数可以适用于任意两个相同类对象的比较大小，其比较大小的方法由类重载 &lt; 操作符实现。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"1-STL源码笔记-总览","slug":"STL源码笔记/1-STL源码笔记-总览.","date":"2024-09-27T15:05:28.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2024/09/27/STL源码笔记/1-STL源码笔记-总览./","link":"","permalink":"https://xie-peiquan.gitee.io/2024/09/27/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/1-STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0-%E6%80%BB%E8%A7%88./","excerpt":"","text":"使用一个东西，却不明白他的道理，不高明！ 我喜欢侯捷先生说的这句话，作为一个C++程序员，几乎每天都要和STL打交道，如果不明白他背后的原理，不舒服。或许现在的STL足够稳定，使用指导书足够丰富，以至于使用者确实可以不用关心STL的内部实现。但是，STL作为C++的高水准程序库，是从业者提升内功的代码典范，加之有侯捷先生的书籍和授课资料。因此，这里把STL源码学习过程中的一些东西记录下来，以备以后查阅。 何为STL？ STL (Standart Template Library，标准模板库) ，是C++标准库中的一大部分，包括我们常用的数据结构和算法。关于C++标准库以及STL的API，可以在以下网站中找到参考信息和demo。 https://legacy.cplusplus.com/reference/stl/ STL六大部件 STL包含如下六大部件，其部件间关系如下图： 容器（container）：STL最主体的部分，各种用来存放数据的数据结构，分为序列式容器 和 关联式容器。（class template） 分配器（allocator）：负责数据空间配置和管理，一般用户不需关心。（class template） 算法（algorithm）：适用于各种容器的通用算法。（function template） 迭代器（iterator）：容器和算法之间的桥梁，是一种泛化的指针。容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针是一种特殊的迭代器。（class template） 仿函数（functor）：行为类似函数。是一种重载了operator()的class或class template，一般函数指针可视为狭义的仿函数。 适配器（adapter）：一种用来修饰容器、迭代器、仿函数接口的东西。 STL容器一览 STL各容器的基本数据结构如下图简单所示，左列为序列式容器，右列为关联式容器。 STL容器的内含关系如下图，其中，基于 hashtable 的容器现已被纳入标准，并在STL中被命名为unordered map/set. STL中的约定 容器均应具备begin() 和end() 两个成员函数，这两个成员函数所传回来的区间为前闭后开区间。 算法中的函数的前两个入参是迭代器，分别是指向前闭后开区间的两个迭代器。 容器的成员函数 end() 所返回的迭代器指向不明确，不能对该迭代器解引用。 《STL源码剖析》侯捷","categories":[{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"}]},{"title":"8-线程局部变量","slug":"C++那些事/8-线程局部变量","date":"2024-07-12T10:19:08.000Z","updated":"2025-05-14T02:14:15.256Z","comments":true,"path":"2024/07/12/C++那些事/8-线程局部变量/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/07/12/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/8-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/","excerpt":"","text":"今天来讨论下线程局部变量，以应对多线程开发中可能面对的需求。主要讨论以下两个问题： 对于一个全局变量，每个线程都希望拥有它的一个副本，维护专属于自己的变量值，应该如何实现？ 进一步的，如果希望一个类在每个线程中有且只有一个副本，应该如何实现？ 1 线程局部变量 1.1 POD 线程局部变量 对于问题一，其实GCC已经提供了简单的解决方案，通过 __thread 关键字就可以实现简单类型的线程局部变量。其存取效率可以和全局变量相比，__thread 变量每一个线程有一份独立实体，各个线程的值互不干扰。那么什么是简单类型？严格讲是POD（Plain Old Data）类型，即 能用 C 的 memcpy() 进行操作的数据类型就是 POD 类型，像C的基本数据类型及指针均属于POD类型。 __thread 的使用规则：①只能用于修饰POD类型，不能修饰class类型，因为无法自动调用构造和析构函数。②可用于修饰全局变量或静态变量，不可修饰局部变量或者class普通成员函数。③其修饰的变量的初始化只能用编译期常量。以下是使用例子： 1__thread int value_ = 0; 这样以后线程对 value_ 的操作都是对自己副本的操作，线程间互不影响。 1.2 class 线程局部变量 那如果我想要创建的变量是一个class类型咋整，pthread 给出了方案，不过需要我们自己包装一下。用到的核心API有两个，分别是 pthread_key_create 和 pthread_key_delete 。下面借助模板进行包装： 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef _THREADLOCAL_H#define _THREADLOCAL_H#include &lt;pthread.h&gt;template&lt;typename T&gt;class ThreadLocal&#123;public: ThreadLocal() &#123; pthread_key_create(&amp;pkey_, &amp;ThreadLocal::destructor); &#125; ~ThreadLocal() &#123; pthread_key_delete(pkey_); &#125; T&amp; value() &#123; T* perThreadValue = static_cast&lt;T*&gt;(pthread_getspecific(pkey_)); if (!perThreadValue) &#123; T* newObj = new T(); pthread_setspecific(pkey_, newObj); perThreadValue = newObj; &#125; return *perThreadValue; &#125; private: static void destructor(void *x) &#123; T* obj = static_cast&lt;T*&gt;(x); delete obj; &#125;private: pthread_key_t pkey_;&#125;;#endif 使用示例： 1234#include &quot;ThreadLocal.h&quot;ThreadLocal&lt;Test&gt; testObj1;ThreadLocal&lt;Test&gt; testObj2; 这样以后线程对 testObj1 和 testObj2 的操作都是对自己副本的操作，线程间互不影响。 2 线程局部单例对象 相信我们对进程中的单例模式不陌生，我们先来回顾下进程中的单例模式怎么写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#ifndef _SINGLETON_H#define _SINGLETON_H#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt; // atexittemplate&lt;typename T&gt;class Singleton&#123;public: Singleton() = delete; ~Singleton() = delete; static T&amp; instance() &#123; pthread_once(&amp;ponce_, &amp;Singleton::init); return *value_; &#125;private: static void init() &#123; value_ = new T(); ::atexit(destroy); &#125; static void destroy() &#123; delete value_; value_ = NULL; &#125;private: static pthread_once_t ponce_; static T* value_;&#125;;template&lt;typename T&gt;pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template&lt;typename T&gt;T* Singleton&lt;T&gt;::value_ = NULL;#endif 单例模式这样写有以下好处： 把某个具体类设置为单例模式极其简单，简单修饰 Singleton&lt;MyClass&gt;::instance() 即可获取该类的唯一实例。 相比于double-check方式，借助pthread_once_t ，可以解决生成实例的线程安全问题。 相比于static MyClass生成实例的方式，可以在进程的生命周期删除实例，释放资源。 而缺点是对于具体类的生成，无法传入构造参数。如果必须传入构造参数，那么可以参考以上方式，把这一套生成实例的方法移入到具体类即可。 那么，对于线程局部变量，且要求类型是单例是怎么实现的呢？其实简单的组合一下就可以了，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#ifndef _THREADLOCALSINGLETON_H#define _THREADLOCALSINGLETON_H#include &lt;pthread.h&gt;template&lt;typename T&gt;class ThreadLocalSingleton&#123; public: ThreadLocalSingleton() = delete; ~ThreadLocalSingleton() = delete; static T&amp; instance() &#123; if (!t_value_) &#123; t_value_ = new T(); deleter_.set(t_value_); &#125; return *t_value_; &#125; static T* pointer() &#123; return t_value_; &#125; private: static void destructor(void* obj) &#123; delete t_value_; t_value_ = 0; &#125; class Deleter &#123; public: Deleter() &#123; pthread_key_create(&amp;pkey_, &amp;ThreadLocalSingleton::destructor); &#125; ~Deleter() &#123; pthread_key_delete(pkey_); &#125; void set(T* newObj) &#123; pthread_setspecific(pkey_, newObj); &#125; pthread_key_t pkey_; &#125;; static __thread T* t_value_; static Deleter deleter_;&#125;;template&lt;typename T&gt;__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = 0;template&lt;typename T&gt;typename ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;#endif 使用时，ThreadLocalSingleton&lt;MyClass&gt;::instance() 即可获取 线程局部单例对象。 https://github.com/chenshuo/muduo","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"线程局部变量","slug":"线程局部变量","permalink":"https://xie-peiquan.gitee.io/tags/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"}]},{"title":"6-简单的Logger","slug":"C++那些事/6-简单的Logger","date":"2024-07-06T09:33:37.000Z","updated":"2025-05-14T02:14:15.252Z","comments":true,"path":"2024/07/06/C++那些事/6-简单的Logger/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/07/06/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/6-%E7%AE%80%E5%8D%95%E7%9A%84Logger/","excerpt":"","text":"当我们编译第一个C程序的时候，我们就会用到 printf 函数，它把程序里面要表达的信息呈现出来。当我们的程序变得稍微复杂一点的时候，我们可能将信息记录到日志文件里面，以供故障诊断。这个时候，你可能会偷懒地利用 linux 系统下的重定向，把程序打印重定向文件里面，如：./main | ts '[%Y-%m-%d %H:%M:%S]' &gt;&gt;./main.log 2&gt;&amp;1 。当程序变得进一步复杂的时候，你会发现无论是 printf 还是重定向，对正常执行流的性能会有一些影响。这个时候，你终于想着应该写一个Logger了，并且他应该是一个牛逼的Logger，对正常执行流几乎不影响并且对磁盘友好。 一个对正常执行流几乎不影响的Logger 应该是异步的，但这一篇先不讲异步日志记录，我们先从简单的同步日志记录讲起。本篇参考muduo库，将日志功能独立出来，以供程序移植。 1 需求分析 日志格式：包含时间戳(精确到毫秒) ，日志等级 ，代码行号，日志内容。 日志写入：按块写入，相邻日志时间间隔超过设定值时触发flush。 日志等级：程序能动态更改日志打印等级。 并发写入：满足线程安全。 2 模块划分 LogFile：日志写入管理这一块，由 LogFile 类负责文件的写入管理，保证线程安全。 LogStream：日志格式化这一块，由 LogStream 类负责字段的格式化。 Timestamp：精确时间戳的获取由Timestamp 类负责。 Logger：对以上模块的封装，同时做日志记录的上层管理。 3 LogFile类实现 3.0 Mutex.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#ifndef _MUTEX_H#define _MUTEX_H#include &lt;assert.h&gt;#include &lt;pthread.h&gt;#if defined(__clang__) &amp;&amp; (!defined(SWIG))#define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x))#else#define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op#endif#define CAPABILITY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(capability(x))#define SCOPED_CAPABILITY \\ THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable)#define GUARDED_BY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x))#define PT_GUARDED_BY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x))#define ACQUIRED_BEFORE(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__))#define ACQUIRED_AFTER(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__))#define REQUIRES(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__))#define REQUIRES_SHARED(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__))#define ACQUIRE(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(acquire_capability(__VA_ARGS__))#define ACQUIRE_SHARED(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(acquire_shared_capability(__VA_ARGS__))#define RELEASE(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(release_capability(__VA_ARGS__))#define RELEASE_SHARED(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(release_shared_capability(__VA_ARGS__))#define TRY_ACQUIRE(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_capability(__VA_ARGS__))#define TRY_ACQUIRE_SHARED(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_shared_capability(__VA_ARGS__))#define EXCLUDES(...) \\ THREAD_ANNOTATION_ATTRIBUTE__(locks_excluded(__VA_ARGS__))#define ASSERT_CAPABILITY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(assert_capability(x))#define ASSERT_SHARED_CAPABILITY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(assert_shared_capability(x))#define RETURN_CAPABILITY(x) \\ THREAD_ANNOTATION_ATTRIBUTE__(lock_returned(x))#define NO_THREAD_SAFETY_ANALYSIS \\ THREAD_ANNOTATION_ATTRIBUTE__(no_thread_safety_analysis)// End of thread safety annotations &#125;#ifdef CHECK_PTHREAD_RETURN_VALUE#ifdef NDEBUG__BEGIN_DECLSextern void __assert_perror_fail (int errnum, const char *file, unsigned int line, const char *function) noexcept __attribute__ ((__noreturn__));__END_DECLS#endif#define MCHECK(ret) (&#123; __typeof__ (ret) errnum = (ret); \\ if (__builtin_expect(errnum != 0, 0)) \\ __assert_perror_fail (errnum, __FILE__, __LINE__, __func__);&#125;)#else // CHECK_PTHREAD_RETURN_VALUE#define MCHECK(ret) (&#123; __typeof__ (ret) errnum = (ret); \\ assert(errnum == 0); (void) errnum;&#125;)#endif // CHECK_PTHREAD_RETURN_VALUEclass CAPABILITY(&quot;mutex&quot;) MutexLock&#123; public: MutexLock() &#123; MCHECK(pthread_mutex_init(&amp;mutex_, NULL)); &#125; ~MutexLock() &#123; MCHECK(pthread_mutex_destroy(&amp;mutex_)); &#125; void lock() ACQUIRE() &#123; MCHECK(pthread_mutex_lock(&amp;mutex_)); &#125; void unlock() RELEASE() &#123; MCHECK(pthread_mutex_unlock(&amp;mutex_)); &#125; pthread_mutex_t* getPthreadMutex() /* non-const */ &#123; return &amp;mutex_; &#125; private: friend class Condition; pthread_mutex_t mutex_;&#125;;// Use as a stack variable, eg.// int Foo::size() const// &#123;// MutexLockGuard lock(mutex_);// return data_.size();// &#125;class SCOPED_CAPABILITY MutexLockGuard&#123; public: explicit MutexLockGuard(MutexLock&amp; mutex) ACQUIRE(mutex) : mutex_(mutex) &#123; mutex_.lock(); &#125; ~MutexLockGuard() RELEASE() &#123; mutex_.unlock(); &#125; private: MutexLock&amp; mutex_;&#125;;#endif 3.1 fileUtil.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#ifndef _FILEUTIL_H#define _FILEUTIL_H#include &lt;sys/types.h&gt;#include &lt;string&gt;// buffer size = 64KBclass FileReader&#123;public: FileReader(std::string filename); ~FileReader(); static const int kBufferSize = 64*1024; // return errno int readToString(int maxSize, std::string* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime); // return errno int readToBuffer(int* size); const char* buffer() const &#123; return buf_; &#125;private: int fd_; int err_; char buf_[kBufferSize];&#125;;// not thread safeclass FileWriter&#123;public: explicit FileWriter(std::string filename); ~FileWriter(); void append(const char* logline, size_t len); void flush(); off_t writtenBytes() const &#123; return writtenBytes_; &#125;private: size_t write(const char* logline, size_t len); FILE* fp_; char buffer_[8*1024]; off_t writtenBytes_;&#125;;int readFileToString(std::string filename, int maxSize, std::string* content, int64_t* fileSize = NULL, int64_t* modifyTime = NULL, int64_t* createTime = NULL);#endif 3.2 fileUtil.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &quot;fileUtil.h&quot;FileReader::FileReader(std::string filename) : fd_(::open(filename.c_str(), O_RDONLY | O_CLOEXEC)), err_(0)&#123; buf_[0] = &#x27;\\0&#x27;; if (fd_ &lt; 0) &#123; err_ = errno; &#125;&#125;FileReader::~FileReader()&#123; if (fd_ &gt;= 0) &#123; ::close(fd_); &#125;&#125;int FileReader::readToString(int maxSize, std::string* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime)&#123; static_assert(sizeof(off_t) == 8, &quot;_FILE_OFFSET_BITS = 64&quot;); int err = err_; if (fd_ &gt;= 0) &#123; content-&gt;clear(); if (fileSize) &#123; struct stat statbuf; if (::fstat(fd_, &amp;statbuf) == 0) &#123; if (S_ISREG(statbuf.st_mode)) &#123; *fileSize = statbuf.st_size; content-&gt;reserve(static_cast&lt;int&gt;(std::min(static_cast&lt;int64_t&gt;(maxSize), *fileSize))); &#125; else if (S_ISDIR(statbuf.st_mode)) &#123; err = EISDIR; &#125; if (modifyTime) &#123; *modifyTime = statbuf.st_mtime; &#125; if (createTime) &#123; *createTime = statbuf.st_ctime; &#125; &#125; else &#123; err = errno; &#125; &#125; while (content-&gt;size() &lt; static_cast&lt;size_t&gt;(maxSize)) &#123; size_t toRead = std::min(static_cast&lt;size_t&gt;(maxSize) - content-&gt;size(), sizeof(buf_)); ssize_t n = ::read(fd_, buf_, toRead); if (n &gt; 0) &#123; content-&gt;append(buf_, n); &#125; else &#123; if (n &lt; 0) &#123; err = errno; &#125; break; &#125; &#125; &#125; return err;&#125;int FileReader::readToBuffer(int* size)&#123; int err = err_; if (fd_ &gt;= 0) &#123; ssize_t n = ::pread(fd_, buf_, sizeof(buf_)-1, 0); if (n &gt;= 0) &#123; if (size) &#123; *size = static_cast&lt;int&gt;(n); &#125; buf_[n] = &#x27;\\0&#x27;; &#125; else &#123; err = errno; &#125; &#125; return err;&#125;FileWriter::FileWriter(std::string filename) : fp_(::fopen(filename.c_str(), &quot;ae&quot;)), // &#x27;e&#x27; for O_CLOEXEC writtenBytes_(0)&#123; ::setbuffer(fp_, buffer_, sizeof buffer_);&#125;FileWriter::~FileWriter()&#123; ::fclose(fp_);&#125;size_t FileWriter::write(const char* logline, size_t len)&#123; // #undef fwrite_unlocked return ::fwrite_unlocked(logline, 1, len, fp_);&#125;void FileWriter::append(const char* logline, const size_t len)&#123; size_t n = write(logline, len); size_t remain = len - n; while (remain &gt; 0) &#123; size_t x = write(logline + n, remain); if (x == 0) &#123; int err = ferror(fp_); if (err) &#123; fprintf(stderr, &quot;FileWriter::append() failed.\\n&quot;); &#125; break; &#125; n += x; remain = len - n; // remain -= x &#125; writtenBytes_ += len;&#125;void FileWriter::flush()&#123; ::fflush(fp_);&#125;int readFileToString(std::string filename, int maxSize, std::string* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime)&#123; FileReader file(filename); return file.readToString(maxSize, content, fileSize, modifyTime, createTime);&#125; 3.3 logFile.h 12345678910111213141516171819202122232425262728293031#ifndef _LOGFILE_H#define _LOGFILE_H#include &lt;string&gt;#include &lt;memory&gt;#include &quot;Mutex.h&quot;#include &quot;fileUtil.h&quot;class LogFile&#123;public: LogFile(std::string filepath, int flushInterval=3); ~LogFile(); void append(const char* logline, int len); void flush();private: void append_unlocked(const char* logline, int len); std::string getLogFileName(std::string filepath); const std::string filepath_; const int flushInterval_; MutexLock mutex_; time_t lastFlush_; std::unique_ptr&lt;FileWriter&gt; file_;&#125;;#endif 3.4 logFile.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &quot;logFile.h&quot;LogFile::LogFile(std::string filepath, int flushInterval) : filepath_(filepath), flushInterval_(flushInterval), mutex_(), lastFlush_(0) &#123; std::string filename = getLogFileName(filepath); file_.reset(new FileWriter(filename));&#125;LogFile::~LogFile() = default;void LogFile::append(const char* logline, int len)&#123; MutexLockGuard lock(mutex_); append_unlocked(logline, len);&#125;void LogFile::append_unlocked(const char* logline, int len)&#123; file_-&gt;append(logline, len); time_t now = ::time(NULL); if (now - lastFlush_ &gt; flushInterval_) &#123; lastFlush_ = now; file_-&gt;flush(); &#125;&#125;void LogFile::flush()&#123; MutexLockGuard lock(mutex_); file_-&gt;flush();&#125;std::string LogFile::getLogFileName(std::string filepath)&#123; /* add more log name info */ // std::string filename; // std::string basename = ::basename(filepath.c_str()); // filename.reserve(basename.size() + 64); // filename = basename; // filename += &quot;.log&quot;; return filepath;&#125; 3.5 logFile 测试 testLogFile.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;unistd.h&gt;#include &quot;logFile.h&quot;std::string getTimeString()&#123; char timebuf[32]; struct tm tm; time_t now = time(NULL); gmtime_r(&amp;now, &amp;tm); // FIXME: localtime_r ? strftime(timebuf, sizeof timebuf, &quot;%Y%m%d-%H%M%S &quot;, &amp;tm); return std::string(timebuf);&#125;int main(int argc, char* argv[])&#123; std::string line = &quot;abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZZ \\n&quot;; LogFile g_logFile(&quot;./mylog.log&quot;, 2); std::string timeString = getTimeString(); std::string outputline = timeString+line; g_logFile.append(outputline.c_str(),outputline.size()); sleep(3); timeString = getTimeString(); outputline = timeString+line; g_logFile.append(outputline.c_str(),outputline.size()); usleep(300000); timeString = getTimeString(); outputline = timeString+line; g_logFile.append(outputline.c_str(),outputline.size()); g_logFile.flush(); timeString = getTimeString(); outputline = timeString+&quot;-------------------------\\n&quot;; g_logFile.append(outputline.c_str(),outputline.size()); for(int i=0;i&lt;500;++i) &#123; timeString = getTimeString(); outputline = timeString+&quot;test write the 8KB block.\\n&quot;; g_logFile.append(outputline.c_str(),outputline.size()); &#125; sleep(10);&#125; 编译运行： 12g++ ./testLogFile.cpp ./logFile.cpp ./fileUtil.cpp -o testLogFile./testLogFile 4 LogStream类实现 4.1 logStream.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#ifndef _LOGSTREAM_H#define _LOGSTREAM_H#include &lt;memory.h&gt; // memcpy#include &lt;string&gt;template&lt;int SIZE&gt;class FixedBuffer&#123;public: FixedBuffer() : cur_(data_) &#123; setCookie(cookieStart); &#125; ~FixedBuffer() &#123; setCookie(cookieEnd); &#125; void append(const char* buf, size_t len) &#123; // FIXME: append partially if (static_cast&lt;size_t&gt;(avail()) &gt; len) &#123; memcpy(cur_, buf, len); cur_ += len; &#125; &#125; const char* data() const &#123; return data_; &#125; int length() const &#123; return static_cast&lt;int&gt;(cur_ - data_); &#125; // write to data_ directly char* current() &#123; return cur_; &#125; int avail() const &#123; return static_cast&lt;int&gt;(end() - cur_); &#125; void add(size_t len) &#123; cur_ += len; &#125; void reset() &#123; cur_ = data_; &#125; void bzero() &#123; memset(data_, 0, sizeof data_); &#125; // for used by GDB const char* debugString(); void setCookie(void (*cookie)()) &#123; cookie_ = cookie; &#125; // for used by unit test std::string toString() const &#123; return std::string(data_, length()); &#125;private: const char* end() const &#123; return data_ + sizeof data_; &#125; // Must be outline function for cookies. static void cookieStart(); static void cookieEnd(); void (*cookie_)(); char data_[SIZE]; char* cur_;&#125;;class LogStream&#123; typedef LogStream self;public: static const int kSmallBuffer = 4000; static const int kLargeBuffer = 4000*1000; static const int kMaxNumericSize = 48; typedef FixedBuffer&lt;kSmallBuffer&gt; Buffer; self&amp; operator&lt;&lt;(bool v) &#123; buffer_.append(v ? &quot;1&quot; : &quot;0&quot;, 1); return *this; &#125; self&amp; operator&lt;&lt;(short); self&amp; operator&lt;&lt;(unsigned short); self&amp; operator&lt;&lt;(int); self&amp; operator&lt;&lt;(unsigned int); self&amp; operator&lt;&lt;(long); self&amp; operator&lt;&lt;(unsigned long); self&amp; operator&lt;&lt;(long long); self&amp; operator&lt;&lt;(unsigned long long); self&amp; operator&lt;&lt;(const void*); self&amp; operator&lt;&lt;(float v) &#123; *this &lt;&lt; static_cast&lt;double&gt;(v); return *this; &#125; self&amp; operator&lt;&lt;(double); // self&amp; operator&lt;&lt;(long double); self&amp; operator&lt;&lt;(char v) &#123; buffer_.append(&amp;v, 1); return *this; &#125; // self&amp; operator&lt;&lt;(signed char); // self&amp; operator&lt;&lt;(unsigned char); self&amp; operator&lt;&lt;(const char* str) &#123; if (str) &#123; buffer_.append(str, strlen(str)); &#125; else &#123; buffer_.append(&quot;(null)&quot;, 6); &#125; return *this; &#125; self&amp; operator&lt;&lt;(const unsigned char* str) &#123; return operator&lt;&lt;(reinterpret_cast&lt;const char*&gt;(str)); &#125; self&amp; operator&lt;&lt;(const std::string&amp; v) &#123; buffer_.append(v.c_str(), v.size()); return *this; &#125; self&amp; operator&lt;&lt;(const Buffer&amp; v) &#123; *this &lt;&lt; v.toString(); return *this; &#125; void append(const char* data, int len) &#123; buffer_.append(data, len); &#125; const Buffer&amp; buffer() const &#123; return buffer_; &#125; void resetBuffer() &#123; buffer_.reset(); &#125;private: void staticCheck(); template&lt;typename T&gt; void formatInteger(T); Buffer buffer_;&#125;;class Fmt&#123;public: template&lt;typename T&gt; Fmt(const char* fmt, T val); const char* data() const &#123; return buf_; &#125; int length() const &#123; return length_; &#125;private: char buf_[32]; int length_;&#125;;inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, const Fmt&amp; fmt)&#123; s.append(fmt.data(), fmt.length()); return s;&#125;#endif 4.2 logStream.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;type_traits&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &quot;logStream.h&quot;#pragma GCC diagnostic ignored &quot;-Wtype-limits&quot;static const char digits[] = &quot;9876543210123456789&quot;;static const char* zero = digits + 9;static_assert(sizeof(digits) == 20, &quot;wrong number of digits&quot;);static const char digitsHex[] = &quot;0123456789ABCDEF&quot;;static_assert(sizeof digitsHex == 17, &quot;wrong number of digitsHex&quot;);// Efficient Integer to String Conversions, by Matthew Wilson.template&lt;typename T&gt;size_t convert(char buf[], T value)&#123; T i = value; char* p = buf; do &#123; int lsd = static_cast&lt;int&gt;(i % 10); i /= 10; *p++ = zero[lsd]; &#125; while (i != 0); if (value &lt; 0) &#123; *p++ = &#x27;-&#x27;; &#125; *p = &#x27;\\0&#x27;; std::reverse(buf, p); return p - buf;&#125;size_t convertHex(char buf[], uintptr_t value)&#123; uintptr_t i = value; char* p = buf; do &#123; int lsd = static_cast&lt;int&gt;(i % 16); i /= 16; *p++ = digitsHex[lsd]; &#125; while (i != 0); *p = &#x27;\\0&#x27;; std::reverse(buf, p); return p - buf;&#125;template class FixedBuffer&lt;LogStream::kSmallBuffer&gt;;template class FixedBuffer&lt;LogStream::kLargeBuffer&gt;;template&lt;int SIZE&gt;const char* FixedBuffer&lt;SIZE&gt;::debugString()&#123; *cur_ = &#x27;\\0&#x27;; return data_;&#125;template&lt;int SIZE&gt;void FixedBuffer&lt;SIZE&gt;::cookieStart()&#123;&#125;template&lt;int SIZE&gt;void FixedBuffer&lt;SIZE&gt;::cookieEnd()&#123;&#125;void LogStream::staticCheck()&#123; static_assert(kMaxNumericSize - 10 &gt; std::numeric_limits&lt;double&gt;::digits10, &quot;kMaxNumericSize is large enough&quot;); static_assert(kMaxNumericSize - 10 &gt; std::numeric_limits&lt;long double&gt;::digits10, &quot;kMaxNumericSize is large enough&quot;); static_assert(kMaxNumericSize - 10 &gt; std::numeric_limits&lt;long&gt;::digits10, &quot;kMaxNumericSize is large enough&quot;); static_assert(kMaxNumericSize - 10 &gt; std::numeric_limits&lt;long long&gt;::digits10, &quot;kMaxNumericSize is large enough&quot;);&#125;template&lt;typename T&gt;void LogStream::formatInteger(T v)&#123; if (buffer_.avail() &gt;= kMaxNumericSize) &#123; size_t len = convert(buffer_.current(), v); buffer_.add(len); &#125;&#125;LogStream&amp; LogStream::operator&lt;&lt;(short v)&#123; *this &lt;&lt; static_cast&lt;int&gt;(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(unsigned short v)&#123; *this &lt;&lt; static_cast&lt;unsigned int&gt;(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(int v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(unsigned int v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(long v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(unsigned long v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(long long v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(unsigned long long v)&#123; formatInteger(v); return *this;&#125;LogStream&amp; LogStream::operator&lt;&lt;(const void* p)&#123; uintptr_t v = reinterpret_cast&lt;uintptr_t&gt;(p); if (buffer_.avail() &gt;= kMaxNumericSize) &#123; char* buf = buffer_.current(); buf[0] = &#x27;0&#x27;; buf[1] = &#x27;x&#x27;; size_t len = convertHex(buf+2, v); buffer_.add(len+2); &#125; return *this;&#125;// FIXME: replace this with Grisu3 by Florian Loitsch.LogStream&amp; LogStream::operator&lt;&lt;(double v)&#123; if (buffer_.avail() &gt;= kMaxNumericSize) &#123; int len = snprintf(buffer_.current(), kMaxNumericSize, &quot;%.12g&quot;, v); buffer_.add(len); &#125; return *this;&#125;template&lt;typename T&gt;Fmt::Fmt(const char* fmt, T val)&#123; static_assert(std::is_arithmetic&lt;T&gt;::value == true, &quot;Must be arithmetic type&quot;); length_ = snprintf(buf_, sizeof buf_, fmt, val);&#125;// Explicit instantiationstemplate Fmt::Fmt(const char* fmt, char);template Fmt::Fmt(const char* fmt, short);template Fmt::Fmt(const char* fmt, unsigned short);template Fmt::Fmt(const char* fmt, int);template Fmt::Fmt(const char* fmt, unsigned int);template Fmt::Fmt(const char* fmt, long);template Fmt::Fmt(const char* fmt, unsigned long);template Fmt::Fmt(const char* fmt, long long);template Fmt::Fmt(const char* fmt, unsigned long long);template Fmt::Fmt(const char* fmt, float);template Fmt::Fmt(const char* fmt, double); 4.3 logStream 测试 testLogStream.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;limits&gt;#include &lt;stdint.h&gt;#include &lt;string&gt;#define BOOST_TEST_MAIN#define BOOST_TEST_DYN_LINK#include &lt;boost/test/unit_test.hpp&gt;// g++ ./testLogStream.cpp ./logStream.cpp -o test -lboost_unit_test_framework -lboost_test_exec_monitor#include &quot;LogStream.h&quot;using namespace std;BOOST_AUTO_TEST_CASE(testLogStreamBooleans)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;)); os &lt;&lt; true; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;)); os &lt;&lt; &#x27;\\n&#x27;; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\\n&quot;)); os &lt;&lt; false; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\\n0&quot;));&#125;BOOST_AUTO_TEST_CASE(testLogStreamIntegers)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;)); os &lt;&lt; 1; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;)); os &lt;&lt; 0; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10&quot;)); os &lt;&lt; -1; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10-1&quot;)); os.resetBuffer(); os &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 123 &lt;&lt; &#x27;x&#x27; &lt;&lt; 0x64; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0 123x100&quot;));&#125;BOOST_AUTO_TEST_CASE(testLogStreamIntegerLimits)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); os &lt;&lt; -2147483647; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647&quot;)); os &lt;&lt; static_cast&lt;int&gt;(-2147483647 - 1); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648&quot;)); os &lt;&lt; &#x27; &#x27;; os &lt;&lt; 2147483647; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648 2147483647&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-32768&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;32767&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;65535&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483648&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;2147483647&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;4294967295&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-9223372036854775808&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;9223372036854775807&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::min(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;)); os.resetBuffer(); os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::max(); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;18446744073709551615&quot;)); os.resetBuffer(); int16_t a = 0; int32_t b = 0; int64_t c = 0; os &lt;&lt; a; os &lt;&lt; b; os &lt;&lt; c; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;000&quot;));&#125;BOOST_AUTO_TEST_CASE(testLogStreamFloats)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); os &lt;&lt; 0.0; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;)); os.resetBuffer(); os &lt;&lt; 1.0; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;)); os.resetBuffer(); os &lt;&lt; 0.1; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;)); os.resetBuffer(); os &lt;&lt; 0.05; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;)); os.resetBuffer(); os &lt;&lt; 0.15; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;)); os.resetBuffer(); double a = 0.1; os &lt;&lt; a; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;)); os.resetBuffer(); double b = 0.05; os &lt;&lt; b; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;)); os.resetBuffer(); double c = 0.15; os &lt;&lt; c; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;)); os.resetBuffer(); os &lt;&lt; a+b; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;)); os.resetBuffer(); BOOST_CHECK(a+b != c); os &lt;&lt; 1.23456789; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.23456789&quot;)); os.resetBuffer(); os &lt;&lt; 1.234567; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.234567&quot;)); os.resetBuffer(); os &lt;&lt; -123.456; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-123.456&quot;)); os.resetBuffer();&#125;BOOST_AUTO_TEST_CASE(testLogStreamVoid)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); os &lt;&lt; static_cast&lt;void*&gt;(0); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x0&quot;)); os.resetBuffer(); os &lt;&lt; reinterpret_cast&lt;void*&gt;(8888); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x22B8&quot;)); os.resetBuffer();&#125;BOOST_AUTO_TEST_CASE(testLogStreamStrings)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); os &lt;&lt; &quot;Hello &quot;; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello &quot;)); string chenshuo = &quot;Shuo Chen&quot;; os &lt;&lt; chenshuo; BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello Shuo Chen&quot;));&#125;BOOST_AUTO_TEST_CASE(testLogStreamFmts)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); os &lt;&lt; Fmt(&quot;%4d&quot;, 1); BOOST_CHECK_EQUAL(buf.toString(), string(&quot; 1&quot;)); os.resetBuffer(); os &lt;&lt; Fmt(&quot;%4.2f&quot;, 1.2); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20&quot;)); os.resetBuffer(); os &lt;&lt; Fmt(&quot;%4.2f&quot;, 1.2) &lt;&lt; Fmt(&quot;%4d&quot;, 43); BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20 43&quot;)); os.resetBuffer();&#125;BOOST_AUTO_TEST_CASE(testLogStreamLong)&#123; LogStream os; const LogStream::Buffer&amp; buf = os.buffer(); for (int i = 0; i &lt; 399; ++i) &#123; os &lt;&lt; &quot;123456789 &quot;; BOOST_CHECK_EQUAL(buf.length(), 10*(i+1)); BOOST_CHECK_EQUAL(buf.avail(), 4000 - 10*(i+1)); &#125; os &lt;&lt; &quot;abcdefghi &quot;; BOOST_CHECK_EQUAL(buf.length(), 3990); BOOST_CHECK_EQUAL(buf.avail(), 10); os &lt;&lt; &quot;abcdefghi&quot;; BOOST_CHECK_EQUAL(buf.length(), 3999); BOOST_CHECK_EQUAL(buf.avail(), 1);&#125; 编译运行： 12g++ ./testLogStream.cpp ./logStream.cpp -o test -lboost_unit_test_framework -lboost_test_exec_monitor./test 5 Timestamp 类实现 5.1 Timestamp.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#ifndef _TIMESTAMP_H#define _TIMESTAMP_H#include &lt;sys/types.h&gt;#include &lt;string&gt;class Timestamp&#123;public: Timestamp() : microSecondsSinceEpoch_(0) &#123; &#125; explicit Timestamp(int64_t microSecondsSinceEpochArg) : microSecondsSinceEpoch_(microSecondsSinceEpochArg) &#123; &#125; void swap(Timestamp&amp; that) &#123; std::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_); &#125; std::string toString() const; std::string toFormattedString(bool showMicroseconds = true) const; bool valid() const &#123; return microSecondsSinceEpoch_ &gt; 0; &#125; int64_t microSecondsSinceEpoch() const &#123; return microSecondsSinceEpoch_; &#125; time_t secondsSinceEpoch() const &#123; return static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125; static Timestamp now(); static Timestamp invalid() &#123; return Timestamp(); &#125; static Timestamp fromUnixTime(time_t t) &#123; return fromUnixTime(t, 0); &#125; static Timestamp fromUnixTime(time_t t, int microseconds) &#123; return Timestamp(static_cast&lt;int64_t&gt;(t) * kMicroSecondsPerSecond + microseconds); &#125; static const int kMicroSecondsPerSecond = 1000 * 1000;private: int64_t microSecondsSinceEpoch_;&#125;;inline bool operator&lt;(Timestamp lhs, Timestamp rhs)&#123; return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();&#125;inline bool operator==(Timestamp lhs, Timestamp rhs)&#123; return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();&#125;////// Gets time difference of two timestamps, result in seconds.////// @param high, low/// @return (high-low) in seconds/// @c double has 52-bit precision, enough for one-microsecond/// resolution for next 100 years.inline double timeDifference(Timestamp high, Timestamp low)&#123; int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch(); return static_cast&lt;double&gt;(diff) / Timestamp::kMicroSecondsPerSecond;&#125;////// Add @c seconds to given timestamp.////// @return timestamp+seconds as Timestamp///inline Timestamp addTime(Timestamp timestamp, double seconds)&#123; int64_t delta = static_cast&lt;int64_t&gt;(seconds * Timestamp::kMicroSecondsPerSecond); return Timestamp(timestamp.microSecondsSinceEpoch() + delta);&#125;#endif 5.2 Timestamp.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;sys/time.h&gt;#include &lt;stdio.h&gt;#ifndef __STDC_FORMAT_MACROS#define __STDC_FORMAT_MACROS#endif#include &lt;inttypes.h&gt;#include &quot;Timestamp.h&quot;static_assert(sizeof(Timestamp) == sizeof(int64_t), &quot;Timestamp is same size as int64_t&quot;);std::string Timestamp::toString() const&#123; char buf[32] = &#123;0&#125;; int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond; int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond; snprintf(buf, sizeof(buf)-1, &quot;%&quot; PRId64 &quot;.%06&quot; PRId64 &quot;&quot;, seconds, microseconds); return buf;&#125;std::string Timestamp::toFormattedString(bool showMicroseconds) const&#123; char buf[64] = &#123;0&#125;; time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); struct tm tm_time; gmtime_r(&amp;seconds, &amp;tm_time); if (showMicroseconds) &#123; int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond); snprintf(buf, sizeof(buf), &quot;%4d%02d%02d-%02d:%02d:%02d.%06d&quot;, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec, microseconds); &#125; else &#123; snprintf(buf, sizeof(buf), &quot;%4d%02d%02d-%02d:%02d:%02d&quot;, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec); &#125; return buf;&#125;Timestamp Timestamp::now()&#123; struct timeval tv; gettimeofday(&amp;tv, NULL); int64_t seconds = tv.tv_sec; return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);&#125; 6 Logger 类实现 6.1 logging.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#ifndef _LOGGING_H#define _LOGGING_H#include &quot;logStream.h&quot;#include &quot;Timestamp.h&quot;class SourceFile&#123;public: template&lt;int N&gt; SourceFile(const char (&amp;arr)[N]) : data_(arr), size_(N-1) &#123; const char* slash = strrchr(data_, &#x27;/&#x27;); // builtin function if (slash) &#123; data_ = slash + 1; size_ -= static_cast&lt;int&gt;(data_ - arr); &#125; &#125; explicit SourceFile(const char* filename) : data_(filename) &#123; const char* slash = strrchr(filename, &#x27;/&#x27;); if (slash) &#123; data_ = slash + 1; &#125; size_ = static_cast&lt;int&gt;(strlen(data_)); &#125; const char* data_; int size_;&#125;;class Logger &#123;public: enum LogLevel &#123; TRACE, DEBUG, INFO, WARN, ERROR, FATAL, NUM_LOG_LEVELS, &#125;; Logger(SourceFile file, int line); Logger(SourceFile file, int line, LogLevel level); Logger(SourceFile file, int line, LogLevel level, const char* func); Logger(SourceFile file, int line, bool toAbort); ~Logger(); LogStream&amp; stream() &#123; return impl_.stream_; &#125; static LogLevel logLevel(); static void setLogLevel(LogLevel level); typedef void (*OutputFunc)(const char* msg, int len); typedef void (*FlushFunc)(); static void setOutput(OutputFunc); static void setFlush(FlushFunc);private:class Impl&#123;public: typedef Logger::LogLevel LogLevel; Impl(LogLevel level, int old_errno, const SourceFile&amp; file, int line); void formatTime(); void finish(); Timestamp time_; LogStream stream_; LogLevel level_; int line_; SourceFile basename_;&#125;; Impl impl_;&#125;;extern Logger::LogLevel g_logLevel;inline Logger::LogLevel Logger::logLevel()&#123; return g_logLevel;&#125;#define LOG_TRACE if (Logger::logLevel() &lt;= Logger::TRACE) \\ Logger(__FILE__, __LINE__, Logger::TRACE, __func__).stream()#define LOG_DEBUG if (Logger::logLevel() &lt;= Logger::DEBUG) \\ Logger(__FILE__, __LINE__, Logger::DEBUG, __func__).stream()#define LOG_INFO if (Logger::logLevel() &lt;= Logger::INFO) \\ Logger(__FILE__, __LINE__).stream()#define LOG_WARN Logger(__FILE__, __LINE__, Logger::WARN).stream()#define LOG_ERROR Logger(__FILE__, __LINE__, Logger::ERROR).stream()#define LOG_FATAL Logger(__FILE__, __LINE__, Logger::FATAL).stream()#define LOG_SYSERR Logger(__FILE__, __LINE__, false).stream()#define LOG_SYSFATAL Logger(__FILE__, __LINE__, true).stream()const char* strerror_tl(int savedErrno);#endif 6.2 logging.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sstream&gt;#include &quot;logging.h&quot;#include &quot;Timestamp.h&quot;__thread char t_errnobuf[512];__thread char t_time[64];__thread time_t t_lastSecond;static const char* LogLevelName[Logger::NUM_LOG_LEVELS] =&#123; &quot;TRACE &quot;, &quot;DEBUG &quot;, &quot;INFO &quot;, &quot;WARN &quot;, &quot;ERROR &quot;, &quot;FATAL &quot;,&#125;;const char* strerror_tl(int savedErrno)&#123; return strerror_r(savedErrno, t_errnobuf, sizeof t_errnobuf);&#125;Logger::LogLevel initLogLevel()&#123; if (::getenv(&quot;MUDUO_LOG_TRACE&quot;)) return Logger::TRACE; else if (::getenv(&quot;MUDUO_LOG_DEBUG&quot;)) return Logger::DEBUG; else return Logger::INFO;&#125;Logger::LogLevel g_logLevel = initLogLevel();// helper class for known string length at compile timeclass T&#123;public: T(const char* str, unsigned len) :str_(str), len_(len) &#123; // assert(strlen(str) == len_); &#125; const char* str_; const unsigned len_;&#125;;inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, T v)&#123; s.append(v.str_, v.len_); return s;&#125;inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, const SourceFile&amp; v)&#123; s.append(v.data_, v.size_); return s;&#125;void defaultOutput(const char* msg, int len)&#123; size_t n = fwrite(msg, 1, len, stdout);&#125;void defaultFlush()&#123; fflush(stdout);&#125;Logger::OutputFunc g_output = defaultOutput;Logger::FlushFunc g_flush = defaultFlush;Logger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile&amp; file, int line) : time_(Timestamp::now()), stream_(), level_(level), line_(line), basename_(file)&#123; formatTime(); stream_ &lt;&lt; T(LogLevelName[level], 6); stream_ &lt;&lt; basename_ &lt;&lt; &#x27;:&#x27; &lt;&lt; line_ &lt;&lt; &quot; &quot;; if (savedErrno != 0) &#123; stream_ &lt;&lt; strerror_tl(savedErrno) &lt;&lt; &quot; (errno=&quot; &lt;&lt; savedErrno &lt;&lt; &quot;) &quot;; &#125;&#125;void Logger::Impl::formatTime()&#123; int64_t microSecondsSinceEpoch = time_.microSecondsSinceEpoch(); time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch / Timestamp::kMicroSecondsPerSecond); int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch % Timestamp::kMicroSecondsPerSecond); if (seconds != t_lastSecond) &#123; t_lastSecond = seconds; struct tm tm_time; ::gmtime_r(&amp;seconds, &amp;tm_time); int len = snprintf(t_time, sizeof(t_time), &quot;%4d%02d%02d-%02d:%02d:%02d&quot;, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec); &#125; Fmt us(&quot;.%06d &quot;, microseconds); stream_ &lt;&lt; T(t_time, 17) &lt;&lt; T(us.data(), 9);&#125;void Logger::Impl::finish()&#123; stream_ &lt;&lt; &#x27;\\n&#x27;;&#125;Logger::Logger(SourceFile file, int line) : impl_(INFO, 0, file, line)&#123;&#125;Logger::Logger(SourceFile file, int line, LogLevel level, const char* func) : impl_(level, 0, file, line)&#123; impl_.stream_ &lt;&lt; func &lt;&lt; &#x27; &#x27;;&#125;Logger::Logger(SourceFile file, int line, LogLevel level) : impl_(level, 0, file, line)&#123;&#125;Logger::Logger(SourceFile file, int line, bool toAbort) : impl_(toAbort?FATAL:ERROR, errno, file, line)&#123;&#125;Logger::~Logger()&#123; impl_.finish(); const LogStream::Buffer&amp; buf(stream().buffer()); g_output(buf.data(), buf.length()); if (impl_.level_ == FATAL) &#123; g_flush(); abort(); &#125;&#125;void Logger::setLogLevel(Logger::LogLevel level)&#123; g_logLevel = level;&#125;void Logger::setOutput(OutputFunc out)&#123; g_output = out;&#125;void Logger::setFlush(FlushFunc flush)&#123; g_flush = flush;&#125; 6.3 Logger 测试 testLogger.cpp 1234567891011121314151617181920212223242526272829303132333435#include &quot;logFile.h&quot;#include &quot;logging.h&quot;#include &lt;unistd.h&gt;LogFile g_logFile(&quot;./mylog.log&quot;, 2);void outputFunc(const char* msg, int len)&#123; g_logFile.append(msg, len);&#125;void flushFunc()&#123; g_logFile.flush();&#125;int main(int argc, char* argv[])&#123; Logger::setOutput(outputFunc); Logger::setFlush(flushFunc); std::string line = &quot;abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ &quot;; for (int i = 0; i &lt; 10000; ++i) &#123; LOG_INFO &lt;&lt; line &lt;&lt; i; LOG_DEBUG &lt;&lt; line &lt;&lt; i; usleep(1000); if(i==5000) &#123; Logger::setLogLevel(Logger::DEBUG); &#125; &#125;&#125; 编译运行： 12g++ ./testLogger.cpp ./logFile.cpp ./fileUtil.cpp ./logStream.cpp ./logging.cpp ./Timestamp.cpp -o test./test 到这一步，相信异步Logger也呼之欲出了。我们可以新起一个线程专门负责写日志文件，其接收来自其他线程的写日志请求。由于其他线程写日志实际上是将字符串压进请求队列，所以这种操作是异步且高效的。这里需要注意的是线程安全的问题以及前端大量写入的问题，后续有时间再把异步Logger这部分代码补充完整。 https://github.com/chenshuo/muduo","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"日志记录","slug":"日志记录","permalink":"https://xie-peiquan.gitee.io/tags/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"}]},{"title":"5-I/O多路复用","slug":"C++那些事/5-IO多路复用","date":"2024-07-01T09:15:35.000Z","updated":"2025-05-14T02:14:15.248Z","comments":true,"path":"2024/07/01/C++那些事/5-IO多路复用/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/07/01/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/5-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"我们经常在单个线程中去管理某个数据 I/O ，但当软件变得复杂时，尤其是高并发的生产环境中，一个线程对应一个 I/O 会面临资源吃紧的情况。IO多路复用（Input/Output Multiplexing）是一种在单个线程中管理多个输入/输出通道的技术。它允许一个线程同时监听多个输入流（例如网络套接字、文件描述符等），并在有数据可读或可写时进行相应的处理，而不需要为每个通道创建一个独立的线程。 常见的IO多路复用机制包括 select、poll 和 epoll。这些机制通过将多个IO通道注册到一个事件管理器中，然后通过阻塞方式等待事件的发生。一旦有事件发生（如有数据可读或可写），线程就会被唤醒，然后可以针对具体的事件进行处理。 最近俞感 epoll 的好用，但当注册的通道变多时，代码容易变得很乱。这里参考muduo库，将使用 epoll 里面通用的部分给抽象出来，使代码使用起来简洁一点。 1 问题抽象 我们先简单地对 poll 模型抽象一下，其中稳定的部分是：poller会不断轮询用户注册的channel，当channel中有事件到来时，将事件及事件对应的活跃的channel传出，并回调活跃channel相应的处理函数。不稳定的部分是：用户注册的channel可能是不同类型的，且channel所对应的事件处理函数也是不一样的。 所以这里，将用户注册的数据通道抽象出一个Channel类，将IO复用轮询器抽象出一个EPoller类。这两个类的配合承担着以上稳定的部分。而用户不稳定的那部分，Channel类留出了相应的接口供用户进行定制。 2 Channel 类实现 2.1 需求分析 具备对 fd 的封装，且具备使能/去使能 fd 读写的能力。 具备接收用户设置 会话读/写/关闭/错误处理的能力。 具备响应 fd 产生的事件并进行相应处理的能力。 2.2 代码实现 channel.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#ifndef _NET_CHANNEL_H#define _NET_CHANNEL_H#include &lt;functional&gt;#include &lt;poll.h&gt;class EPoller;class Channel&#123;public: typedef std::function&lt;void()&gt; EventCallback; Channel(EPoller* poller, int fd); ~Channel(); //使能/去使能fd读写的标志位 static const int kNoneEvent = 0; static const int kReadEvent = POLLIN | POLLPRI; static const int kWriteEvent = POLLOUT; int fd() const &#123; return fd_; &#125; int events() const &#123; return uevents_; &#125; void set_revents(int revt) &#123; revents_ = revt; &#125; bool isNoneEvent() const &#123; return uevents_ == kNoneEvent; &#125; void enableReading() &#123; uevents_ |= kReadEvent; update(); &#125; void disableReading() &#123; uevents_ &amp;= ~kReadEvent; update(); &#125; void enableWriting() &#123; uevents_ |= kWriteEvent; update(); &#125; void disableWriting() &#123; uevents_ &amp;= ~kWriteEvent; update(); &#125; void disableAll() &#123; uevents_ = kNoneEvent; update(); &#125; bool isWriting() const &#123; return uevents_ &amp; kWriteEvent; &#125; bool isReading() const &#123; return uevents_ &amp; kReadEvent; &#125; void setReadCallback(EventCallback cb) &#123; readCallback_ = std::move(cb); &#125; void setWriteCallback(EventCallback cb) &#123; writeCallback_ = std::move(cb); &#125; void setCloseCallback(EventCallback cb) &#123; closeCallback_ = std::move(cb); &#125; void setErrorCallback(EventCallback cb) &#123; errorCallback_ = std::move(cb); &#125; void handleEvent(); int status() &#123; return status_; &#125; void set_status(int status) &#123; status_ = status; &#125; void remove();private: void update(); EPoller* poller_; const int fd_; int uevents_; //用户设置的事件 int revents_; //fd接收到的事件 int status_; //在poller中的状态 bool eventHandling_; EventCallback readCallback_; EventCallback writeCallback_; EventCallback closeCallback_; EventCallback errorCallback_;&#125;;#endif channel.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &quot;epoller.h&quot;#include &quot;channel.h&quot;Channel::Channel(EPoller* poller, int fd) : poller_(poller), fd_(fd), uevents_(0), revents_(0), status_(-1), eventHandling_(false)&#123;&#125;Channel::~Channel()&#123; ::close(fd_);&#125;void Channel::update()&#123; poller_-&gt;updateChannel(this);&#125;void Channel::remove()&#123; poller_-&gt;removeChannel(this);&#125;void Channel::handleEvent()&#123; eventHandling_ = true; if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) &#123; std::cout &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLHUP&quot; &lt;&lt; std::endl; if (closeCallback_) closeCallback_(); &#125; if (revents_ &amp; POLLNVAL) &#123; std::cout &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLNVAL&quot; &lt;&lt; std::endl; &#125; if (revents_ &amp; (POLLERR | POLLNVAL)) &#123; if (errorCallback_) errorCallback_(); &#125; if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) &#123; if (readCallback_) readCallback_(); &#125; if (revents_ &amp; POLLOUT) &#123; if (writeCallback_) writeCallback_(); &#125; eventHandling_ = false;&#125; 3 EPoller 类实现 3.1 需求分析 具备创建 epollfd 的能力。 具备从 channel_fd-&gt;epoll_fd 的增删改能力。 能感知channel事件到来，且将事件和对应的channel传递出去。 能够设置 epoll 的超时时间。 3.2 代码实现 epoller.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef _NET_EPOLLER_H#define _NET_EPOLLER_H#include &lt;vector&gt;class Channel;struct epoll_event;class EPoller&#123;public: typedef std::vector&lt;Channel*&gt; ChannelList; EPoller(); ~EPoller(); //channel在epollfd中状态的标识 static const int kNew = -1; //不在epollfd中 static const int kAdded = 1; //在epollfd中 static const int kInitEventListSize = 16; void updateChannel(Channel* channel); void removeChannel(Channel* channel); void update(int operation, Channel* channel); void poll(int timeoutMs, ChannelList* activeChannels); void fillActiveChannels(int numEvents,ChannelList* activeChannels) const; const char* operationToString(int op); private: int epollfd_; std::vector&lt;epoll_event&gt; events_;&#125;;#endif epoller.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;errno.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;memory.h&gt;#include &quot;channel.h&quot;#include &quot;epoller.h&quot;EPoller::EPoller() : epollfd_(::epoll_create1(EPOLL_CLOEXEC)), events_(kInitEventListSize)&#123; if (epollfd_ &lt; 0) &#123; std::cout &lt;&lt; &quot;EPollPoller::EPollPoller&quot; &lt;&lt; std::endl; &#125;&#125;EPoller::~EPoller()&#123; ::close(epollfd_);&#125;void EPoller::poll(int timeoutMs, ChannelList* activeChannels)&#123; int numEvents = ::epoll_wait(epollfd_, &amp;*events_.begin(), static_cast&lt;int&gt;(events_.size()), timeoutMs); int savedErrno = errno; if (numEvents &gt; 0) &#123; std::cout &lt;&lt; numEvents &lt;&lt; &quot; events happened&quot; &lt;&lt;std::endl; fillActiveChannels(numEvents, activeChannels); if (static_cast&lt;size_t&gt;(numEvents) == events_.size()) &#123; events_.resize(events_.size()*2); &#125; &#125; else if (numEvents == 0) &#123; std::cout &lt;&lt; &quot;nothing happened&quot; &lt;&lt;std::endl; &#125; else &#123; // error happens, log uncommon ones if (savedErrno != EINTR) &#123; errno = savedErrno; std::cout &lt;&lt; &quot;EPoller::poll()&quot; &lt;&lt;std::endl; &#125; &#125;&#125;void EPoller::fillActiveChannels(int numEvents, ChannelList* activeChannels) const&#123; for (int i = 0; i &lt; numEvents; ++i) &#123; Channel* channel = static_cast&lt;Channel*&gt;(events_[i].data.ptr); channel-&gt;set_revents(events_[i].events); activeChannels-&gt;push_back(channel); &#125;&#125;void EPoller::updateChannel(Channel* channel)&#123; const int status = channel-&gt;status(); if (status == kNew) &#123; // a new one, add with EPOLL_CTL_ADD int fd = channel-&gt;fd(); channel-&gt;set_status(kAdded); update(EPOLL_CTL_ADD, channel); &#125; else &#123; // update existing one with EPOLL_CTL_MOD/DEL int fd = channel-&gt;fd(); if (channel-&gt;isNoneEvent()) &#123; update(EPOLL_CTL_DEL, channel); channel-&gt;set_status(kNew); &#125; else &#123; update(EPOLL_CTL_MOD, channel); &#125; &#125;&#125;void EPoller::removeChannel(Channel* channel)&#123; int fd = channel-&gt;fd(); int status = channel-&gt;status(); if (status == kAdded) &#123; update(EPOLL_CTL_DEL, channel); &#125; channel-&gt;set_status(kNew);&#125;void EPoller::update(int operation, Channel* channel)&#123; struct epoll_event event; memset(&amp;event, 0, sizeof(event)); event.events = channel-&gt;events(); event.data.ptr = channel; int fd = channel-&gt;fd(); if (::epoll_ctl(epollfd_, operation, fd, &amp;event) &lt; 0) &#123; if (operation == EPOLL_CTL_DEL) &#123; std::cout &lt;&lt; &quot;epoll_ctl err: op =&quot; &lt;&lt; operationToString(operation) &lt;&lt; &quot; fd =&quot; &lt;&lt; fd &lt;&lt;std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;epoll_ctl err: op =&quot; &lt;&lt; operationToString(operation) &lt;&lt; &quot; fd =&quot; &lt;&lt; fd &lt;&lt;std::endl; &#125; &#125;&#125;const char* EPoller::operationToString(int op)&#123; switch (op) &#123; case EPOLL_CTL_ADD: return &quot;ADD&quot;; case EPOLL_CTL_DEL: return &quot;DEL&quot;; case EPOLL_CTL_MOD: return &quot;MOD&quot;; default: return &quot;Unknown Operation&quot;; &#125;&#125; 4 用户通道类实现 这里为了做一个简单地测试，基于 timerfd 实现一个 PeriodicTimer 类。这其实是一个定时器，通过向 timerfd 设置到期时间，当到时得时候，timerfd 会产生事件。PeriodicTimer 类是对Channel类做一个包装，并最终将 timerfd 注册到 EPoller类里面去。 4.1 代码实现 timer.h 12345678910111213141516171819202122232425262728#ifndef _TIMER_H#define _TIMER_H#include &lt;functional&gt;class EPoller;class Channel;class PeriodicTimer&#123; public: typedef std::function&lt;void()&gt; TimerCallback; PeriodicTimer(EPoller* poller, double interval, const TimerCallback&amp; cb); ~PeriodicTimer(); void start(); void stop();private: void handleRead(); const int timerfd_; Channel timerfdChannel_; const double interval_; // in seconds TimerCallback cb_;&#125;;#endif timer.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/timerfd.h&gt;#include &lt;memory.h&gt;#include &lt;iostream&gt;#include &quot;epoller.h&quot;#include &quot;channel.h&quot;#include &quot;timer.h&quot;int createTimerfd()&#123; int timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC); if (timerfd &lt; 0) &#123; std::cout &lt;&lt; &quot;Failed in timerfd_create&quot; &lt;&lt;std::endl; &#125; return timerfd;&#125;static struct timespec toTimeSpec(double seconds)&#123; struct timespec ts; memset(&amp;ts, 0, sizeof ts); const int64_t kNanoSecondsPerSecond = 1000000000; const int kMinInterval = 100000; int64_t nanoseconds = static_cast&lt;int64_t&gt;(seconds * kNanoSecondsPerSecond); if (nanoseconds &lt; kMinInterval) nanoseconds = kMinInterval; ts.tv_sec = static_cast&lt;time_t&gt;(nanoseconds / kNanoSecondsPerSecond); ts.tv_nsec = static_cast&lt;long&gt;(nanoseconds % kNanoSecondsPerSecond); return ts;&#125;PeriodicTimer::PeriodicTimer(EPoller* poller, double interval, const TimerCallback&amp; cb) : timerfd_(::createTimerfd()), timerfdChannel_(poller, timerfd_), interval_(interval), cb_(cb)&#123; timerfdChannel_.setReadCallback( std::bind(&amp;PeriodicTimer::handleRead, this)); timerfdChannel_.enableReading();&#125;PeriodicTimer::~PeriodicTimer()&#123; timerfdChannel_.disableAll(); timerfdChannel_.remove(); ::close(timerfd_);&#125;void PeriodicTimer::handleRead()&#123; // 需读清到时标志 uint64_t howmany; ssize_t n = ::read(timerfd_, &amp;howmany, sizeof howmany); if (n != sizeof howmany) &#123; std::cout &lt;&lt; &quot;TimerQueue::handleRead() reads &quot; &lt;&lt; n &lt;&lt; &quot; bytes instead of 8&quot; &lt;&lt;std::endl; &#125; if (cb_) cb_();&#125;void PeriodicTimer::start()&#123; struct itimerspec spec; memset(&amp;spec, 0, sizeof spec); spec.it_interval = toTimeSpec(interval_); spec.it_value = spec.it_interval; int ret = ::timerfd_settime(timerfd_, 0 /* relative timer */, &amp;spec, NULL); if (ret) &#123; std::cout &lt;&lt; &quot;timerfd_settime()&quot; &lt;&lt; std::endl; &#125;&#125;void PeriodicTimer::stop()&#123; struct itimerspec spec; memset(&amp;spec, 0, sizeof spec); int ret = ::timerfd_settime(timerfd_, 0, &amp;spec, NULL); if (ret) &#123; std::cout &lt;&lt; &quot;timerfd_settime()&quot; &lt;&lt; std::endl; &#125; timerfdChannel_.disableAll();&#125; 5 程序测试 我们向 EPoller 注册两个 PeriodicTimer 通道，让 EPoller 同时处理这两个IO. 代码如下： 5.1 测试代码 main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &quot;channel.h&quot;#include &quot;epoller.h&quot;#include &quot;timer.h&quot;static const int kPollTimeMs = 3000;void timer1_print()&#123;std::cout&lt;&lt;&quot;timer1&quot;&lt;&lt;std::endl;&#125;void timer2_print()&#123;std::cout&lt;&lt;&quot;timer2&quot;&lt;&lt;std::endl;&#125;int main()&#123; int cnt = 0; EPoller poller; EPoller::ChannelList activeChannels; PeriodicTimer timer1(&amp;poller,1, timer1_print); PeriodicTimer timer2(&amp;poller,2, timer2_print); timer1.start(); timer2.start(); while(1) &#123; activeChannels.clear(); poller.poll(kPollTimeMs, &amp;activeChannels); for (Channel* channel : activeChannels) &#123; channel-&gt;handleEvent(); &#125; if (cnt==5) &#123; timer1.stop(); &#125; cnt++; &#125; return 0;&#125; 5.2 编译执行 12g++ ./main.cpp ./channel.cpp ./epoller.cpp ./timer.cpp -o main./main | ts 5.3 测试结果 12345678910111213141516171819202122Jul 01 15:59:46 1 events happenedJul 01 15:59:46 timer1Jul 01 15:59:47 2 events happenedJul 01 15:59:47 timer1Jul 01 15:59:47 timer2Jul 01 15:59:48 1 events happenedJul 01 15:59:48 timer1Jul 01 15:59:49 2 events happenedJul 01 15:59:49 timer1Jul 01 15:59:49 timer2Jul 01 15:59:50 1 events happenedJul 01 15:59:50 timer1Jul 01 15:59:51 2 events happenedJul 01 15:59:51 timer1Jul 01 15:59:51 timer2Jul 01 15:59:53 1 events happenedJul 01 15:59:53 timer2Jul 01 15:59:55 1 events happenedJul 01 15:59:55 timer2Jul 01 15:59:57 1 events happenedJul 01 15:59:57 timer2Jul 01 15:59:59 1 events happened 可以看出，EPoller可以处理两个同时产生事件的Channel，同时Channel 也可以动态完成在 EPoller 中的注册与注销。需要注意的是，这里对IO轮询与事件处理是放在同一个线程，如果负荷较重，建议把事件放在线程池中处理，这样不会影响对事件感知的及时性。 https://blog.csdn.net/m0_67318913/article/details/138442134 https://github.com/chenshuo/muduo","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"IO复用","slug":"IO复用","permalink":"https://xie-peiquan.gitee.io/tags/IO%E5%A4%8D%E7%94%A8/"}]},{"title":"1-SQLite语法一页纸","slug":"数据库/1-SQLite语法一页纸","date":"2024-03-27T03:08:18.000Z","updated":"2025-05-14T02:14:15.356Z","comments":true,"path":"2024/03/27/数据库/1-SQLite语法一页纸/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/1-SQLite%E8%AF%AD%E6%B3%95%E4%B8%80%E9%A1%B5%E7%BA%B8/","excerpt":"","text":"基础语法 创建数据库 存在则连接，不存在则创建。 .database 可查询存在哪些数据库。 1.open xxx.db 创建表 ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL。.tables 可查询存在哪些表。 1234567CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 删除表 1DROP TABLE table_name; Insert 语句（增） 123456789# 写法一（带key）：INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 );# 写法二（不带key）：INSERT INTO COMPANY VALUES (7, &#x27;James&#x27;, 24, &#x27;Houston&#x27;, 10000.00 );# 新增列：ALTER TABLE MyTable ADD COLUMN age INTEGER; Select 语句 （查） 12345SELECT ID, NAME, SALARY FROM COMPANY;# 若要显示表头.header ON.mode column Where 子句 （条件） 用于带上条件。 1SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; Update 语句 （改） 1UPDATE COMPANY SET ADDRESS = &#x27;Texas&#x27; WHERE ID = 6; Delete 语句 （删） 12DELETE FROM COMPANY WHERE ID = 7;DELETE FROM COMPANY; //删除所有 Like 子句 （匹配） LIKE 用于文本字符串匹配，与通配符 % 或 _ 一起使用。百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 例如： 12345SELECT column_list FROM table_nameWHERE column LIKE &#x27;%XXXX%&#x27;SELECT column_list FROM table_nameWHERE column LIKE &#x27;XXXX_&#x27; 注：Like 也可以匹配数值，比如 SELECT * FROM COMPANY WHERE AGE LIKE '2%'; 匹配以2开头的数值，惊不惊喜 😏 Glob 子句 （匹配） 与 LIKE 运算符类似，但是GLOB 是大小写敏感的。搭配一下通配符： *：匹配零个、一个或多个数字或字符。 ?：代表一个单一的数字或字符。 [...]：匹配方括号内指定的字符之一。例如，[abc] 匹配 “a”、“b” 或 “c” 中的任何一个字符。 [^...]：匹配不在方括号内指定的字符之一。例如，[^abc] 匹配不是 “a”、“b” 或 “c” 中的任何一个字符的字符。 1SELECT * FROM users WHERE username GLOB &#x27;[^0-9]*&#x27;; Limit 子句 （限制条目） 限制输出条目，可搭配 OFFSET 使其从某个位置开始输出。 1sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; Order By 子句 （排序） 1234567SELECT select_listFROM tableORDER BY column_1 ASC, # 升序 column_2 DESC; # 降序 1SELECT * FROM COMPANY ORDER BY SALARY ASC; Group By 子句 （分组） 用于分组，在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。注：如果分组后没有对组进行操作，那么查询出来的结果可能只是组中的一个成员。 1SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME; # 分组后薪资求和 Having 子句（过滤分组） HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。HAVING 子句在Select语句中的位置如下： 123456SELECTFROMWHEREGROUP BYHAVINGORDER BY 1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; DISTINCT 关键字（去重） 用于去重。 1SELECT DISTINCT name FROM COMPANY; 算数运算符 运算符 描述 == 是否相等，如果相等则条件为真。 = 是否相等，如果相等则条件为真。 != 是否不相等，如果不相等则条件为真。 &lt;&gt; 是否不相等，如果不相等则条件为真。 &gt; 是否大于，如果是则条件为真。 &lt; 是否小于，如果是则条件为真。 &gt;= 是否大于等于，如果是则条件为真。 &lt;= 是否小于等于，如果是则条件为真。 !&lt; 是否不小于，如果是则条件为真。 !&gt; 是否不大于，如果是则条件为真。 逻辑运算符 运算符 描述 AND 多个条件 且 。 OR 多个条件 或 。 NOT 条件 非 。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。 IN 某个值在 指定列表里面 。``如 SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 ); NOT IN 某个值不在 指定列表里面 。 LIKE 字符串匹配 。``如 SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%'; GLOB 字符串匹配 。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。``如 SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*'; BETWEEN 在给定最小值和最大值范围内搜索值。``如 SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27; （闭区间） EXISTS 在满足一定条件中搜索行的存在。``如 SELECT AGE FROM COMPANY WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); IS NULL 某个值是 NULL 。 IS NOT IS NOT 运算符与 != 相似。 || 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 高级语法 空间管理 123456789101112131415# 限制数据库大小，设置页面大小为 4096 字节，最大页面数为 1000000。# 注意：仅当前连接会话有效PRAGMA page_size = 4096;PRAGMA max_page_count = 1000000;# 清理空闲空间，将被删除数据清理掉。VACUUM;# 清理旧数据DELETE FROM your_tableWHERE primary_key_column IN ( SELECT primary_key_column FROM your_table LIMIT 10); 建表约束 NOT NULL 约束：确保某列不能有 NULL 值。 DEFAULT 约束：当某列没有指定值时，为该列提供默认值。 UNIQUE 约束：确保某列中的所有值是不同的。 PRIMARY Key 约束：唯一标识数据库表中的各行/记录。 CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。 JOIN 子句 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段。SQL 定义了三种主要类型的连接： 交叉连接 - CROSS JOIN 内连接 - INNER JOIN 外连接 - OUTER JOIN 交叉连接 - CROSS JOIN 交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。如果两个输入表分别有 x 和 y 行，则结果表有 x*y 行。由于交叉连接（CROSS JOIN）有可能产生非常大的表，使用时必须谨慎，只在适当的时候使用它们。 下面是交叉连接（CROSS JOIN）的语法： 1SELECT ... FROM table1 CROSS JOIN table2 ... 基于上面的表，我们可以写一个交叉连接（CROSS JOIN），如下所示： 1SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT; 内连接 - INNER JOIN 内连接（INNER JOIN）根据连接谓词结合两个表（table1 和 table2）的列值来创建一个新的结果表。查询会把 table1 中的每一行与 table2 中的每一行进行比较，找到所有满足连接谓词的行的匹配对。当满足连接谓词时，A 和 B 行的每个匹配对的列值会合并成一个结果行。 内连接（INNER JOIN）是最常见的连接类型，是默认的连接类型。INNER 关键字是可选的。 下面是内连接（INNER JOIN）的语法： 1SELECT ... FROM table1 [INNER] JOIN table2 ON conditional_expression ... 为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表： 1SELECT ... FROM table1 JOIN table2 USING ( column1 ,... ) ... 基于上面的表，我们可以写一个内连接（INNER JOIN），如下所示： 12SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENTON COMPANY.ID = DEPARTMENT.EMP_ID; 外连接 - OUTER JOIN SQLite 的 OUTER JOIN 是 左外连接。左外连接可以认为是以左表为主的，去右表寻找额外信息。若在右表找不到额外信息，则以 NULL 值填充。 下面是左外连接（LEFT OUTER JOIN）的语法： 1SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ... 为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明外连接（OUTER JOIN）条件。这个表达式指定一个或多个列的列表： 1SELECT ... FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,... ) ... 基于上面的表，我们可以写一个外连接（OUTER JOIN），如下所示： 12SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENTON COMPANY.ID = DEPARTMENT.EMP_ID; UNION 子句 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。 12345SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_IDUNIONSELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; 如果需要包含重复行，可以用 UNION ALL : 12345SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_IDUNION ALLSELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT ON COMPANY.ID = DEPARTMENT.EMP_ID; Index 索引 索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。 使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。 123456789101112# 单列索引CREATE INDEX if not exists index_name ON table_name (column_name);# 组合索引CREATE INDEX if not exists index_name ON table_name (column1, column2);# 唯一索引,唯一索引不允许任何重复的值插入到表中。CREATE UNIQUE INDEX if not exists index_name ON table_name (column_name); # 隐式索引，隐式索引是在创建对象时，由数据库服务器自动创建的索引。索引自动创建为主键约束和唯一约束。# 查看索引.indices table_name# 删除索引DROP INDEX index_name; 注：以下情况不要使用索引： 索引不应该使用在较小的表上。 索引不应该使用在有频繁的大批量的更新或插入操作的表上。 索引不应该使用在含有大量的 NULL 值的列上。 索引不应该使用在频繁操作的列上。 Indexed By 子句 利用上一步创建的Index，配合Select语句，加速查询。 1SELECT * FROM COMPANY INDEXED BY salary_index WHERE salary &gt; 5000; Alter 语句 1234# 更改表名ALTER TABLE COMPANY RENAME TO OLD_COMPANY;# 添加新列ALTER TABLE OLD_COMPANY ADD COLUMN SEX char(1); View 语句 视图（View）是一种虚表，视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。 1234567# 创建view视图CREATE VIEW COMPANY_VIEW ASSELECT ID, NAME, AGE FROM COMPANY;# 查看view视图SELECT * FROM COMPANY_VIEW;# 删除视图DROP VIEW COMPANY_VIEW; SQLite 事务 事务（Transaction）是一个对数据库执行工作单元。事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID： **原子性（Atomicity）：**确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。 **一致性（Consistency)：**确保数据库在成功提交的事务上正确地改变状态。 **隔离性（Isolation）：**使事务操作相互独立和透明。 **持久性（Durability）：**确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。 事务的控制语句 BEGIN：使用 BEGIN 或 BEGIN TRANSACTION 启动事务。直到遇到 COMMIT 或 ROLLBACK 命令。在数据库关闭或发生错误时，事务处理也会自动回滚。 不使用 begin 的语句自动 commit。 COMMIT：执行事务，从上一个 COMMIT 或 ROLLBACK 算起。该命令能保证 ACID 。 ROCKBACK：撤销事务，从上一个 COMMIT 或 ROLLBACK 算起。该命令能保证 ACID 。 1234567BEGIN;DELETE FROM COMPANY WHERE AGE = 25;ROLLBACK;BEGIN;DELETE FROM COMPANY WHERE AGE = 25;COMMIT; Autoincrement 关键字 用于表中的字段值自动递增。我们可以在创建表时在特定的列名称上使用 AUTOINCREMENT 关键字实现该字段值的自动增加。 1234567891011CREATE TABLE COMPANY( ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL);# 增加条目时不必指定ID, ID为自动增加。INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)VALUES ( &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 ); 日期 &amp; 时间 123456789101112# 指定时间范围SELECT * FROM salesWHERE sales_date BETWEEN &#x27;2022-01-01&#x27; AND &#x27;2022-12-31&#x27;;# 指定过去七天SELECT * FROM salesWHERE sales_date BETWEEN DATE(&#x27;now&#x27;, &#x27;-7 days&#x27;) AND DATE(&#x27;now&#x27;);# SELECT 打印精确时间SELECT id, date AS formatted_timestamp FROM COMPANY;# 插入时间戳INSERT INTO COMPANY VALUES (800, &#x27;James&#x27;, 24, &#x27;Houston&#x27;, 10000.00, 1, datetime(&#x27;now&#x27;) );INSERT INTO COMPANY VALUES (801, &#x27;James&#x27;, 24, &#x27;Houston&#x27;, 10000.00, 1, strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;,&#x27;now&#x27;) ); https://www.runoob.com/sqlite/sqlite-tutorial.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://xie-peiquan.gitee.io/tags/SQLite/"}]},{"title":"聊点音乐","slug":"音乐/聊点音乐","date":"2024-03-22T02:45:26.000Z","updated":"2025-05-14T02:14:15.380Z","comments":true,"path":"2024/03/22/音乐/聊点音乐/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/22/%E9%9F%B3%E4%B9%90/%E8%81%8A%E7%82%B9%E9%9F%B3%E4%B9%90/","excerpt":"","text":"OK，今天不聊技术。技术只是为了谋生，在生存的基础上，艺术/哲学或许才是人的最终追求和归宿。当然我没有这么高雅的追求啦，只不过在无聊和闲暇之际找一种寄托罢了。我并没有什么艺术细胞，20多年来似乎也从未真正地钻研过。只不过似乎跟艺术又有说不清道不明的关系，又加上每次稍微置身其中就有莫名感受。所以我想或许我应该记录些什么，也当做在无趣的技术文章中留点有趣的东西。 前面讲到艺术，其实是一个很抽象的概念，我也不晓得怎么去讲明白这个东西。不如直白一点，聊点音乐。最早接触音乐大概是在小时候唱儿歌的时候，那时候还是录音机/DVD的时候，大致就是跟着老师一句一句地唱，至于唱了什么，唱的怎么样，我是一点印象都没有。我接受最“专业”的音乐教学大概是在小学吧，至于到了初中、高中，可以说基本上没有音乐这门课，因为似乎音乐老师也不认为这是一门重要的课，常常把音乐课变成电影课或者为主科让道的自习课。因此你若要问我稍微深一点的乐理，我大概是不懂的。等等，高中有音乐老师么。。 说回小学，为什么说小学是我接受最“专业”音乐教学的时候呢，或许还是偶然，我当时4,5年级的班主任是语文兼音乐老师，印象中是一位音乐专业的老师，她教的得很有趣也很专业，那大概是小学里面最放松最有趣的课堂了。课堂上老师会教一些开喉的技巧，一些简谱的发声，吸气停顿，以及一些简单的节拍。虽说只是一些简单的乐理，但对于我来说算是音乐的启蒙了。那时候家里有一个小的电子琴玩具，只有C3到C4的8个音，不过也够我弹《茉莉花》了。有些音不在那个音区，就拿最近的音来凑，感觉也像是那么回事，在那个时候就萌发了一点兴趣。后来我妈似乎看出点什么，在地摊上给我买了一根竖笛，我也只能吹出8个音，不过竖笛可以通过气息吹出悠扬的感觉，一度让我很是沉迷，甚至有些不务正业。那个时候自己写了一本小本子，记录一些老师教的技巧以及能通过8个音吹出来的曲子，中午上学前会经常拿出来吹。那时候感觉像啥，像躺在林荫下吹牧笛的牧童，巴适。事实上这是我上学期间唯一做的一本有关乐曲的笔记，后来没好好保存弄丢了，可惜了。在物质匮乏的年代，总能找些有意思的事情做，没人逼你，没有目标，随心而动。 到后来接触的就是乡里锣鼓班的曲目教学，这是一个不以盈利为目的的春节锣鼓班（当时），每年春节出动一次。演奏前几个月组织乡里的一批人过来学习演奏曲目，有年事已高的老头，也有一窍不通的年轻人。只要你有兴趣，都可以进来学习，有经验老道的老人教着一群小屁孩，不求完美，只图春节有个氛围。我曾经在里面的小房子泡过，大冷天的一到8点听到鼓声就凑过去了。因为对里面的乐器都不懂，我只能听着他们练习。emm，老头吹得潮汕曲目是真好听。后来不知道是什么途径，我妈向锣鼓班借来了一支萧和几首曲目，说可以让我先练习。因为在家没人教，我能吹出来的音并不全，曲子也只是吹了前面几段。其实那个时候如果我能自愿跟着他们学习，学会几首曲子应该是没问题，并且收获肯定也不止是音乐上的。可惜，那个时候我已经上初中了。。那也大概是我上学期间离 学音乐 最近也是最后的一次。 后来接触到流行音乐，同样的沉迷一发不可收拾，把歌词抄到一页纸上，花几个小时学着唱，不感觉到累。这种音乐几乎很近，近到你打开 CCTV3（当时智能手机并未普及，嘿嘿）这个频道就有，但这种音乐又很远，远到你感觉不到它是一种音乐。这种感觉很难说明白，似乎它把我的注意力吸引到歌词和旋律上面，让我像在读一首朗朗上口的诗歌，至于它背后是怎么把这些个音连起来的，谁又明白呢。或许，如果那时候没有那股信息技术大浪潮，我还就真的钻进去了。信息爆炸的时代，会有多少人专情于一件事情、一首歌呢？ 扯远了，直到现在，我的手机里面有上千首歌，几十张歌单，但是时不时能听出莫名感觉的，还是纯音乐。如钢琴、小提琴或者二胡，或者各种管弦乐的合奏，总能听出鸡皮疙瘩的生理反应。也正因为此，在工作后买回来的第一个电子设备，是电子琴。即使工作忙碌、乐理不全、手指不听使唤，但是若能在某个悠闲的周末，弹上一曲，情随琴动，便是感激不已。当然这也只是主观感受，旁人舍友看到可能在想这傻子在弄啥嘞。好了，下面记录一些零碎的记录，不足以称为音乐，某个时间 某个地点 某种情绪的记录罢了。 《问候歌》2021.01 深圳 这是一首我经常拿来暖手的曲子，没有什么特别的理由，因为简单。如果非要说理由，那大概也是因为小时候（四年级暑假）在一部台剧中听过这首曲子，男主居然可以用这么简单的曲子打动女主？！，电视里都是骗人的啊呜呜，看过罗志祥的台剧应该对这首曲子有印象。说来也奇怪啊，童年的记忆明明都很潦草，却在某个时刻的点拨变得记忆犹新。 Your browser does not support the audio tag. 《萱草花》2021.04 深圳 初次听到这首歌是在《你好，李焕英》这部电影中，一开始是当喜剧来看的，没想到最后贾玲来了段特别煽情的，BGM正是这首。共鸣有时是可怕的，即使是硬汉也挡不住排山倒海的情绪翻涌。印象中那几天是清明，远处山色朦胧，小雨绵延不绝，回想故人往事，心情很难平复，于是有了这首。大致是几个小时弹出来的，略有生疏，但情绪基本在每个音中。致，一直懂我的远方故人。 Your browser does not support the audio tag. 《想见你》2021.01 深圳 弹这首是因为那段时间在刷《想见你》这部电视剧，其实我很少看电视剧，但如果看进去便一发不可收拾，会熬夜地看，哪怕第二天顶着黑眼圈在梦里写代(B)码(UG)。看完之后呢还要再过两三天才能从里面出来，这首便是在看完的那两三天弹下的，不完整，心血来潮，有感而发，和弦都没来得及合，见谅🥲。下面是我在网上找到的一张图，这种“莫比乌斯”式的双向穿越在看的时候还感觉蛮有意思的，这不比漫威最近整的什么平行时空来的好看。 Your browser does not support the audio tag. 《菊花台》 2021.02 深圳 谁的记忆里没有一首周杰伦呢？因而弹这首的时候没有太多理由，单纯只是想有一首Jay. 当然周杰伦的歌这么多，为什么偏偏是这一首啊。我也不明白，可能这一首比较容易代入吧。《菊花台》总会让我想到《满城尽带黄金甲》结局的时候，元杰兵败被命令伺候母后服药，他无法保护自己的母亲，却也不愿亲手伤害母亲，自刎而尽。这种无助，我能理解。说回曲子，第一次弹这么长的曲子，也没好好练习，一次性弹下来不是很好，Jay粉别骂我。特意截取了一个简短版本，建议戳简短版。 Your browser does not support the audio tag. Your browser does not support the audio tag. 《这世界那么多人》 2021.10 深圳 这是一首我很喜欢的歌，莫文蔚的歌会给我一种感觉，她明明没在讲故事，却让你满脑子都是往事。“灰树叶飘转在池塘，看飞机轰的一声去远方”；“这悠长命运中的晨昏，常让我，望远方出神”。这些歌词有没有让你想起那个曾经背起行囊，远离故乡求学、工作的身影呢？或者是某个黄昏，坐在阳台呆呆出神的平凡和迷茫呢？这世界那么多人，哪里又才是属于自己的立身之处呢？不知道你们是怎么理解的呢？弹这首曲子的时候，既能感觉到回忆的温暖，又有前途的艰辛，还有未知和迷茫，这或许是我等平凡打工人才有的感受吧😂 这首曲子有一个小提琴版本，也很好听，小提琴的特质把曲子里的情感变得更加细腻悠长。 Your browser does not support the audio tag. 《老男孩弹唱》2023.07 深圳 翻记录才知道，距离我上一个录音已有一年多。不是不喜欢了，而是这段时间我忙其他事情去了😂 时间快的惊人，一转眼已经被社会打磨了三年。回头望望，这条路走了多远呢，曾经的诺言又实现了多少呢，哈哈，果然迷茫是我等年轻打工人永恒的主题。这首曲子是我第一次录弹唱，没有刻意练，即兴唱了一段。只唱了前半段，副歌太高了没唱上去，期待有伙伴能教我，等会唱了一定补上。像我这种五音不全，喉咙机能差的，又没有好好练，只是唱个开心，见谅。 Your browser does not support the audio tag. 《哭砂清唱》 2023.12 深圳 这也是一首我很喜欢的歌，不过这首歌有点年代，一开始是从陈冠宇老师的钢琴曲认识的。相信我，你一定会听出鸡皮疙瘩的，这应该也是我2023年循环最多的一首钢琴曲，为什么可以弹这么好听啊😭 之所以放的不是弹出来的曲子，是因为我一直没有弹出来那种感觉，和弦也没有和好。虽然我很清楚我的水平，但是哪怕是有一点点类似的感觉在里面呢。出于对这首曲子的喜爱吧，先发个清唱占个坑，后来弹好了一定补上。对于这个清唱呢，里面音准和气息可能有些问题，本来想看看有什么修音软件可以修修，后来想想还是算了吧，等我感觉不好意思就把他撤下来，嘻嘻。还有，阿妹唱的也很好，那个年代的歌总给我感觉很有质感。 2024.01：发现宝藏up主，顺便把自己的录音撤下😂 附陈冠宇《哭砂》：https://t4.kugou.com/song.html?id=3AgD97cCJV2","categories":[{"name":"音乐","slug":"音乐","permalink":"https://xie-peiquan.gitee.io/categories/%E9%9F%B3%E4%B9%90/"}],"tags":[{"name":"聊点音乐","slug":"聊点音乐","permalink":"https://xie-peiquan.gitee.io/tags/%E8%81%8A%E7%82%B9%E9%9F%B3%E4%B9%90/"}]},{"title":"9-MySQL事务隔离","slug":"数据库/9-MySQL事务隔离","date":"2024-03-22T02:30:49.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2024/03/22/数据库/9-MySQL事务隔离/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/9-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/","excerpt":"","text":"1 事务并发的问题 1.1 脏写（Dirty Write） 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了 脏写。（我在写，别人也在写） 1.2 脏读（Dirty Read） 如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了 脏读。（我在读，别人在写） 1.3 不可重复读（Non-Repeatable Read） 如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了 不可重复读。（前后两次读不一致） 1.4 幻读（Phantom） 如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了 幻读 。强调了读到了之前读取没有获取到的记录。（后一次读比前一次多） **从严重性来排序的话：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读 **。 2 SQL标准的隔离级别 如果我们让事务串行，就不会产生以上的问题，但无疑会牺牲一些性能。实际上我们会舍弃一部分隔离性来换取一部分性能。SQL标准设立四个隔离级别，针对不同的隔离级别，并发事务可以发生不同严重程度的问题： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED （未提交读） 可能 可能 可能 READ COMMITTED （已提交读） 不可能 可能 可能 REPEATABLE READ （可重复读） 不可能 不可能 可能 SERIALIZABLE （可串行化） 不可能 不可能 不可能 而脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。 设置隔离级别 MySQL 的默认隔离级别为 REPEATABLE READ ，我们可以手动修改一下事务的隔离级别。 1234567891011# GLOBAL 只对执行完该语句之后产生的会话起作用。# SESSION 对当前会话的所有后续的事务有效。SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;# 可选levellevel: &#123; REPEATABLE READ READ COMMITTED READ UNCOMMITTED SERIALIZABLE&#125; 3 MVCC原理 对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（ row_id 并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含 row_id 列）： trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 事务id 赋值给 trx_id 隐藏列。 roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志中，roll_pointer 就相当于一个指针，指向这条 undo 日志。 对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当前记录最新的值。 所谓的 MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。 READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。 《MySQL是怎样运行的：从根儿上理解MySQL》","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xie-peiquan.gitee.io/tags/MySQL/"}]},{"title":"5-MySQL-InnoDB索引","slug":"数据库/5-MySQL-InnoDB索引","date":"2024-03-19T07:18:12.000Z","updated":"2025-05-14T02:14:15.364Z","comments":true,"path":"2024/03/19/数据库/5-MySQL-InnoDB索引/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/5-MySQL-InnoDB%E7%B4%A2%E5%BC%95/","excerpt":"","text":"快速的查找一般是建立在数据有序的基础上，而有序一般是依赖一个可以用来排序的 键 来排列。我们把这种通过键查找到对应数值的过程叫 索引查找 。如果我们要查找的目标不能通过 键 来查找，那么查找就只能从头到尾的遍历所有数据页，这对于大数据库来讲，是慢得可怕的。慢得原因也很明显，它没有走索引。 那么以上涉及到两个问题，一个是InnoDB是如何快速索引的？一个是如果我们的SQL查询语句不能走索引，怎么办？ 1 InnoDB 如何索引 前几章我们讲了InnoDB的存储结构：数据被划分在好多个页中，每个页中数据被分为好几组（槽），组也是有序的。那么，我们大致可以猜想，InnoDB的索引方式是：快速地定位到某个页，加载页到内存，在页中二分查找到对应的槽，在槽中遍历找到目标条目。那么，InnoDB又是怎么快速地定位到某个页的呢？ 明显的，想要快速地定位到某个页，也需要页是有序的。这意味着：下一个数据页中的最小主键值必须大于上一个页的主键值。因为这些 16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：页的用户记录中最小的主键值，我们用 key 来表示。页号，我们用 page_no 表示。这个目录也叫 索引。 从上图，我们可以从目录中找到我们的key所对应的目录项，进而找到我们的目标页。那么怎么快速找到目录项呢？二分查找行不行？用树？那为什么是B+树？ 记住，在数据引擎中，I/O操作是最耗时的。如果引擎能在一次 I/O 读取中（16KB，一页）把所有的目录项都读上来，那么二分查找，平衡树查找，B树查找等等 都是差不多的。那如果目录远远超过超过16KB呢？各种查找算法所需的 I/O 次数就会远不相同。所以我们可以很快地排除二分查找。而对于树结构，我们希望树的高度越小越好，越小的高度所需的 I/O 操作越少，B树是最合适的。而InnoDB采用B+树，其实也是B树的一个变种，只不过B+树的内节点不存储数据，只做索引，所有的数据都存储在叶子节点。B+树更适合做磁盘索引，性能优于B树。（关于为什么MySQL为什么选择B+树做索引，这是一个很大的话题，后续再仔细做一下补充。B站有一个视频讲得挺好： https://www.bilibili.com/video/BV1kr4y1T7Zx/?share_source=copy_web&amp;vd_source=5b5f35446e77e54d0ddbdaf99f8d5c9b） 如果当目录项超过一页大小（16KB）, 则会再创建一页出来存储，并且会新增一个父节点，父节点的索引范围更大。这样便形成了一颗索引B+树。索引页的组织结构与数据页类似，有以下特点： 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内的记录是按照主键的大小顺序排成一个单向链表。 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。 B+ 树的叶子节点存储的是完整的用户记录。 2 InnoDB 二级索引 回到开头提到的第二个问题，如果我们要查找的语句不能走原来的索引，怎么办？更具体的说，如果我们一开始建表的时候是以C1这一列作为索引的，而现在需要找 满足C2=X 这个条件的所有条目怎么办？如果你没做任何优化的话，那么数据库也只能一条一条地遍历去找，效率感人。但是我们可以再创建一个 C2 列的索引啊，查找的时候走C2列索引就好了！ 那么现在的问题是，现在数据库中的所有页都是按照之前的 键 排序的，我创建新的索引不能破坏原来的页排列吧，难道我要把所有数据拷贝一份从头到尾重新排列？这成本也太高了吧。其实没必要，我们只需要创建一份能从 C2 映射到 C1 的索引表，再用C1的键进行一次查找即可。这个过程叫做 回表。因为这种按照 非主键列 建立的 B+ 树也被称为 二级索引 （英文名 secondary index ）或者 辅助索引 。 这个 B+ 树与之前的聚簇索引有几处不同： B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。 目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配。 3 InnoDB 联合索引 即联合多列作为索引的 键。其特点为： 每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列排序，再按照 c3 列排序。 B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。 需要注意的是，查询利用联合索引时，不要违背最左前缀原则，否则走不了索引。 4 InnoDB 单表索引具体方式 总体来说，单表的查询方式分为两种，一种是全表扫描，一种使用索引进行查询。而使用索引进行查询又可以进行细分，如： 针对主键或唯一二级索引的等值查询 针对普通二级索引的等值查询 针对索引列的范围查询 直接扫描整个索引 4.1 前置 123456789101112131415CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3)) Engine=InnoDB CHARSET=utf8; 4.2 const 方式 通过主键或者唯一二级索引列与常数的等值比较来定位的方式叫 const . 由于其索引很快，代价几乎忽略不计，因此命名 const. 1SELECT * FROM single_table WHERE key2 = 3841; 4.3 ref 方式 由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，比如一条就是 const 的方式。这种普通的二级索引称为 ref. 1SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27;; 这种 ref 访问方法比 const 差了一点点，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的。 4.4 ref_or_null 方式 当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为 ref_or_null. 1SELECT * FROM single_demo WHERE key1 = &#x27;abc&#x27; OR key1 IS NULL; 4.5 range 方式 索引列需要匹配某个或某些范围的值，在本查询中 key2 列的值只要匹配下列3个范围中的任何一个就算是匹配成功。 1SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79); 4.6 index 方式 遍历二级索引记录的方式叫 index. 如下： 1SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &#x27;abc&#x27;; 我们可以直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = ‘abc’ 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多，而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多。 4.7 all 方式 直接全表扫描。 《MySQL是怎样运行的：从根儿上理解MySQL》","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xie-peiquan.gitee.io/tags/MySQL/"}]},{"title":"7-MySQL-连接","slug":"数据库/7-MySQL-连接","date":"2024-03-19T07:17:53.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2024/03/19/数据库/7-MySQL-连接/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/7-MySQL-%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"1 MySQL中的连接 1.1 交叉连接 将 A 表的每一个条目与 B 表的每一个条目都交叉一遍，这样的结果集也称为 笛卡尔积 。交叉连接出来的表很大，这种连接方式要慎用。 1SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;; MySQL是怎么执行以上语句的呢？过程如下： 首先确定第一个需要查询的表，这个表称为 驱动表 。此处假设使用 t1 作为驱动表，那么就需要到 t1 表中找满足 t1.m1 &gt; 1 的记录。 针对上一步从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被称之为 被驱动表 。匹配的过程，是分别具体化 t1.m1 = t2.m2 AND t2.n2 &lt; 'd' 这个条件进行查询的。 1.2 内连接和外连接 以上的交叉连接加条件过滤的方式，很容易找到多个表的交集。但是有时候，我们想要 驱动表中的记录即使在被驱动表中没有匹配的记 **录，也仍然需要加入到结果集。**为了解决这个问题，就有了 内连接 和 外连接 的概念： 对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。 对于 外连接 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种： 左外连接：选取左侧的表为驱动表。 右外连接：选取右侧的表为驱动表。 1.3 ON 语句 ON语句用于指定内外连接的连接条件。需要注意的是：① 对于外连接来说，如果无法在被驱动表中找到匹配 ON 子句中的条件，那么该记录仍然会被加入到结果集中，缺失值使用 NULL 填充。 ② 对于内连接来说，WHERE子句和ON子句是等价的。 一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中。 123456# 左连接语句SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];# 右连接语句SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];# 内连接语句SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件]; 2 连接的原理 2.1 嵌套循环连接 对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。t1 表和 t2 表执行内连接查询的大致过程如下： 步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。 步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。 这个过程就像是一个嵌套的循环，这是最简单，也是最笨拙的一种连接查询算法。 2.2 使用索引加快连接速度 如果访问 被驱动表 的方式都是全表扫描的话，那么要对 被驱动表 做好多次全表扫描，时间爆炸。如果我们可以对 被驱动表 采用索引的方式来查询，那么效率就会大大增加。 2.3 基于块的嵌套循环连接 如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大。MySQL 提出了一个 join buffer 的概念， join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。 《MySQL是怎样运行的：从根儿上理解MySQL》","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xie-peiquan.gitee.io/tags/MySQL/"}]},{"title":"6-MySQL-B+树","slug":"数据库/6-MySQL-B+树","date":"2024-03-19T07:17:44.000Z","updated":"2025-05-14T02:14:15.364Z","comments":true,"path":"2024/03/19/数据库/6-MySQL-B+树/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/6-MySQL-B+%E6%A0%91/","excerpt":"","text":"1 索引的代价 空间上的代价：每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间。 时间上的代价：每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。 2 B+树索引场景 这里先创建一个表作为以下说明的例子。其中 id 是主键，而 idx_name_birthday_phone_number 是二级索引。 123456789CREATE TABLE person_info( id INT NOT NULL auto_increment, name VARCHAR(100) NOT NULL, birthday DATE NOT NULL, phone_number CHAR(11) NOT NULL, country varchar(100) NOT NULL, PRIMARY KEY (id), KEY idx_name_birthday_phone_number (name, birthday, phone_number)); 2.1 全值匹配 如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。比如： 12SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27;; 如果我们调换 name 、 birthday 、 phone_number 这几个搜索列的顺序对查询的执行过程有影响么？还能走索引吗？事实上没影响。 MySQL 会帮我们优化，它会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。 2.2 最左前缀匹配 如果我们匹配联合索引的最左前几列，是可以走索引的，匹配结果可能是多个条目。但如果我们跳过左边的某一列，那么会导致查询无法走索引。为啥？比如： 1SELECT * FROM person_info WHERE birthday = &#x27;1990-09-27&#x27;; B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。而现在你跳过name 列直接根据 birthday 的值去查找，MySQL 做不到呀。 所以我们查询的时候在条件语句中尽量不要漏掉最左边的某一列，即 最左前缀匹配原则。 2.3 匹配列前缀 观察以下两条查询语句，有没有发现在查询过程中有什么不同？ 12SELECT * FROM person_info WHERE name LIKE &#x27;As%&#x27;;SELECT * FROM person_info WHERE name LIKE &#x27;%As%&#x27;; 答案是，第一条能走索引，第二条不能走索引。为啥？因为以As开头的数据条目在数据库中已经排好序了，而以As作为中间子串的数据条目并没有排好序，存储引擎只能做全表扫描比对。好烦，那我有时候需要匹配后缀，也只能全表扫描吗？对于匹配后缀，有一个优化思路，就是让该列的字符串全部逆序存储，这样我们就可以转后缀匹配为前缀匹配了。 不知到这里你有没有发现规律，分析一条查询语句到底能不能走索引，只需要分析这条语句能不能利用数据库中已经排好序的B+树。 2.4 匹配范围值 B+树所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引，比如： 1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; AND birthday &gt; &#x27;1980-01-01&#x27;; 这里只有 name 范围查找可以用上索引，birthday 列不能，想想为什么？问就是无序。 2.5 精确匹配某一列并范围匹配另外一列 对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精 确查找，则右边的列可以进行范围查找，比如： 1SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday &gt; &#x27;1980-01-01&#x27; AND birthday &lt; &#x27;2000-12-31&#x27; AND phone_number &gt; &#x27;15100000000&#x27;; 这里的 birthday 范围查找是可以用上索引的，为什么？问就是有序。 2.6 用于排序 如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如： 1SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10; 由于SQL语句要求的排序与数据库存储中的顺序一致，所以直接从索引中提取数据就好了。 3 回表的代价 由于我们创建的索引 idx_name_birthday_phone_number 是个二级索引，索引查完这颗B+树后获得的是真正的主键值 id，索引需要再拿这个id去找一遍，这个过程叫 回表。 回表的代价在范围查找里面体现的尤为明显。比如这条语句： 1SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;; 由于索引 idx_name_birthday_phone_number 对应的 B+ 树中的记录首先会按照 name 列的值进行排序，所以值在 Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 顺序I/O 。以上过程取到的记录的 id 字段的值可能并不相连，而在聚簇索引中记录是根据 id （也就是主键）的顺序排列的，所以根据这些并不连续的 id 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为 随机I/O 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。 需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用 二级索引 。比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用 idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去扫描全表。 事实上，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索引 + 回表 的方式。 3.1 覆盖索引 为了彻底告别 回表 操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如： 1SELECT name, birthday, phone_number FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; 这样在二级索引的时候，就已经能够得到我们所关心的值了，不用回表查找更多列数据。 4 如何选择索引 只为用于搜索、排序或分组的列创建索引。 为基数大的列建立索引。在记录行数一定的情况下，列的基数越大，该列中的值越分散；基数越小，该列中的值越集中。对于值集中的列，其使用二级索引查出的条目可能很多，这样去回表很耗性能。 索引列的类型尽量小。比如整形，能用小的整数类型就用小的，可以节省更多的存储空间和更高效的 I/O 。 索引字符串值的前缀。如果对某一列长字符串创建索引，会很耗空间和性能。所以我们在创建索引的时候，可以取字符串的前几个字符来创建索引就好，这样可以大致获取到长字符串的位置，再回表去精确查找。 1234567CREATE TABLE person_info( name VARCHAR(100) NOT NULL, birthday DATE NOT NULL, phone_number CHAR(11) NOT NULL, country varchar(100) NOT NULL, KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)); 让主键自增。如果主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插；而如果插入的主键值忽大忽小，这就比较麻烦了，可能需要把当前已经插满页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着：性能损耗！ 所以一般建议：让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入 。 《MySQL是怎样运行的：从根儿上理解MySQL》","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xie-peiquan.gitee.io/tags/MySQL/"}]},{"title":"2-SQLite中间件","slug":"数据库/2-SQLite中间件","date":"2024-03-15T09:43:29.000Z","updated":"2025-05-14T02:14:15.364Z","comments":true,"path":"2024/03/15/数据库/2-SQLite中间件/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/2-SQLite%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"SQLite 提供的 C/CPP API 实在是太简陋，使用C++开发的伙伴一定会感到极为不方便。事实上有很多用C++包装的中间件，可以极大方便我们操作数据库。这里我整理了 sqlite_modern_cpp 的使用方法，相比于一些 orm 中间件，它简单而纯粹。如果对 orm 感兴趣的话，也可以看一下 sqlite_orm 这份代码。这两份代码都是 header_only的，部署起来十分简单。 开发环境 12apt install sqlite3apt install libsqlite3-dev 基本操作 包含头文件 1234#include &lt;iostream&gt;#include &quot;sqlite_modern_cpp.h&quot;using namespace sqlite;using namespace std; 连接数据库 1234567// creates a database file &#x27;dbfile.db&#x27; if it does not exists.database db(&quot;dbfile.db&quot;);//带上参数设置sqlite_config config;config.flags = OpenFlags::READONLYdatabase db(&quot;some_db&quot;, config); 创建表 12345678// executes the query and creates a &#x27;user&#x27; table db &lt;&lt; &quot;create table if not exists user (&quot; &quot; _id integer primary key autoincrement not null,&quot; &quot; age int,&quot; &quot; name text,&quot; &quot; weight real&quot; &quot;);&quot;; 增 123456789101112// inserts a new user record.// binds the fields to &#x27;?&#x27; .// note that only types allowed for bindings are :// int ,long, long long, float, double// string, u16string// sqlite3 only supports utf8 and utf16 strings, you should use std::string for utf8 and std::u16string for utf16.// If you&#x27;re using C++17, `std::string_view` and `std::u16string_view` can be used as string types.// note that u&quot;my text&quot; is a utf16 string literal of type char16_t * .db &lt;&lt; &quot;insert into user (age,name,weight) values (?,?,?);&quot; &lt;&lt; 20 &lt;&lt; &quot;bob&quot; &lt;&lt; 83.25; 查 返回多个条目 其中 db &lt;&lt; &quot;select age,name,weight from user where age &gt; ? ;&quot; &lt;&lt; 18; 的输出结果是一个临时的 sqlite::database_binder 对象。 123456789101112auto &amp;&amp; infer = db &lt;&lt; &quot;select age,name,weight from user where age &gt; ? ;&quot; &lt;&lt; 18;for(auto &amp;row : infer) &#123; int age; string name; double weight; row &gt;&gt; age &gt;&gt; name &gt;&gt; weight; cout &lt;&lt; age &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &#x27; &#x27; &lt;&lt; weight &lt;&lt; endl;&#125;//或者是以下使用lambda函数db &lt;&lt; &quot;select age,name,weight from user where age &gt; ? ;&quot; &lt;&lt; 18 &gt;&gt; [&amp;](int age, string name, double weight) &#123; cout &lt;&lt; age &lt;&lt; &#x27; &#x27; &lt;&lt; name &lt;&lt; &#x27; &#x27; &lt;&lt; weight &lt;&lt; endl; &#125;; 返回单个条目 1234567891011121314// selects the count(*) from user table// note that you can extract a single column single row result only to : int,long,long,long,float,double,string,u16stringint count = 0;db &lt;&lt; &quot;select count(*) from user&quot; &gt;&gt; count;cout &lt;&lt; &quot;cout : &quot; &lt;&lt; count &lt;&lt; endl;// you can also extract multiple column rowsdb &lt;&lt; &quot;select age, name from user where _id=1;&quot; &gt;&gt; tie(age, name);cout &lt;&lt; &quot;Age = &quot; &lt;&lt; age &lt;&lt; &quot;, name = &quot; &lt;&lt; name &lt;&lt; endl;// this also works and the returned value will be automatically converted to stringstring str_count;db &lt;&lt; &quot;select count(*) from user&quot; &gt;&gt; str_count;cout &lt;&lt; &quot;scount : &quot; &lt;&lt; str_count &lt;&lt; endl; 改 1db &lt;&lt; &quot;update user set age = ? where age = ?;&quot; &lt;&lt; 22 &lt;&lt; 20; 删 1db &lt;&lt; &quot;delete from user where age = ?;&quot; &lt;&lt; 20; 事务操作 1234567891011121314151617db &lt;&lt; &quot;begin;&quot;; // begin a transaction ... db &lt;&lt; &quot;insert into user (age,name,weight) values (?,?,?);&quot; &lt;&lt; 20 &lt;&lt; u&quot;bob&quot; &lt;&lt; 83.25f;db &lt;&lt; &quot;insert into user (age,name,weight) values (?,?,?);&quot; // utf16 string &lt;&lt; 21 &lt;&lt; u&quot;jack&quot; &lt;&lt; 68.5;db &lt;&lt; &quot;commit;&quot;; // commit all the changes.db &lt;&lt; &quot;begin;&quot;; // begin another transaction ....db &lt;&lt; &quot;insert into user (age,name,weight) values (?,?,?);&quot; // utf16 string &lt;&lt; 19 &lt;&lt; u&quot;chirs&quot; &lt;&lt; 82.7;db &lt;&lt; &quot;rollback;&quot;; // cancel this transaction ... 有没有发现，这个中间件保留了原始的 SQL 语句，同时它让数据的存取变得简单，简单而灵活！其他更多的操作照搬 SQLite3 的语句就可以了，请参考 1-SQLite语法一页纸 ，这里不再赘述。 捕获异常 1234catch (const sqlite_exception&amp; e) &#123; cerr &lt;&lt; e.get_code() &lt;&lt; &quot;: &quot; &lt;&lt; e.what() &lt;&lt; &quot; during &quot; &lt;&lt; e.get_sql() &lt;&lt; endl;&#125; 其中，sqlite返回的错误码可通过 e.get_code() 获取，标准错误码可在 sqlite.h 中查看： 123456789101112131415161718192021222324252627282930313233#define SQLITE_OK 0 /* Successful result *//* beginning-of-error-codes */#define SQLITE_ERROR 1 /* Generic error */#define SQLITE_INTERNAL 2 /* Internal logic error in SQLite */#define SQLITE_PERM 3 /* Access permission denied */#define SQLITE_ABORT 4 /* Callback routine requested an abort */#define SQLITE_BUSY 5 /* The database file is locked */#define SQLITE_LOCKED 6 /* A table in the database is locked */#define SQLITE_NOMEM 7 /* A malloc() failed */#define SQLITE_READONLY 8 /* Attempt to write a readonly database */#define SQLITE_INTERRUPT 9 /* Operation terminated by sqlite3_interrupt()*/#define SQLITE_IOERR 10 /* Some kind of disk I/O error occurred */#define SQLITE_CORRUPT 11 /* The database disk image is malformed */#define SQLITE_NOTFOUND 12 /* Unknown opcode in sqlite3_file_control() */#define SQLITE_FULL 13 /* Insertion failed because database is full */#define SQLITE_CANTOPEN 14 /* Unable to open the database file */#define SQLITE_PROTOCOL 15 /* Database lock protocol error */#define SQLITE_EMPTY 16 /* Internal use only */#define SQLITE_SCHEMA 17 /* The database schema changed */#define SQLITE_TOOBIG 18 /* String or BLOB exceeds size limit */#define SQLITE_CONSTRAINT 19 /* Abort due to constraint violation */#define SQLITE_MISMATCH 20 /* Data type mismatch */#define SQLITE_MISUSE 21 /* Library used incorrectly */#define SQLITE_NOLFS 22 /* Uses OS features not supported on host */#define SQLITE_AUTH 23 /* Authorization denied */#define SQLITE_FORMAT 24 /* Not used */#define SQLITE_RANGE 25 /* 2nd parameter to sqlite3_bind out of range */#define SQLITE_NOTADB 26 /* File opened that is not a database file */#define SQLITE_NOTICE 27 /* Notifications from sqlite3_log() */#define SQLITE_WARNING 28 /* Warnings from sqlite3_log() */#define SQLITE_ROW 100 /* sqlite3_step() has another row ready */#define SQLITE_DONE 101 /* sqlite3_step() has finished executing *//* end-of-error-codes */ https://github.com/SqliteModernCpp/sqlite_modern_cpp","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://xie-peiquan.gitee.io/tags/SQLite/"}]},{"title":"4-Cmake一页纸","slug":"C++那些事/4-cmake一页纸","date":"2024-02-27T08:58:27.000Z","updated":"2025-05-14T02:14:15.244Z","comments":true,"path":"2024/02/27/C++那些事/4-cmake一页纸/","link":"","permalink":"https://xie-peiquan.gitee.io/2024/02/27/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/4-cmake%E4%B8%80%E9%A1%B5%E7%BA%B8/","excerpt":"","text":"1 基本设置 Cmake版本控制 12345cmake_minimum_required(VERSION 3.16) # 最低版本要求if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.21) # 设置cmake特性，非必需 cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;)endif() project信息设置 1234project(ProjectName VERSION 1.0 # 非必需 DESCRIPTION &quot;Very nice project&quot; # 非必需 LANGUAGES CXX) # 非必需，默认为C CXX 生成目标文件 1234# 生成库文件add_library(libA STATIC libA.cpp libA.h) # STATIC(静态库), SHARED(动态库)# 生成可执行文件add_executable(main testA.cpp testA.h) # 依赖文件顺序，基础的放前面 向target添加信息 12target_include_directories(main ./include) # 向目标添加头文件路径target_link_libraries(main libA) # 向目标链接库文件 设置target输出路径 1set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;) 设置安装路径 123install(TARGETS A_lib DESTINATION ./install/lib) # 安装库文件file(GLOB HEADERS &quot;*.h&quot;)install(FILES $&#123;HEADERS&#125; DESTINATION ./install/include) # 安装头文件 一般 install 不会立刻执行，当执行 make install 时，会将目标移动至指定路径下。 简单示例 123456789cmake_minimum_required(VERSION 3.16)project(Calculator LANGUAGES CXX)add_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp)target_include_directories(calclib include)target_compile_features(calclib cxx_std_11)add_executable(calc apps/calc.cpp)target_link_libraries(calc calclib) 2 变量与属性 设置局部变量 12set(MY_VARIABLE &quot;value&quot;) # 单值set(MY_LIST &quot;one&quot; &quot;two&quot;) # 列表 该变量作用域只在本CmakeList文件中，通过 $&#123;MY_VARIABLE&#125; 来取变量值。注：在变量不含空格时，加不加引号是等效的。 1aux_source_directory(./src/common COMMON_SRC_LIST) 该命令可自动搜索 ./src/common 路径下的所有可编译源文件，并写入 COMMON_SRC_LIST 变量中，可节省手动添加需编译源文件的麻烦。不过，当源文件编译顺序有讲究时，建议手动添加。 设置环境变量 12set(ENV&#123;variable_name&#125; value) # set$ENV&#123;variable_name&#125; # get 设置全局属性 123set(CMAKE_CXX_COMPILER &quot;arm-linux-gnueabihf-g++&quot;)set(CMAKE_CXX_STANDARD 17)set(CMAKE_BUILD_TYPE debug) 全局属性以 CMAKE_ 作为前缀，其作用域是全局的。例如你设置 CMAKE_CXX_STANDARD 这个变量，这意味着你之后创建的所有目标的 CXX_STANDARD 都将被设为 CMAKE_CXX_STANDARD 变量的值。 设置局部属性 123set_target_properties(TargetName PROPERTIES CXX_STANDARD 17) # set# set_property(TARGET TargetName PROPERTY CXX_STANDARD 17)get_property(ResultVariable TARGET TargetName PROPERTY CXX_STANDARD) # get 3 Cmake控制流 if-else 123456if(variable)# if(&quot;$&#123;variable&#125;&quot;) # True if variable is not false-likeelse() # Note that undefined variables would be `&quot;&quot;` thus falseendif() 注：if 会将 variable 展开，无需用 $&#123;&#125; 取值。if 不会对 &quot;$&#123;variable&#125;&quot; 再次展开。 生成器表达式 最简单的生成器表达式是信息表达式，其形式为 $&lt;KEYWORD&gt;；它会评估和当前配置相关的一系列信息。信息表达式的另一个形式是 $&lt;KEYWORD:value&gt;，其中 KEYWORD 是一个控制评估的关键字，而 value 则是被评估的对象。如果 KEYWORD被评估 为1 则 value 会在这里被保留下来，而反之则不会。例如： 123456target_include_directories( MyTarget PUBLIC $&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include&gt; $&lt;INSTALL_INTERFACE:include&gt;) 宏定义与函数 12345function(fun arg1) message(&quot;Simple arguments: $&#123;arg1&#125;, followed by $&#123;ARGN&#125;&quot;)endfunction()fun(hello world boy) 123456macro(my_macro arg1 arg2) message(&quot;Argument 1: $&#123;arg1&#125;&quot;) message(&quot;Argument 2: $&#123;arg2&#125;&quot;)endmacro()my_macro(Hello World) **函数和宏只有作用域上存在区别，宏没有作用域的限制。**如果 宏/函数 需要一个指定的参数，你应该在列表中明确的列出，除此之外的所有参数都会被存储在 ARGN 这个变量中。 4 Cmake与代码交互 代码从cmake获取信息 以获取版本号为例，CMake 允许你在代码中使用 configure_file 来访问 CMake 变量。该命令将一个文件（ 一般以 .in 结尾 ）的内容复制到另一个文件中，并替换其中它找到的所有 CMake 变量。 Version.h.in 1234567#pragma once#define MY_VERSION_MAJOR @PROJECT_VERSION_MAJOR@#define MY_VERSION_MINOR @PROJECT_VERSION_MINOR@#define MY_VERSION_PATCH @PROJECT_VERSION_PATCH@#define MY_VERSION_TWEAK @PROJECT_VERSION_TWEAK@#define MY_VERSION &quot;@PROJECT_VERSION@&quot; CMake lines 1234configure_file ( &quot;$&#123;PROJECT_SOURCE_DIR&#125;/include/My/Version.h.in&quot; &quot;$&#123;PROJECT_BINARY_DIR&#125;/include/My/Version.h&quot;) Cmake从代码读取信息 以版本号为例，Cmake可从源文件匹配出第三方库的版本信息。 12345678910111213# Assuming the canonical version is listed in a single line# This would be in several parts if picking up from MAJOR, MINOR, etc.set(VERSION_REGEX &quot;#define MY_VERSION[ \\t]+\\&quot;(.+)\\&quot;&quot;)# Read in the line containing the versionfile(STRINGS &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/My/Version.hpp&quot; VERSION_STRING REGEX $&#123;VERSION_REGEX&#125;)# Pick out just the versionstring(REGEX REPLACE $&#123;VERSION_REGEX&#125; &quot;\\\\1&quot; VERSION_STRING &quot;$&#123;VERSION_STRING&#125;&quot;)# Automatically getting PROJECT_VERSION_MAJOR, My_VERSION_MAJOR, etc.project(My LANGUAGES CXX VERSION $&#123;VERSION_STRING&#125;)","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"CMake","slug":"CMake","permalink":"https://xie-peiquan.gitee.io/tags/CMake/"}]},{"title":"10-让pthread更好用","slug":"并发编程基础/10.让pthread更好用","date":"2023-12-28T12:31:03.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2023/12/28/并发编程基础/10.让pthread更好用/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/10.%E8%AE%A9pthread%E6%9B%B4%E5%A5%BD%E7%94%A8/","excerpt":"","text":"事实上std::thread正是从pthread中继承发展而来的，你可以发现他们的用法几乎一致。由于一些历史原因，可能我们还是得用到pthread线程库。但pthread 有一些用法不太灵活，我们可以稍微对他进行包装，让它更好用。 123456789101112131415161718192021222324252627282930313233#include &lt;pthread.h&gt;#include &lt;functional&gt;#include &lt;iostream&gt;class x_thread &#123;public: typedef std::function&lt;void()&gt; ThreadFunc; explicit x_thread(ThreadFunc func)&#123; _thread_func = func; &#125; ~x_thread()&#123;&#125; void start()&#123; pthread_create(&amp;_thread_id,NULL,&amp;x_thread::run,this); &#125; void join()&#123; pthread_join(_thread_id,nullptr); &#125; void detach()&#123; pthread_detach(_thread_id); &#125;private: static void* run(void* arg)&#123; x_thread* xthread = static_cast&lt;x_thread*&gt;(arg); xthread-&gt;_thread_func(); return nullptr; &#125; private: ThreadFunc _thread_func; pthread_t _thread_id;&#125;; 新增功能： 2023/12/25：让 pthread 支持接收函数对象。 应用示例： 1234567891011121314151617181920212223#include &lt;unistd.h&gt;#include &lt;functional&gt;#include &lt;iostream&gt;class Foo&#123;public: void memfunc(double d,int i,int j)&#123; std::cout&lt;&lt;d&lt;&lt;std::endl; std::cout&lt;&lt;i&lt;&lt;std::endl; std::cout&lt;&lt;j&lt;&lt;std::endl; &#125;&#125;;int main()&#123; Foo foo; //支持回调成员函数 x_thread t1(std::bind(&amp;Foo::memfunc, &amp;foo,0.5, 4, 100)); t1.start(); t1.join(); std::cout&lt;&lt;&quot;program over.&quot;&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"8-多线程消息传递","slug":"并发编程基础/8-多线程消息传递","date":"2023-12-28T07:31:56.000Z","updated":"2025-05-14T02:14:15.356Z","comments":true,"path":"2023/12/28/并发编程基础/8-多线程消息传递/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/","excerpt":"","text":"1 简单阻塞消息队列 12345678910111213141516171819202122232425262728#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;memory&gt;template&lt;typename T&gt;class msgQueue&#123;public: void push(T const&amp; msg) &#123; std::lock_guard&lt;std::mutex&gt; lk(m); q.push(msg); c.notify_all(); &#125; T wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lk(m); c.wait(lk,[&amp;]&#123;return !q.empty();&#125;); //阻塞等待队列有消息 T res = q.front(); q.pop(); return res; &#125;private: std::mutex m; std::condition_variable c; std::queue&lt;T&gt; q; &#125;; 2 简单阻塞广义队列 相信用过python的同学都对python的容器爱不释手，其实c++稍加处理也可以实现像python那样的广义容器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;memory&gt;namespace messaging&#123; struct message_base ⇽--- ①消息基类。队列中存储的项目 &#123; virtual ~message_base()&#123;&#125; &#125;; template&lt;typename Msg&gt; struct wrapped_message: ⇽--- ②对具体消息的包装 message_base &#123; Msg contents; explicit wrapped_message(Msg const&amp; contents_): contents(contents_)&#123;&#125; &#125;; class msgQueue &#123; public: template&lt;typename T&gt; void push(T const&amp; msg) &#123; std::lock_guard&lt;std::mutex&gt; lk(m); q.push(std::make_shared&lt;wrapped_message&lt;T&gt; &gt;(msg)); ⇽--- ⑤包装发布的消息，并存储相关的指针 c.notify_all(); &#125; std::shared_ptr&lt;message_base&gt; wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lk(m); c.wait(lk,[&amp;]&#123;return !q.empty();&#125;); ⇽--- ⑥如果队列为空，就发生阻塞 auto res=q.front(); q.pop(); return res; &#125; private: std::mutex m; std::condition_variable c; std::queue&lt;std::shared_ptr&lt;message_base&gt; &gt; q; &#125;;&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"7-设计并发代码","slug":"并发编程基础/7-设计并发代码","date":"2023-12-28T04:01:46.000Z","updated":"2025-05-14T02:14:15.356Z","comments":true,"path":"2023/12/28/并发编程基础/7-设计并发代码/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/7-%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%8F%91%E4%BB%A3%E7%A0%81/","excerpt":"","text":"设计并发代码时需考虑两个层面：线程安全 和 并发性能。 1 线程划分 1.1 数据简单切分 考虑将将一片较大的数据切分为若干块给各线程执行，最后按串行的方式执行规约操作。简单例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename Iterator,typename T&gt;struct accumulate_block&#123; void operator()(Iterator first,Iterator last,T&amp; result) &#123; result=std::accumulate(first,last,result); &#125;&#125;;template&lt;typename Iterator,typename T&gt;T parallel_accumulate(Iterator first,Iterator last,T init)&#123; unsigned long const length=std::distance(first,last); if(!length) return init; ⇽--- ① unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; ⇽--- ② unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= std::min(hardware_threads!=0?hardware_threads:2,max_threads); ⇽--- ③ unsigned long const block_size=length/num_threads; ⇽--- ④ std::vector&lt;T&gt; results(num_threads); std::vector&lt;std::thread&gt; threads(num_threads-1); ⇽--- ⑤ Iterator block_start=first; for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; Iterator block_end=block_start; std::advance(block_end,block_size); ⇽--- ⑥ threads[i]=std::thread( ⇽--- ⑦ accumulate_block&lt;Iterator,T&gt;(), block_start,block_end,std::ref(results[i])); block_start=block_end; ⇽--- ⑧ &#125; accumulate_block&lt;Iterator,T&gt;()( block_start,last,results[num_threads-1]); ⇽--- ⑨ for(auto&amp; entry: threads) entry.join(); ⇽--- ⑩ return std::accumulate(results.begin(),results.end(),init); ⇽--- ⑪&#125; 1.2 数据递归划分 以快排算法为例，数据无法一开始就划分好，因为只有经过处理后，才会清楚它会归入到哪个部分。并行化这个算法需要利用递归来进行划分。 1234567891011121314151617181920212223template&lt;typename T&gt;std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input)&#123; if(input.empty()) &#123; return input; &#125; std::list&lt;T&gt; result; result.splice(result.begin(),input,input.begin()); T const&amp; pivot=*result.begin(); auto divide_point=std::partition(input.begin(),input.end(), [&amp;](T const&amp; t)&#123;return t&lt;pivot;&#125;); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end(),input,input.begin(), divide_point); std::future&lt;std::list&lt;T&gt;&gt; new_lower( ⇽--- ① std::async(&amp;parallel_quick_sort&lt;T&gt;,std::move(lower_part))); auto new_higher( parallel_quick_sort(std::move(input))); ⇽--- ② result.splice(result.end(),new_higher); ⇽--- ③ result.splice(result.begin(),new_lower.get()); ⇽--- ④ return result;&#125; 以上代码随着每一层递归的深入，都借助std::async()生成新的异步任务处理前半部分数据，这样可以让左右两部分的数据并行排序起来。这里用到std::async()其实是让C++线程库自主决定，是否新起线程来运行新数据。快排不可能让所有的数据块排序并行起来，因为太多的线程反而让程序变慢，且消耗资源。 1.3 任务切分 将串行的任务切块，让块并行，块与块之间通过队列等管道传输数据。即流水线模式。 2 影响并发性能的因素 2.1 处理器数量 处理器数量可谓是首要且关键的因素。当需同时运行的线程超过处理器实际能并行的线程数，各线程就会发生切换，导致浪费处理器时间，此称为线程过饱和。C++标准库提供了std::thread::hardware_concurrency()来查询硬件能并行的线程数，应用程序可以依此缩放实际执行任务的线程数量。 2.2 数据竞争&amp;缓存乒乓 如果两个线程在不同的处理器上并行并共享数据，数据实际上会复制到两个处理器上的缓存中。如果其中一个线程改动了数据，变化必须传导至另一个处理器的缓存中，这之间可能导致另一个处理器半途暂停，以等待硬件变化。可怕的是，这种处理器暂停会让其他无关的线程也随着暂停。以以下代码为例： 12345678std::atomic&lt;unsigned long&gt; counter(0);void processing_loop()&#123; while(counter.fetch_add(1,std::memory_order_relaxed)&lt;100000000) &#123; do_something(); &#125;&#125; 当处理器执行原子变量的自增操作时，必须先确保自身缓存载入了变量的最新副本，然后再改变它的值，再通知其他处理器。这样，当do_something()函数足够短时，大量线程会阻塞在原子变量的更改处，且处理器缓存会发生多次的同步。由于原子变量的值在不同处理器缓存之间多次来回传递，因此称缓存乒乓。 互斥锁同样也会导致缓存乒乓，但其与原子争夺稍有不同。因为互斥锁是在操作系统层面的，不直接插手到处理器层面。 2.3 不经意共享 你以为所有线程不共享数据就不会产生缓存乒乓的问题吗？NO! (好难啊)。 缓存是一块一块读取的，也就是说，当你读取自己线程所属的数据，有可能不经意把别人的数据也读取进来，这个时候相当于不经意共享。这里的解决方法是编排数据布局，不同线程的数据在内存中彼此隔离，减少不经意共享。 2.4 线程过饱和 若线程数目过多，超过硬件可并行数，操作系统也会随之开始剧烈地切换任务，以公平分摊时间片。若数据分布不够紧凑，还会导致缓存问题，这两个问题叠加会导致严重后果。 3 线程异常保护 当不对并发线程的异常进行处理，线程对象会通过析构函数调用std::terminate() 从而终结整个应用程序。 以下提供并行代码进行分析： 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename Iterator,typename T&gt;struct accumulate_block&#123; void operator()(Iterator first,Iterator last,T&amp; result) &#123; result=std::accumulate(first,last,result); ⇽--- ① &#125;&#125;;template&lt;typename Iterator,typename T&gt;T parallel_accumulate(Iterator first,Iterator last,T init)&#123; unsigned long const length=std::distance(first,last); ⇽--- ② if(!length) return init; unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= std::min(hardware_threads!=0?hardware_threads:2,max_threads); unsigned long const block_size=length/num_threads; std::vector&lt;T&gt; results(num_threads); ⇽--- ③ std::vector&lt;std::thread&gt; threads(num_threads-1); ⇽--- ④ Iterator block_start=first; ⇽--- ⑤ for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; Iterator block_end=block_start; ⇽--- ⑥ std::advance(block_end,block_size); threads[i]=std::thread( ⇽--- ⑦ accumulate_block&lt;Iterator,T&gt;(), block_start,block_end,std::ref(results[i])); block_start=block_end; ⇽--- ⑧ &#125; accumulate_block&lt;Iterator,T&gt;()( block_start,last,results[num_threads-1]); ⇽--- ⑨ std::for_each(threads.begin(),threads.end(), std::mem_fn(&amp;std::thread::join)); return std::accumulate(results.begin(),results.end(),init); ⇽--- ⑩&#125; 以上，新线程发起的 accumulate_block 块，此处没有任何的catch块，故代码不会处理产生的异常，结果令线程库调用 std::terminate()而终止整个应用程序。 3.1 加入异常安全 以上代码，我们希望新起线程能抛出异常，并被父线程所捕获。我们借助 std::packaged_task 和 std::future 即可实现。以下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template&lt;typename Iterator,typename T&gt;struct accumulate_block&#123; T operator()(Iterator first,Iterator last) ⇽--- ① &#123; return std::accumulate(first,last,T()); ⇽--- ② &#125;&#125;;template&lt;typename Iterator,typename T&gt;T parallel_accumulate(Iterator first,Iterator last,T init)&#123; unsigned long const length=std::distance(first,last); if(!length) return init; unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= std::min(hardware_threads!=0?hardware_threads:2,max_threads); unsigned long const block_size=length/num_threads; std::vector&lt;std::future&lt;T&gt; &gt; futures(num_threads-1); ⇽--- ③ std::vector&lt;std::thread&gt; threads(num_threads-1); Iterator block_start=first; for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; Iterator block_end=block_start; std::advance(block_end,block_size); std::packaged_task&lt;T(Iterator,Iterator)&gt; task( ⇽--- ④ accumulate_block&lt;Iterator,T&gt;()); futures[i]=task.get_future(); ⇽--- ⑤ threads[i]=std::thread(std::move(task),block_start,block_end); ⇽--- ⑥ block_start=block_end; &#125; T last_result=accumulate_block&lt;Iterator,T&gt;()(block_start,last); ⇽--- ⑦ std::for_each(threads.begin(),threads.end(), std::mem_fn(&amp;std::thread::join)); T result=init; ⇽--- ⑧ for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; result+=futures[i].get(); ⇽--- ⑨ &#125; result += last_result; ⇽--- ⑩ return result;&#125; 变化点： accumulate_block 直接返回值给 std::future. 用vector容器来存储 futrue对象，并用 std::packaged_task 打包任务。这样任务运行的最终结果会返回给future，如果出现异常，也会被future捕获。 最后线程汇合，利用futrue.get()获取计算的返回值并求和。如果线程抛出异常，那么此处调用get会再次抛出异常。 以上代码还有另一个问题，若有线程异常退出，则会导致线程泄漏。我们可以设计一个RAII形式的线程回收类避免这个问题。以下： 12345678910111213141516class join_threads&#123; std::vector&lt;std::thread&gt;&amp; threads;public: explicit join_threads(std::vector&lt;std::thread&gt;&amp; threads_): threads(threads_) &#123;&#125; ~join_threads() &#123; for(unsigned long i=0;i&lt;threads.size();++i) &#123; if(threads[i].joinable()) threads[i].join(); &#125; &#125;&#125;; 3.2 std::async的线程安全 std::async()会让线程库替我们管控线程，线程一旦完成，对应的future就会进入就绪状态。如果不等future进入就绪状态就将其销毁，future对象的析构函数仍然会等待其线程运行结束。体现在，当父线程捕获到某一子线程的异常并准备向上抛时，也会等待其他子线程完成，以防止悬空线程。 4 线程可伸缩性 程序是由串行片段和并行片段共同构成的。如果串行片段所占总体程序的比例是fs，那么N个处理器所取得的整体性能增益P是： Amdahl定律： P=1fs+1−fsN P=\\frac{1}{f_s + \\frac{1-f_s}{N}} P=fs​+N1−fs​​1​ 若串行片段 fs 为0，则加速比为N；若串行片段为1/3，则加速比不可能超过3. 5 并行代码实践 5.1 std::for_each 并行版本 12345678910111213141516171819202122232425262728293031323334353637template&lt;typename Iterator,typename Func&gt;void parallel_for_each(Iterator first,Iterator last,Func f)&#123; unsigned long const length=std::distance(first,last); if(!length) return; unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= std::min(hardware_threads!=0?hardware_threads:2,max_threads); unsigned long const block_size=length/num_threads; std::vector&lt;std::future&lt;void&gt;&gt; futures(num_threads-1); ⇽--- ① std::vector&lt;std::thread&gt; threads(num_threads-1); join_threads joiner(threads); Iterator block_start=first; for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; Iterator block_end=block_start; std::advance(block_end,block_size); std::packaged_task&lt;void(void)&gt; task( ⇽--- ② [=]() &#123; std::for_each(block_start,block_end,f); &#125;); futures[i]=task.get_future(); threads[i]=std::thread(std::move(task)); ⇽--- ③ block_start=block_end; &#125; std::for_each(block_start,last,f); for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; futures[i].get(); ⇽--- ④ &#125;&#125; 由于以上工作线程没有返回值，因此future.get()调用的意义在于提供一种捕获异常的方法。若不想传递异常，亦可以忽略这一操作。 5.2 std::async() 递归版本 123456789101112131415161718192021template&lt;typename Iterator,typename Func&gt;void parallel_for_each(Iterator first,Iterator last,Func f)&#123; unsigned long const length=std::distance(first,last); if(!length) return; unsigned long const min_per_thread=25; if(length&lt;(2*min_per_thread)) &#123; std::for_each(first,last,f); ⇽--- ① &#125; else &#123; Iterator const mid_point=first+length/2; std::future&lt;void&gt; first_half= ⇽--- ② std::async(&amp;parallel_for_each&lt;Iterator,Func&gt;, first,mid_point,f); parallel_for_each(mid_point,last,f); ⇽--- ③ first_half.get(); ⇽--- ④ &#125;&#125; 5.3 std::find并行版本 对于find这类任务，他的特点就是尽早地完成任务，这可以避免浪费资源和时间。若某一线程找到目标元素，如何中断其他线程呢？可以将一原子变量作为标志，每处理一次元素就查验一次该标志。如果这个标志被置为成立，则表明某个线程已找到匹配的元素。这种并行的代价是要反复查验原子变量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768template&lt;typename Iterator,typename MatchType&gt;Iterator parallel_find(Iterator first,Iterator last,MatchType match)&#123; struct find_element ⇽--- ① &#123; void operator()(Iterator begin,Iterator end, MatchType match, std::promise&lt;Iterator&gt;* result, std::atomic&lt;bool&gt;* done_flag) &#123; try &#123; for(;(begin!=end) &amp;&amp; !done_flag-&gt;load();++begin) ⇽--- ② &#123; if(*begin==match) &#123; result-&gt;set_value(begin); ⇽--- ③ done_flag-&gt;store(true); ⇽--- ④ return; &#125; &#125; &#125; catch(...) ⇽--- ⑤ &#123; try &#123; result-&gt;set_exception(std::current_exception()); ⇽--- ⑥ done_flag-&gt;store(true); &#125; catch(...) ⇽--- ⑦ &#123;&#125; &#125; &#125; &#125;; unsigned long const length=std::distance(first,last); if(!length) return last; unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= std::min(hardware_threads!=0?hardware_threads:2,max_threads); unsigned long const block_size=length/num_threads; std::promise&lt;Iterator&gt; result; ⇽--- ⑧ std::atomic&lt;bool&gt; done_flag(false); ⇽--- ⑨ std::vector&lt;std::thread&gt; threads(num_threads-1); &#123; ⇽--- ⑩ join_threads joiner(threads); Iterator block_start=first; for(unsigned long i=0;i&lt;(num_threads-1);++i) &#123; Iterator block_end=block_start; std::advance(block_end,block_size); threads[i]=std::thread(find_element(), ⇽--- ⑪ block_start,block_end,match, &amp;result,&amp;done_flag); block_start=block_end; &#125; find_element()(block_start,last,match,&amp;result,&amp;done_flag); ⇽--- ⑫ &#125; if(!done_flag.load()) ⇽--- ⑬ &#123; return last; &#125; return result.get_future().get(); ⇽--- ⑭&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"5-基于锁的数据结构","slug":"并发编程基础/5-基于锁的数据结构","date":"2023-12-28T03:31:38.000Z","updated":"2025-05-14T02:14:15.356Z","comments":true,"path":"2023/12/28/并发编程基础/5-基于锁的数据结构/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/5-%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1 线程安全栈 基于互斥锁实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;exception&gt;struct empty_stack: std::exception&#123; const char* what() const throw();&#125;;template&lt;typename T&gt;class threadsafe_stack&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack()&#123;&#125; threadsafe_stack(const threadsafe_stack&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); data=other.data; &#125; threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); ⇽--- ① &#125; std::shared_ptr&lt;T&gt; pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); ⇽--- ② std::shared_ptr&lt;T&gt; const res( std::make_shared&lt;T&gt;(std::move(data.top()))); ⇽--- ③ data.pop(); ⇽--- ④ return res; &#125; void pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); value=std::move(data.top()); ⇽--- ⑤ data.pop(); ⇽--- ⑥ &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125;&#125;; 2 线程安全队列 基于锁和条件变量实现，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657template&lt;typename T&gt;class threadsafe_queue&#123;private: mutable std::mutex mut; std::queue&lt;T&gt; data_queue; std::condition_variable data_cond;public: threadsafe_queue() &#123;&#125; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(std::move(new_value)); data_cond.notify_one(); ⇽--- ① &#125; void wait_and_pop(T&amp; value) ⇽--- ② &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;); value=std::move(data_queue.front()); data_queue.pop(); &#125; std::shared_ptr&lt;T&gt; wait_and_pop() ⇽--- ③ &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;); ⇽--- ④ std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;(std::move(data_queue.front()))); data_queue.pop(); return res; &#125; bool try_pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return false; value=std::move(data_queue.front()); data_queue.pop(); return true; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return std::shared_ptr&lt;T&gt;(); ⇽--- ⑤ std::shared_ptr&lt;T&gt; res( std::make_shared&lt;T&gt;(std::move(data_queue.front()))); data_queue.pop(); return res; &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); &#125;&#125;; 3 线程安全map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;functional&gt;#include &lt;list&gt;#include &lt;utility&gt;#include &lt;boost/thread/shared_mutex.hpp&gt;template&lt;typename Key,typename Value,typename Hash=std::hash&lt;Key&gt; &gt;class threadsafe_lookup_table&#123;private: class bucket_type &#123; private: typedef std::pair&lt;Key,Value&gt; bucket_value; typedef std::list&lt;bucket_value&gt; bucket_data; typedef typename bucket_data::iterator bucket_iterator; bucket_data data; mutable boost::shared_mutex mutex; bucket_iterator find_entry_for(Key const&amp; key) const &#123; return std::find_if(data.begin(),data.end(), [&amp;](bucket_value const&amp; item) &#123;return item.first==key;&#125;); &#125; public: Value value_for(Key const&amp; key,Value const&amp; default_value) const &#123; boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry=find_entry_for(key); return (found_entry==data.end())? default_value : found_entry-&gt;second; &#125; void add_or_update_mapping(Key const&amp; key,Value const&amp; value) &#123; std::unique_lock&lt;boost::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry=find_entry_for(key); if(found_entry==data.end()) &#123; data.push_back(bucket_value(key,value)); &#125; else &#123; found_entry-&gt;second=value; &#125; &#125; void remove_mapping(Key const&amp; key) &#123; std::unique_lock&lt;boost::shared_mutex&gt; lock(mutex); bucket_iterator const found_entry=find_entry_for(key); if(found_entry!=data.end()) &#123; data.erase(found_entry); &#125; &#125; &#125;; std::vector&lt;std::unique_ptr&lt;bucket_type&gt; &gt; buckets; Hash hasher; bucket_type&amp; get_bucket(Key const&amp; key) const &#123; std::size_t const bucket_index=hasher(key)%buckets.size(); return *buckets[bucket_index]; &#125;public: typedef Key key_type; typedef Value mapped_type; typedef Hash hash_type; threadsafe_lookup_table( unsigned num_buckets=19, Hash const&amp; hasher_=Hash()): buckets(num_buckets),hasher(hasher_) &#123; for(unsigned i=0;i&lt;num_buckets;++i) &#123; buckets[i].reset(new bucket_type); &#125; &#125; threadsafe_lookup_table(threadsafe_lookup_table const&amp; other)=delete; threadsafe_lookup_table&amp; operator=( threadsafe_lookup_table const&amp; other)=delete; Value value_for(Key const&amp; key, Value const&amp; default_value=Value()) const &#123; return get_bucket(key).value_for(key,default_value); &#125; void add_or_update_mapping(Key const&amp; key,Value const&amp; value) &#123; get_bucket(key).add_or_update_mapping(key,value); &#125; void remove_mapping(Key const&amp; key) &#123; get_bucket(key).remove_mapping(key); &#125; std::map&lt;Key,Value&gt; get_map() const &#123; std::vector&lt;std::unique_lock&lt;boost::shared_mutex&gt; &gt; locks; for(unsigned i=0;i&lt;buckets.size();++i) &#123; locks.push_back( std::unique_lock&lt;boost::shared_mutex&gt;(buckets[i].mutex)); &#125; std::map&lt;Key,Value&gt; res; for(unsigned i=0;i&lt;buckets.size();++i) &#123; for(bucket_iterator it=buckets[i].data.begin(); it!=buckets[i].data.end(); ++it) &#123; res.insert(*it); &#125; &#125; return res; &#125;&#125;; 4 线程安全链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687template&lt;typename T&gt;class threadsafe_list&#123; struct node ⇽--- ① &#123; std::mutex m; std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; node(): ⇽--- ② next() &#123;&#125; node(T const&amp; value): ⇽--- ③ data(std::make_shared&lt;T&gt;(value)) &#123;&#125; &#125;; node head;public: threadsafe_list() &#123;&#125; ~threadsafe_list() &#123; remove_if([](node const&amp;)&#123;return true;&#125;); &#125; threadsafe_list(threadsafe_list const&amp; other)=delete; threadsafe_list&amp; operator=(threadsafe_list const&amp; other)=delete; void push_front(T const&amp; value) &#123; std::unique_ptr&lt;node&gt; new_node(new node(value)); ⇽--- ④ std::lock_guard&lt;std::mutex&gt; lk(head.m); new_node-&gt;next=std::move(head.next); ⇽--- ⑤ head.next=std::move(new_node); ⇽--- ⑥ &#125; template&lt;typename Function&gt; void for_each(Function f) ⇽--- ⑦ &#123; node* current=&amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); ⇽--- ⑧ while(node* const next=current-&gt;next.get()) ⇽--- ⑨ &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); ⇽--- ⑩ lk.unlock(); ⇽--- ⑪ f(*next-&gt;data); ⇽--- ⑫ current=next; lk=std::move(next_lk); ⇽--- ⑬ &#125; &#125; template&lt;typename Predicate&gt; std::shared_ptr&lt;T&gt; find_first_if(Predicate p) ⇽--- ⑭ &#123; node* current=&amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while(node* const next=current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); lk.unlock(); if(p(*next-&gt;data)) ⇽--- ⑮ &#123; return next-&gt;data; ⇽--- ⑯ &#125; current=next; lk=std::move(next_lk); &#125; return std::shared_ptr&lt;T&gt;(); &#125; template&lt;typename Predicate&gt; void remove_if(Predicate p) ⇽--- ⑰ &#123; node* current=&amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while(node* const next=current-&gt;next.get()) &#123; std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); if(p(*next-&gt;data)) ⇽--- ⑱ &#123; std::unique_ptr&lt;node&gt; old_next=std::move(current-&gt;next); current-&gt;next=std::move(next-&gt;next); ⇽--- ⑲ next_lk.unlock(); &#125; ⇽--- ⑳ else &#123; lk.unlock(); ⇽--- ㉑ current=next; lk=std::move(next_lk); &#125; &#125; &#125;&#125;;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"4-原子操作","slug":"并发编程基础/4-原子操作","date":"2023-12-28T03:30:35.000Z","updated":"2025-05-14T02:14:15.324Z","comments":true,"path":"2023/12/28/并发编程基础/4-原子操作/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/4-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1 原子操作 原子操作是不可分割的操作，对于操作共享数据之外的其他线程，观察到这种操作要么完全做好，要么完全没做，不会处于半完成状态。 2 原子类型 标准原子类型的定义位于头文件 &lt;atomic&gt;内，这些类型全都是原子化的。我们可以通过 atomic&lt;T&gt;定义原子类型的变量，如 atomic&lt;bool&gt;,atomic&lt;int&gt; 这些都是原子类型。原子类型的出现是为了取代共享数据的互斥的同步方式，若原子类型是无锁实现，会带来一定的性能提升，以及让代码更加直观可靠。 从C++17开始，所有的原子类型都包含一个静态成员变量，std::atomic::is_always_lock_free。这个成员变量的值表示在任意给定的目标硬件上，原子类型X是否始终以无锁结构形式实现。如果在所有支持该程序运行的硬件上，原子类型X都以无锁结构形式实现，那么这个成员变量的值就为true；否则为false。 2.1 atomic_flag atomic_flag 是一个简单的布尔类型，它一定是无锁操作，因而不提供 is_lock_free()成员函数 。atomic_flag的对象在初始化时清零，随后即可通过成员函数 test_and_set()查值并设置成立，或者由 clear()清零。整个过程只有这两个操作。其他的 atomic&lt;&gt;的原子类型都可以基于其实现。 test_and_set成员函数是一个原子操作，他会先检查 std::atomic_flag当前的状态是否被设置过： 如果没被设置过(比如初始状态或者清除后)，将 std::atomic_flag当前的状态设置为 true，并返回 false。 如果被设置过则直接返回 ture。 2.2 atomic&lt;T&gt; 其他的原子类型都是通过atomic&lt;T&gt; 特例化而成的，但可能不是无锁结构。通过atomic&lt;T&gt; 实例化的原子类型都具有以下接口： load()：从原子对象中以原子方式读取值，并返回读取的值。 store(val)：以原子方式将给定的值 val存储到原子对象中。 exchange(val)：以原子方式将给定的值 val存储到原子对象中，并返回原子对象之前的值。 compare_exchange_weak(expected, val)和 compare_exchange_strong(expected, val)：使用原子比较和交换操作，将原子对象的值与 expected进行比较，如果相等，则将原子对象的值设置为 val。这两个函数的区别在于对比较失败时的行为 compare_exchange_weak可能会失败但不会给出明确的失败原因，而 compare_exchange_strong在比较失败时会返回失败的原子对象的值。 fetch_add(val)和 fetch_sub(val)：以原子方式将原子对象的值与 val相加或相减，并返回操作之前的原子对象的值。 operator T()：将原子对象转换为 T类型的操作数，可以通过此操作符获取原子对象的值。 这些接口只是原子类型提供的一部分功能，还有其他接口可以用于原子操作。使用原子类型可以确保多个线程对共享数据的访问是安全的，避免了数据竞争的问题。**请注意，原子类型只能保证单个操作的原子性，而不能保证多个操作的原子性。**如果需要实现更复杂的原子操作序列，可以使用互斥锁或其他同步机制。 2.3 atomic&lt;UDT&gt; 对于用户自定义类型UDT，需要满足一定条件才能被atomic&lt;&gt;具现化： 必须具备平实拷贝赋值操作符，由编译器代其隐式生成拷贝赋值操作符。 不得含有任何虚函数，不可以从虚基类派生得出。 若具有基类或非静态数据成员，必须具备平实拷贝赋值操作符。 由于以上限制，赋值操作不涉及任何用户编写的代码，因此编译器可借用memcpy()完成。另外，compare_exchange 操作采用的是逐位比较运算，效果等同于直接使用memcmp()函数，即使UDT自行定义了比较运算符，也会被忽略。编译器之所以这样限制，是为了使得可以将UDT视为原始字节，从而让UDT按无锁方式具现化。 3 内存次序 对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义。枚举类std::memory_order具有6个可能的值： 宽松次序：memory_order_relaxed； 获取-释放次序：memory_order_consume（建议不予采用）、memory_order_acquire、memory_order_release、memory_order_acq_rel； 先后一致次序：memory_order_seq_cst（默认）. 先后一致次序是最严格的内存次序，同时也是默认参数。如果程序服从该次序，就简单地把一切事件视为按先后顺序发生，所有线程所见的一切操作都必须服从相同的次序。这样最符合直觉，比较容易理解。但其他次序中，不同线程看到的同一组操作的次序和效果可能呈现差异。 以下以atomic_flag构成的自旋锁为例： 12345678910111213141516class spinlock_mutex&#123; std::atomic_flag flag;public: spinlock_mutex(): flag(ATOMIC_FLAG_INIT) &#123;&#125; void lock() &#123; while(flag.test_and_set(std::memory_order_acquire)); &#125; void unlock() &#123; flag.clear(std::memory_order_release); &#125;&#125;;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"3-线程同步","slug":"并发编程基础/3-线程同步","date":"2023-12-28T03:30:31.000Z","updated":"2025-05-14T02:14:15.324Z","comments":true,"path":"2023/12/28/并发编程基础/3-线程同步/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"何为线程同步？有时候我们需要规范线程的执行顺序，令独立线程上的行为同步。以下介绍C++标准库提供的线程同步工具。 1 信号量 1234567891011121314151617#include &lt;semaphore.h&gt;sem_t semaphore;sem_init(&amp;semaphore, 0, 0);void data_preparation_thread()&#123; while(more_data_to_prepare())&#123; ...... sem_post(&amp;semaphore); //信号量发送（增加） &#125;&#125;void data_processing_thread() &#123; while(true)&#123; sem_wait(&amp;semaphore); //等待信号量（减小） ...... &#125;&#125; 2 条件变量 123456789101112131415161718192021222324252627282930std::mutex mut;std::queue&lt;data_chunk&gt; data_queue; ⇽--- ①std::condition_variable data_cond;void data_preparation_thread() // 由线程乙运行&#123; while(more_data_to_prepare()) &#123; data_chunk const data=prepare_data(); &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(data); ⇽--- ② &#125; data_cond.notify_one(); ⇽--- ③ &#125;&#125;void data_processing_thread() // 由线程甲运行&#123; while(true) &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); ⇽--- ④ data_cond.wait( lk,[]&#123;return !data_queue.empty();&#125;); ⇽--- ⑤ data_chunk data=data_queue.front(); data_queue.pop(); lk.unlock(); ⇽--- ⑥ process(data); if(is_last_chunk(data)) break; &#125;&#125; 以上，data_cond.wait() 建议配合 data_cond.notify_one() 一起用。notify_one() 通知条件变量，使wait() 从阻塞中被唤醒，重新尝试获取锁，再次查验条件。也就是 data_cond.wait() 并非一直检查条件，而是需要 notify_one() 触发。 当有多个线程阻塞等待时，用notify_all() . 另外，为什么这里要使用 std::unique_lock 呢？因为当条件不成立时，wait()要释放锁。而std::lock_guard 无法提供这种灵活性。 利用条件变量构建线程安全队列 虽然std::queue 的操作是原子性的，但是并不代表线程安全，其接口还是存在固有的条件竞争。我们需要把front()和pop()合并成一个函数，这与栈容器的top()和pop()合并相似。另外，为了增加灵活性，这里提供pop的两个变体，try_pop()和wait_and_pop()，一个非阻塞一个阻塞。以下是类定义： 12345678910111213141516#include &lt;memory&gt; ⇽--- ①为使用std::shared_ptr而包含此头文件template&lt;typename T&gt;class threadsafe_queue&#123;public: threadsafe_queue(); threadsafe_queue(const threadsafe_queue&amp;); threadsafe_queue&amp; operator=( const threadsafe_queue&amp;) = delete; ⇽--- ②为简化设计而禁止赋值操作 void push(T new_value); bool try_pop(T&amp; value); ⇽--- ③ std::shared_ptr&lt;T&gt; try_pop(); ⇽--- ④ void wait_and_pop(T&amp; value); std::shared_ptr&lt;T&gt; wait_and_pop(); bool empty() const;&#125;; 完整接口实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;template&lt;typename T&gt;class threadsafe_queue&#123;private: mutable std::mutex mut; ⇽--- ①互斥必须用mutable修饰（针对const对象，准许其数据成员发生变动） std::queue&lt;T&gt; data_queue; std::condition_variable data_cond;public: threadsafe_queue() &#123;&#125; threadsafe_queue(threadsafe_queue const&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lk(other.mut); data_queue=other.data_queue; &#125; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(new_value); data_cond.notify_one(); &#125; void wait_and_pop(T&amp; value) &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;); value=data_queue.front(); data_queue.pop(); &#125; std::shared_ptr&lt;T&gt; wait_and_pop() &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; &#125; bool try_pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return false; value=data_queue.front(); data_queue.pop(); return true; &#125; std::shared_ptr&lt;T&gt; try_pop() &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); &#125;&#125;; 3 future机制 如果某个线程按计划只需等待一次，那么利用 future 等待更合适。标准库中有std::future 和 std::shared_future，其参照了std::unique_ptr 和 std::shared_ptr. 注意，虽然future对象能用于线程间通信，但是future对象不提供同步访问。若有多个线程访问同一个future对象，必须用互斥访问。 3.1 async 异步运行 使用 std::async 启动一个异步任务。与 std::thread 对象等待运行方式的不同， std::async 会返回一个 std::future 对象，这个对象持有最终计算出来的结果。当你需要这个值时，你只需要调用 future 对象的get()方法阻塞获取。 std::async是C++中一种快速建立并行的方法，类似的，python中ProcessPoolExecutor也可以快速并行。 12345678910#include &lt;future&gt;#include &lt;iostream&gt;int find_the_answer_to_ltuae();void do_other_stuff();int main()&#123; std::future&lt;int&gt; the_answer=std::async(find_the_answer_to_ltuae); do_other_stuff(); std::cout&lt;&lt;&quot;The answer is &quot;&lt;&lt;the_answer.get()&lt;&lt;std::endl; //阻塞获取&#125; std::async 的传参与 std::thread的传参一致，若传入的是普通函数，则第一个参数是函数对象，其余为函数的入参；若传入的是类成员函数，则第一个参数为类成员函数地址，第二个参数是对象地址，其余为函数入参。注意如果要传引用，用std::ref()包装。 std::async 有两种运行方式，一种是起新线程的异步运行方法，一种是在当前线程的同步运行方法。通过设定 std::async 的第一个参数，可以指定运行方式。该参数值可以是 std::launch::deferred 或 std::launch::async，前者指定在本线程上延迟执行函数，后者则新起一个线程执行。注：若不设定，则由系统自行选择。 3.2 packaged_task 打包任务 std::packaged_task&lt;&gt;可打包函数对象和future对象，他可以作为线程池的构件单元。std::packaged_task&lt;&gt;是一个类模板，其模板参数是函数签名，如：void()表示一个函数，无入参，无返回值。std::packaged_task&lt;&gt;对象具有 get_futrue()方法，能够返回future对象。std::packaged_task 是个可调用对象，调用时函数开始运行。 std::packaged_task 这种特性使得可以在线程间传递任务，即当前线程将任务包装在 std::packaged_task 中，获得对应 future 对象后，传递给另外的线程，并由其触发任务运行。等需要用到结果时，再用future 对象获取。以下代码是GUI前端向后台线程推处理任务，其将用户的请求（点击事件等）传递给后台线程。 123456789101112131415161718192021222324252627282930313233343536#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;future&gt;#include &lt;thread&gt;#include &lt;utility&gt;std::mutex m;std::deque&lt;std::packaged_task&lt;void()&gt;&gt; tasks;bool gui_shutdown_message_received();void get_and_process_gui_message();void gui_thread() ⇽--- ①&#123; while(!gui_shutdown_message_received()) ⇽--- ② &#123; get_and_process_gui_message(); ⇽--- ③ std::packaged_task&lt;void()&gt; task; &#123; std::lock_guard&lt;std::mutex&gt; lk(m); if(tasks.empty()) ⇽--- ④ continue; task=std::move(tasks.front()); ⇽--- ⑤ tasks.pop_front(); &#125; task(); ⇽--- ⑥ &#125;&#125;std::thread gui_bg_thread(gui_thread);template&lt;typename Func&gt;std::future&lt;void&gt; post_task_for_gui_thread(Func f)&#123; std::packaged_task&lt;void()&gt; task(f); ⇽--- ⑦ std::future&lt;void&gt; res=task.get_future(); ⇽--- ⑧ std::lock_guard&lt;std::mutex&gt; lk(m); tasks.push_back(std::move(task)); ⇽--- ⑨ return res; ⇽--- ⑩&#125; 3.3 promise 等待设定值 std::promise 配合 std::futrue 可实现以下机制：等待数据的线程在 futrue 上阻塞，提供数据的线程则利用 promise 设定关联值，使futrue就绪。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;void initiazer(std::promise&lt;int&gt; * promObj)&#123; std::cout&lt;&lt;&quot;新线程内部&quot;&lt;&lt;std::endl; promObj-&gt;set_value(35);&#125;int main()&#123; std::promise&lt;int&gt; promiseObj; std::future&lt;int&gt; futureObj = promiseObj.get_future(); std::thread th(initiazer, &amp;promiseObj); std::cout&lt;&lt;futureObj.get()&lt;&lt;std::endl; th.join(); return 0;&#125; 3.4 shared_future 共享期待 std::future只有一个实例可以获得特定的同步结果，而 std::shared_future 实例是可拷贝的，所以多个对象可以引用同一关联“期望”的结果。 12std::promise&lt;std::string&gt; p;std::shared_future&lt;std::string&gt; sf(p.get_future()); ⇽--- ①隐式转移归属权 3.5 等待多个futrue 当线程需要汇总各个std::async任务的处理结果时，需要逐个等待future对象，可能写出如下代码： 123456789101112131415161718192021std::future&lt;FinalResult&gt; process_data(std::vector&lt;MyData&gt;&amp; vec)&#123; size_t const chunk_size=whatever; std::vector&lt;std::future&lt;ChunkResult&gt;&gt; results; for(auto begin=vec.begin(),end=vec.end();beg!=end;)&#123; size_t const remaining_size=end-begin; size_t const this_chunk_size=std::min(remaining_size,chunk_size); results.push_back( std::async(process_chunk,begin,begin+this_chunk_size)); begin+=this_chunk_size; &#125; return std::async([all_results=std::move(results)]()&#123; std::vector&lt;ChunkResult&gt; v; v.reserve(all_results.size()); for(auto&amp; f: all_results) &#123; v.push_back(f.get()); ⇽--- ① &#125; return gather_results(v); &#125;);&#125; 当有任务完成时，代码①被唤醒，随之又进入休眠，等待下一个任务唤醒。我们有更简洁的写法，可以减少这种切换开销。采用 std::experimental::when_all 等待所有任务结束再唤醒。 1234567891011121314151617181920212223242526272829std::experimental::future&lt;FinalResult&gt; process_data( std::vector&lt;MyData&gt;&amp; vec)&#123; size_t const chunk_size=whatever; std::vector&lt;std::experimental::future&lt;ChunkResult&gt;&gt; results; for(auto begin=vec.begin(),end=vec.end();beg!=end;)&#123; size_t const remaining_size=end-begin; size_t const this_chunk_size=std::min(remaining_size,chunk_size); results.push_back( spawn_async( process_chunk,begin,begin+this_chunk_size)); begin+=this_chunk_size; &#125; return std::experimental::when_all( results.begin(),results.end()).then( ⇽--- ① [](std::future&lt;std::vector&lt; std::experimental::future&lt;ChunkResult&gt;&gt;&gt; ready_results) &#123; std::vector&lt;std::experimental::future&lt;ChunkResult&gt;&gt; all_results=ready_results .get(); std::vector&lt;ChunkResult&gt; v; v.reserve(all_results.size()); for(auto&amp; f: all_results) &#123; v.push_back(f.get()); ⇽--- ② &#125; return gather_results(v); &#125;);&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"2-共享数据","slug":"并发编程基础/2-共享数据","date":"2023-12-28T03:30:27.000Z","updated":"2025-05-14T02:14:15.344Z","comments":true,"path":"2023/12/28/并发编程基础/2-共享数据/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","excerpt":"","text":"如果线程间所有的共享数据都是只读，就不会有问题。多线程共享数据的问题大多由写数据引起，以下介绍线程间共享数据的安全做法。 1 互斥锁 C++中，保护共享数据最基础的方式就是互斥（std::lock_guard + std:mutex）。互斥意味着，两个或两个以上线程操作同一个数据，必须排队等待。 12345678910#include &lt;list&gt;#include &lt;mutex&gt;std::list&lt;int&gt; some_list; std::mutex some_mutex; void add_to_list(int new_value)&#123; std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(new_value);&#125; C++提供的 std::lock_guard，构造时对 mutex 上锁，析构时对 mutex 解锁，这种RAII方式保证了mutex无论如何都能够被解锁。 利用互斥锁构造线程安全栈 即使C++标准库容器的操作是原子性的，但这并不代表容器的操作就是线程安全的。举个例子： 123456stack&lt;int&gt; s;if(!s.empty()) &#123; int const value=s.top(); s.pop(); &#125; 当 stack 判定为非空时，会对栈顶元素弹出。如果这时刚好另外一个线程弹出栈的最后一个元素，那么此时的操作便是: 对一个空栈进行pop，这是一个未定义的行为。我们可以利用互斥锁来构建线程安全的栈，说白了是用一个粗粒度的锁来控制容器各接口的访问，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;exception&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;stack&gt;struct empty_stack: std::exception&#123; const char* what() const throw();&#125;;template&lt;typename T&gt;class threadsafe_stack&#123;private: std::stack&lt;T&gt; data; mutable std::mutex m;public: threadsafe_stack()&#123;&#125; threadsafe_stack(const threadsafe_stack&amp; other) &#123; std::lock_guard&lt;std::mutex&gt; lock(other.m); data=other.data; ⇽--- ①在构造函数的函数体（constructor body）内进行复制操作 &#125; threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); data.push(std::move(new_value)); &#125; std::shared_ptr&lt;T&gt; pop() &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); ⇽--- ②试图弹出前检查是否为空栈 std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); ⇽--- ③改动栈容器前设置返回值 data.pop(); return res; &#125; void pop(T&amp; value) &#123; std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); value=data.top(); data.pop(); &#125; bool empty() const &#123; std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); &#125;&#125;; 2 死锁 当两个线程互相等待对方解锁，则形成死锁。（递归获取普通锁也会形成死锁），以下两个建议： ① 固定顺序上锁：避免死锁的通常建议，就是让两个互斥量总以相同的顺序上锁，如总在互斥量B之前锁住互斥量A，一般不会死锁。 ② 同时上锁：当然有些时候我们很难保证固定的顺序，比如操作同一个类的两个实例，互相交换他们的内部数据，访问时需获得互斥锁。此时，如果两个线程都在执行这件事，只不过入参（实例1，实例2）的顺序不一样，就会发生死锁，这个时候是没有什么固定顺序可言的。std:lock 可以解决这个问题，同时锁住两个互斥量，就没有所谓的顺序了，如下： 12345678910111213141516171819class some_big_object;void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);class X&#123;private: some_big_object some_detail; std::mutex m;public: X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125; friend void swap(X&amp; lhs, X&amp; rhs) &#123; if(&amp;lhs==&amp;rhs) return; std::lock(lhs.m,rhs.m); ⇽--- ① std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock); ⇽--- ② std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock); ⇽--- ③ swap(lhs.some_detail,rhs.some_detail); &#125;&#125;; 其中，std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock); 是接管锁的管理权，并非创建新锁。std::lock 会阻塞等待所有锁均可获得。 C++17对以上写法进行了简化，如下： 1234567void swap(X&amp; lhs, X&amp; rhs)&#123; if(&amp;lhs==&amp;rhs) return; std::scoped_lock guard(lhs.m,rhs.m); //构造时同时锁定，析构时释放。 swap(lhs.some_detail,rhs.some_detail);&#125; 避免死锁的准则 避免嵌套锁：假设已经持有锁，就不要试图获取第二个锁。如果有多个锁，请使用 std::lock 同时上锁。 固定顺序上锁：当不允许使用 std::lock 同时上锁时，请使用固定顺序依次上锁。 上锁时尽量避免用户接口：因为我们不知道用户接口里面时候也持有锁，因而尽可能在已经持有锁的条件下不要调用用户接口。 使用层次锁：层次锁需要对你的应用进行分层，并且识别在给定层上所有可上锁的互斥量。当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的。 3 其他锁 3.1 unique_lock unique_lock 支持灵活的锁定和解锁操作：std::unique_lock提供了 lock()和 unlock()成员函数，允许在需要的时候手动锁定和解锁互斥量。这样可以灵活地控制临界区的访问时间，而不仅限于对象的构造和析构时，如下： 123456789void get_and_process_data()&#123; std::unique_lock&lt;std::mutex&gt; my_lock(the_mutex); some_class data_to_process=get_next_data_chunk(); my_lock.unlock(); // 1 不要让锁住的互斥量越过process()函数的调用 result_type result=process(data_to_process); my_lock.lock(); // 2 为了写入数据，对互斥量再次上锁 write_result(data_to_process,result);&#125; 3.2 shared_lock shared_lock 是一种多线程同步机制，它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。shared_lock 直到 C++17才被标准库提供，在此之前，可以使用 boost::shared_lock 。如下为dns缓存表的读写控制： 1234567891011121314151617181920212223#include &lt;map&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;class dns_entry;class dns_cache&#123; std::map&lt;std::string,dns_entry&gt; entries; mutable std::shared_mutex entry_mutex; public: dns_entry find_entry(std::string const&amp; domain) const &#123; std::shared_lock&lt;std::shared_mutex&gt; lk(entry_mutex); ⇽--- ① std::map&lt;std::string,dns_entry&gt;::const_iterator const it= entries.find(domain); return (it==entries.end())?dns_entry():it-&gt;second; &#125; void update_or_add_entry(std::string const&amp; domain,dns_entry const&amp; dns_details) &#123; std::lock_guard&lt;std::shared_mutex&gt; lk(entry_mutex); ⇽--- ② entries[domain]=dns_details; &#125;&#125;; 以上代码使用的互斥量为 std::shared_mutex，该互斥量被 shared_lock 持有时，多线程均可持锁访问。被 lock_guard 或 unique_lock 持有时只能当线程持有该锁。 12345// 读时用：std::shared_lock&lt;std::shared_mutex&gt; lk(entry_mutex);// 写时用：std::lock_guard&lt;std::shared_mutex&gt; lk(entry_mutex); 或 std::unique_lock&lt;std::shared_mutex&gt; lk(entry_mutex); 3.3 递归锁 C++标准库提供了 std::recursive_mutex 类。其功能与 std::mutex 类似，除了你可以从同一线程的单个实例上获取多个锁。在互斥量锁住其他线程前，你必须释放你拥有的所有锁，所以当你调用lock()三次时，你也必须调用unlock()三次。 4 再看单例模式 double-check 单例模式： 1234567if (instance_ == nullptr) &#123; \\\\ 语句1 std::lock_guardstd::mutex lock(mutex_); if (instance_ == nullptr) &#123; instance_ = new Singleton; \\\\ 语句2 &#125;&#125;return instance_; 如上代码，对于 语句2是一个写操作 ，我们用mutex来保护instance_这个变量。但是 语句1是一个读操作 ，if (instance_ == nullptr)，这个语句是用来读取instance_这个变量，而这个读操作是没有锁的。所以在多线程情况下，这种写法明显存在线程安全问题。 不同的编译器表现是不一样的。可能先将该内存地址赋给instance_，然后再调用构造函数。这是线程A恰好申请完成内存，并且将内存地址赋给instance_，但是还没调用构造函数的时候。线程B执行到语句1，判断instance_此时不为空，则返回该变量，然后调用该对象的函数，但是该对象还没有进行构造，此时调用会发生错误。 C++11对单例模式提供了语言级别的支持，std::call_once可保证在多线程中函数只被调用一次。std::call_once 可以和任何函数或可调用对象一起使用。如：std::call_once(connection_init_flag,&amp;X::open_connection,this); 如下： 1234567891011std::shared_ptr resource_ptr;std::once_flag resource_flag; // 1void init_resource()&#123; resource_ptr.reset(new some_resource);&#125;void foo()&#123; std::call_once(resource_flag,init_resource); // 可以完整的进行一次初始化 resource_ptr-&gt;do_something();&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"1-线程管理","slug":"并发编程基础/1-线程管理","date":"2023-12-28T03:30:22.000Z","updated":"2025-05-14T02:14:15.324Z","comments":true,"path":"2023/12/28/并发编程基础/1-线程管理/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"每个C++程序至少有一个线程，即main线程。随后，程序可以发起更多线程，他们以别的函数作为入口。当main函数返回时，程序随即退出，其他线程也会随着终结（当然如果有detach线程，情况不一样）。其中，任何线程发生错误崩溃，都会导致整个进程退出。 1 新起线程 123#include &lt;thread&gt;void do_some_work();std::thread my_thread(do_some_work); 不限于普通函数，任何可调用类型都可以初始化 std::thread 。如函数对象，lambda表达式等。如下： 1234567891011class background_task&#123;public: void operator()() const &#123; do_something(); do_something_else(); &#125;&#125;;background_task f;std::thread my_thread(f); 需要注意的是，这样的传参，函数对象 f 是被复制到新线程空间中的，要关注对象副本运行是否会影响正常功能。另外，请不要让新创建的线程访问当前上下文的局部变量，否则当上下文执行后，该局部变量失效。 2 回收线程 1my_thread.join() 在 std:thread 对象被销毁前，我们需要确保已经调用 join() 或 detach() 方法，以确保能够回收线程空间。 ① 若调用 join 方法，则需要格外小心，因为我们需要确保在每一个函数的出口都能调用join方法，尤其是抛出异常的情况。以下提供一种 RAII 方法，确保总能回收线程。 1234567891011121314151617181920212223242526class thread_guard&#123; std::thread&amp; t;public: explicit thread_guard(std::thread&amp; t_): t(t_) &#123;&#125; ~thread_guard() &#123; if(t.joinable()) &#123; t.join(); &#125; &#125; thread_guard(thread_guard const&amp;)=delete; thread_guard&amp; operator=(thread_guard const&amp;)=delete;&#125;; struct func; void f()&#123; int some_local_state=0; func my_func(some_local_state); std::thread t(my_func); thread_guard g(t); do_something_in_current_thread();&#125; 以上，无论 f 函数正常退出还是异常退出，都会析构thread_guard 对象，从而保证一定会调用线程join方法。 ② 若使用detach方法，父线程不需要显式地等待子线程，整个进程会等到子线程运行完才完全退出，因此也回收了线程空间。 3 线程传参 3.1 直接传值 std::thread是可以直接传递参数的，如：std::thread t(func, 3, “hello”); 需要注意的是，默认参数是拷贝到线程独立内存中。即使传递的是对象的引用，传递给函数的参数是对象拷贝的引用，而非对象本身的引用。 3.2 传引用 当传递引用时，使用std::ref进行传参。 1std::thread t(update_data_for_widget, w, std::ref(data)); 3.3 成员函数传参 对于成员函数传参，采用以下形式。若添加第三个参数，则它会作为成员函数的第一个参数。 123456class X &#123;public: void do_lengthy_work();&#125;;X my_x;std::thread t(&amp;X::do_lengthy_work, &amp;my_x); 4 移交线程管理权 12345678void f(std::thread t);void g()&#123; void some_function(); f(std::thread(some_function)); std::thread t(some_function); f(std::move(t));&#125; 移交线程管理权，可以将线程交由类掌管。另外一个好处是，只要将线程归属权转移给某个thread_guard对象，其他对象就无法做汇合或分离操作。 由于线程支持移动语义，因而标准库容器可以合适地装载 std:thread 对象。以下代码经常用于数据并行处理，如下： 1234567891011void do_work(unsigned id);void f()&#123; std::vector&lt;std::thread&gt; threads; for(unsigned i=0;i&lt;20;++i) &#123; threads.emplace_back(do_work,i); &#125; for(auto&amp; entry: threads) entry.join();&#125;","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"0-并发简述","slug":"并发编程基础/0-并发简述","date":"2023-12-28T03:30:16.000Z","updated":"2025-05-14T02:14:15.320Z","comments":true,"path":"2023/12/28/并发编程基础/0-并发简述/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/0-%E5%B9%B6%E5%8F%91%E7%AE%80%E8%BF%B0/","excerpt":"","text":"为什么使用并发？ 分离关注点和性能提升。（唯一原因） 性能提升的两种方式：任务并行 &amp; 数据并行。 为什么不使用并发？ 收益小于代价。 使用并发的代码通常更难理解，会直接拉高开发和维护成本，同时也更可能引起错误。因而除非并发能带来明显的性能提升和代码清晰度，否则别使用并发。 多线程带来的代价 线程启动开销。系统为线程分配内核资源和栈空间，都会耗费时间。 资源消耗：每个线程都需要独立的堆栈空间，太多的线程也会耗尽进程的可用内存或地址空间。 切换性能：线程越多，系统所做的上下文切换越频繁。太多的线程会拉低应用软件的整体性能。","categories":[{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"2-python调用C","slug":"混合编程/2-python调用C","date":"2023-12-20T06:02:35.000Z","updated":"2025-05-14T02:14:15.376Z","comments":true,"path":"2023/12/20/混合编程/2-python调用C/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/20/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/2-python%E8%B0%83%E7%94%A8C/","excerpt":"","text":"python调用C库是一种非常常见的做法，实际上很多python第三方库底层实现就是调用C动态库，以提高执行效率。这也是为什么python被称为“胶水语言”，即便捷地把各种C库粘结在一起。 1 Ctypes方法 1.1 C部分 注意：如果是C++代码，需要将接口extern “C”{}，告诉编译器按C语言风格来编译接口。 123int mul(int a,int b)&#123; return a*b;&#125; 编译：gcc -fPIC -shared ./c_call_python.c -o demo.so 1.2 python部分 1234567import ctypeslib = ctypes.cdll.LoadLibrary(&#x27;./demo.so&#x27;)lib.mul.restype = ctypes.c_inta = ctypes.c_int(12)b = ctypes.c_int(5)print(f&#x27;result: &#123;lib.mul(a,b)&#125;&#x27;) 调用非常简单，其中需要多做的步骤是数据类型转换，这个没办法，C语言是静态类型语言，有明确的类型声明。 2 Boost.Python方法 Ctypes的方法能做到C部分无感，但python部分有感，主要由于要做一些数据类型的转换适配。如果你想做到python无感，那么你可以使用Boost.Python的方法，当然代价是C++部分有感，并且要引入整个Boost库。 2.1 简单示例 2.1.1 C++部分 123456789101112#include &lt;boost/python.hpp&gt;char const* greet()&#123; return &quot;hello, boost&quot;;&#125;BOOST_PYTHON_MODULE(hello)&#123; using namespace boost::python; def(&quot;greet&quot;, greet);&#125; 编译：g++ -fPIC -shared -I /usr/include/python3.9/ hello.cc -o hello.so -lboost_python ，注意：需要提前安装boost.python库。 2.1.2 Python部分 123456def test(): import hello return hello.greet()if __name__ == &quot;__main__&quot;: print test() 2.2 复杂示例 2.2.1 C++部分 123456789101112131415161718192021222324252627282930313233343536#include &lt;boost/python.hpp&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace boost::python;struct Person&#123; void set_name(std::string name) &#123; this-&gt;name = name; &#125; std::string print_info(); void set_items(list&amp; prices, list&amp; discounts); std::string name; std::vector&lt;double&gt; item_prices; std::vector&lt;double&gt; item_discounts;&#125;;void Person::set_items(list&amp; prices, list&amp; discounts)&#123; for(int i = 0; i &lt; len(prices); ++i) &#123; //本质上是在C++这里做了类型转换 double price = extract&lt;double&gt;(prices[i]); double discount = extract&lt;double&gt;(discounts[i]); item_prices.push_back(price); item_discounts.push_back(discount); &#125;&#125;BOOST_PYTHON_MODULE(person)&#123; class_&lt;Person&gt;(&quot;Person&quot;) .def(&quot;set_name&quot;, &amp;Person::set_name) .def(&quot;print_info&quot;, &amp;Person::print_info) .def(&quot;set_items&quot;, &amp;Person::set_items) ; &#125; 2.2.2 python部分 12345678910def test(): import person p = person.Person() p.set_name(&#x27;Qie&#x27;) p.set_items([100, 123.456, 888.8], [0.3, 0.1, 0.5]) print p.print_info()if __name__ == &quot;__main__&quot;: test()","categories":[{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/categories/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"1-C调用python","slug":"混合编程/1-C调用python","date":"2023-12-20T03:48:54.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2023/12/20/混合编程/1-C调用python/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/12/20/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/1-C%E8%B0%83%E7%94%A8python/","excerpt":"","text":"1 hello_python 将python视为一个第三方库，即可通过python提供的C语言API调用python解释器。简单示例如下： 123456789#include &lt;python3.9/Python.h&gt;int main(int argc, char *argv[])&#123; Py_SetProgramName((wchar_t*)argv[0]); Py_Initialize(); PyRun_SimpleString(&quot;print(&#x27;Hello Python!&#x27;)&quot;); Py_Finalize(); return 0;&#125; 编译： 1gcc -I/usr/include/python3.9 ./c_call_python.c -lpython3.9 如果提示某些python相关头文件找不到，则可能需要安装python-dev版本。 1sudo apt install python3.9-dev 2 调用python模块 1234567891011121314151617181920212223242526272829#include &lt;python3.9/Python.h&gt;int python_function_test(int a) &#123; int res; PyObject *pModule,*pFunc; PyObject *pArgs, *pValue; /* import */ PyRun_SimpleString(&quot;import sys&quot;); PyRun_SimpleString(&quot;sys.path.append(&#x27;./&#x27;)&quot;); pModule = PyImport_Import(PyUnicode_FromString(&quot;module_a&quot;)); /* module_a.test_func */ pFunc = PyObject_GetAttrString(pModule, &quot;test_func&quot;); /* build args */ pArgs = PyTuple_New(1); PyTuple_SetItem(pArgs,0, PyLong_FromLong(a)); /* call */ pValue = PyObject_CallObject(pFunc, pArgs); res = PyLong_AsLong(pValue); return res;&#125;int main(int argc, char *argv[])&#123; Py_SetProgramName((wchar_t*)argv[0]); Py_Initialize(); printf(&quot;result: %d\\n&quot;,python_function_test(2)); Py_Finalize(); return 0;&#125; 其中，module_a是python脚本的名字，test_func是脚本中的一个函数。","categories":[{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/categories/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"3-gtest的使用","slug":"C++那些事/3-gtest的使用","date":"2023-11-08T09:13:52.000Z","updated":"2025-10-11T06:33:00.842Z","comments":true,"path":"2023/11/08/C++那些事/3-gtest的使用/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/11/08/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/3-gtest%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1 软件包介绍 gtest是google提供的一个轻量级单元测试框架，它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。 2 软件包安装 12345git clone https://github.com/google/googletest.gitcd googletest mkdir build &amp;&amp; cd buildcmake .. &amp;&amp; makesudo make install 3 软件包使用 3.1 快速开始 123456789101112131415#include &quot;gtest/gtest.h&quot;int Factorial(int n) &#123; int result = 1; for (int i = 1; i &lt;= n; i++) &#123; result *= i; &#125; return result;&#125;namespace sample1&#123;TEST(FactorialTest, Zero) &#123; EXPECT_EQ(1, Factorial(0)); &#125;&#125; 编译运行： 1g++ ./mytest.cpp -lgtest -std=c++14 -lgtest_main -lpthread -o mytest 其中链接 -lgtest_main 是因为测试的 main 函数在 gtest_main.a 库中，由它拉起所有的测试用例。 3.2 断言接口 gtest中，断言的宏可以分为两类，一类是ASSERT系列，一类是EXPECT系列。 ​​ASSERT_（致命断言）​​：当断言失败时，它会立即终止当前测试函数（注意，是当前 TEST或 TEST_F函数）的执行。这意味着该断言之后的所有代码都不会再运行。这就像是遇到一个无法逾越的障碍，必须停下来。 ​​EXPECT_（非致命断言）​​：当断言失败时，它会生成一个错误记录，但测试函数会继续执行下一个断言。这允许你在单次测试运行中验证多个独立条件，并看到所有失败的检查点。这更像是收集一系列问题，然后统一汇报。 一般使用 ASSERT_ 验证关键前提​。使用 EXPECT_ 的场景：验证多个独立条件​。 3.2.1 布尔型检查 Fatal assertion Nonfatal assertion Verifies ASSERT_TRUE(condition); EXPECT_TRUE(condition); condition is true ASSERT_FALSE(condition); EXPECT_FALSE(condition); condition is false 3.2.2 二值检查 Fatal assertion Nonfatal assertion Verifies ASSERT_EQ(expected, actual); EXPECT_EQ(expected, actual); expected == actual ASSERT_NE(val1, val2); EXPECT_NE(val1, val2); val1 != val2 ASSERT_LT(val1, val2); EXPECT_LT(val1, val2); val1 &lt; val2 ASSERT_LE(val1, val2); EXPECT_LE(val1, val2); val1 &lt;= val2 ASSERT_GT(val1, val2); EXPECT_GT(val1, val2); val1 &gt; val2 ASSERT_GE(val1, val2); EXPECT_GE(val1, val2); val1 &gt;= val2 3.2.3 字符串检查 Fatal assertion Nonfatal assertion Verifies ASSERT_STREQ(expected_str, actual_str); EXPECT_STREQ(expected_str,actual_str); the two C strings have the same content ASSERT_STRNE(str1, str2); EXPECT_STRNE(str1, str2); the two C strings have different content ASSERT_STRCASEEQ(expected_str, actual_str); EXPECT_STRCASEEQ(expected_str, actual_str); the two C strings have the same content, ignoring case （忽略大小写） ASSERT_STRCASENE(str1, str2); EXPECT_STRCASENE(str1, str2); the two C strings have different content, ignoring case （忽略大小小） 3.2.4 异常检查 Fatal assertion Nonfatal assertion Verifies ASSERT_THROW(statement, exception_type); EXPECT_THROW(statement, exception_type); statement throws an exception of the given type ASSERT_ANY_THROW(statement); EXPECT_ANY_THROW(statement); statement throws an exception of any type ASSERT_NO_THROW(statement); EXPECT_NO_THROW(statement); statement doesn’t throw any exception 3.2.5 浮点检查 Fatal assertion Nonfatal assertion Verifies ASSERT_FLOAT_EQ(expected, actual); EXPECT_FLOAT_EQ(expected, actual); the two float values are almost equal ASSERT_DOUBLE_EQ(expected, actual); EXPECT_DOUBLE_EQ(expected, actual); the two double values are almost equal 3.2.6 相近值检查 Fatal assertion Nonfatal assertion Verifies ASSERT_NEAR(val1, val2, abs_error); EXPECT_NEAR(val1, val2, abs_error); the difference between val1 and val2 doesn’t exceed the given absolute error 3.3 宏测试接口 3.3.1 TEST TEST(test_suite_name, test_name) 其中，test_suite_name 为测试组名，test_name 为测试用例名，一个测试组可包含多个测试用例。注意这里同一个 test_suite 下的 test 会可能相互影响。 3.3.2 TEST_F TEST_F(test_fixture, test_name) TEST宏的作用是创建一个简单测试，它定义了一个测试函数，在这个函数里可以使用任何C++代码并使用提供的断言来进行检查。 TEST_F主要是进行多样测试，就是多种不同情况的测试TestCase中都会使用相同一份的测试数据的时候将会才用它。即用相同的数据测试不同的行为，如果采用TEST宏进行测试那么将会为不同的测试case创建一份数据。TEST_F宏将会共用一份避免重复拷贝共具灵活性。 使用 TEST_F 前需要创建一个测试类，继承于::testing::Test类。在类内部使用public或者protected定义其成员，使测试子类可以使用其成员。为什么要定义这个测试类？是为了方便我们为每个 TEST_F 创建一个干净独立的环境，即需要定义初始化和清理函数。一般的，“构造函数/析构函数” 和 “SetUp/TearDown” 这两对都可以用来进行初始化和清理。需要注意不要在 构造/析构函数 里抛出异常。 以下选自 apollo 项目的 ConfigManagerTest 片段： 123456789101112131415161718192021222324class ConfigManagerTest : public testing::Test &#123; protected: ConfigManagerTest() : config_manager_(NULL) &#123;&#125; virtual ~ConfigManagerTest() &#123;&#125; virtual void SetUp() &#123; FLAGS_work_root = &quot;modules/perception/data&quot;; FLAGS_config_manager_path = &quot;./config_manager_test/config_manager.config&quot;; config_manager_ = ConfigManager::instance(); &#125; protected: ConfigManager* config_manager_;&#125;;TEST_F(ConfigManagerTest, test_Init) &#123; EXPECT_TRUE(config_manager_-&gt;Init()); EXPECT_EQ(config_manager_-&gt;NumModels(), 3u);&#125;TEST_F(ConfigManagerTest, test_Reset) &#123; EXPECT_TRUE(config_manager_-&gt;Reset()); std::string wrong_root = &quot;wrong_root&quot;; config_manager_-&gt;SetWorkRoot(wrong_root); EXPECT_FALSE(config_manager_-&gt;Reset()); config_manager_-&gt;SetWorkRoot(FLAGS_work_root); 3.4 预处理事件机制 在单元测试中，我们经常需要在某个测试套件、测试用例或者整个测试运行之前进行前置条件设置及检查，或者运行之后对运行结果进行校验等操作。在gtest中，称之为事件机制。gtest将事件按照作用的范围不同进行划分，从大到小总共分为3个层次： 整个测试层面，即在测试工程开始前和结束后进行；（Environment层面） 测试套件层面，即在某个测试套件开始前和结束后进行；（TestSuite层面） 测试用例层面，即在某个测试用例开始前和结束后进行；（TestCase层面） 3.4.1 Environment层面 实现 Environment 层面的环境构造，需要写一个类，继承testing::Environment类，覆盖里面的 SetUp 和 TearDown 方法。 1234567891011121314151617class myEnvirment : public testing::Environment &#123;public: virtual void SetUp() &#123; cout &lt;&lt; &quot;environment setup&quot; &lt;&lt; endl; &#125; virtual void TearDown() &#123; cout &lt;&lt; &quot;environment teardown&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char **argv)&#123; ::testing::InitGoogleTest(&amp;argc, argv); ::testing::AddGlobalTestEnvironment(new myEnvirment()); return RUN_ALL_TESTS();&#125; 3.4.2 TestSuite层面 实现 TestSuite 层面的环境构造，需要写一个类，继承testing::Test类，并覆盖它的静态方法：SetUpTestCase 和 TearDownTestCase. 1234567891011121314class FooTest : public testing::Test &#123; protected: static void SetUpTestCase() &#123; shared_resource_ = new ; &#125; static void TearDownTestCase() &#123; delete shared_resource_; shared_resource_ = NULL; &#125; static T* shared_resource_;&#125;;TEST(FooTest, case1)TEST(FooTest, case2) 3.4.3 TestCase层面 实现 TestCase 层面的环境构造，需要写一个类，继承testing::Test类，并覆盖它 SetUp 和 TearDown 方法。具体见 3.3.2 TEST_F 小节。 引用： https://google.github.io/googletest/ https://cloud.tencent.com/developer/article/2159398","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"C++库","slug":"C-库","permalink":"https://xie-peiquan.gitee.io/tags/C-%E5%BA%93/"}]},{"title":"2-protobuf的使用","slug":"C++那些事/2-protobuf的使用","date":"2023-11-05T08:03:45.000Z","updated":"2025-05-14T02:14:15.252Z","comments":true,"path":"2023/11/05/C++那些事/2-protobuf的使用/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/11/05/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/2-protobuf%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"0 软件包介绍 protobuf是google定义的一套数据传输格式和规范，用于不同应用或进程之间进行通信时使用。protobuf 支持跨平台, 跨语言, 支持目前绝大多数语言, 例如C++, C#, Java, Python等。 1 Why protobuf ? 先来看看目前常用的 序列化 / 反序列化 方法: 将原始数据结构序列化为 字节流 传输。(这是一种脆弱的数据传输方法，它要求 接收端 必须遵守完全相同的内存布局，并禁止扩展数据格式.) 将原始数据结构序列化为 XML 形式。(这是一种广泛使用的数据传输格式，但是 XML 因为冗长而占用了大量的存储空间.) protobuf 通过定义的 message 数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。相比XML，其序列化后的消息大小只有XML的1/10 ~ 1/3，解析速度比XML快20 ~ 100倍。并且protobuf 的设计具有更好的兼容性和扩展性。 2 编译安装 2.1 本机安装 注意 cmake 选项，其中 -DCMAKE_INSTALL_PREFIX 选项指定最后的编译结果安装目录，如果想全局使用，不指定即可。 12345678git clone https://github.com/protocolbuffers/protobuf.git -b v5.27.4cd protobufgit submodule update --init --recursivemkdir -p /cmake/build/releasecd cmake/build/releasecmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../../../install/release -Dprotobuf_BUILD_SHARED_LIBS=ON -Dprotobuf_WITH_ZLIB=OFF -Dprotobuf_BUILD_TESTS=OFF ../../.. make -j20make install 2.2 交叉编译 注意 cmake 选项，其中 -DCMAKE_SYSTEM_NAME, -DCMAKE_SYSTEM_PROCESSOR, -DCMAKE_C_COMPILER, -DCMAKE_CXX_COMPILER 指定目标平台相关的工具链。 12345678git clone https://github.com/protocolbuffers/protobuf.git -b v5.27.4cd protobufgit submodule update --init --recursivemkdir -p /cmake/build/releasecd cmake/build/releasecmake -G &quot;Unix Makefiles&quot; -DCMAKE_SYSTEM_NAME=Linux -DCMAKE_SYSTEM_PROCESSOR=armv7l -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc -DCMAKE_CXX_COMPILER=arm-linux-gnueabihf-g++ -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../../../install/release -Dprotobuf_BUILD_SHARED_LIBS=ON -Dprotobuf_WITH_ZLIB=OFF -Dprotobuf_BUILD_TESTS=OFF ../../.. make -j20make install 3 proto文件 .proto文件用于定义语言无关的消息结构，使用.proto文件时，需要先用 protobuf-compiler 将 .proto文件编译成语言相关的文件（如C++则生成 .pb.cc 和 .pb.h 文件），然后应用代码包含这些文件即可调用消息结构。 3.1 消息定义 12345678910111213141516171819202122syntax = &quot;proto2&quot;; //指定版本package tutorial; //添加域名message Person &#123; optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; optional string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 3.2 修饰符 required: 表示是一个必须字段。对于发送方，在发送消息时必须设置该字段的值；对于接收方，必须能够识别该字段的意思。由于required可能会导致兼容性问题，实际应用中比较少用。 optional：表示是一个可选字段。对于发送方，在发送消息时可以设置或者不设置该字段的值；对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段。由于optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。 repeated：表示是一个可重复字段，可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值，可以看作是在传递一个元素数组。 3.3 字段编码值 字段编码值表示该字段在二进制编码中使用的唯一 “标记”。标签号 1-15 比起更大数字需要少一个字节进行编码，因此可以用于标识常用或重复的元素。1900~2000 编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值。 3.4 数据类型 数据类型 描述 bool 布尔类型 double 64-bit 浮点数 float 32-bit 浮点数 int32 32-bit 整数 uin32 32-bit 无符号整数 int64 64-bit 整数 uint64 64-bit 无符号整数 sint32 32-bit 整数，处理负数效率更高 sing64 64-bit 整数，处理负数效率更高 fixed32 32-bit 无符号整数 fixed64 64-bit 无符号整数 sfixed32 32-bit 整数，处理负数效率更高 sfixed64 64-bit 整数，处理负数效率更高 string 字符串，只能处理 ASCII字符 bytes 用于处理多字节的语言字符、如中文 enum 枚举类型 message 可以包含一个用户自定义的消息类型 关于 fixed32 和int32的区别。fixed32的打包效率比int32的效率高，但是使用的空间一般比int32多。因此一个属于时间效率高，一个属于空间效率高。根据项目的实际情况，一般选择fixed32，如果遇到对传输数据量要求比较苛刻的环境，可以选择int32. 3.5 编译.proto 编译proto文件 1protoc --cpp_out=. example.proto 编译产生 example.pb.cc 和 example.pb.h 文件，以下是 example.pb.h 片段，可见protoc已经为我们生成字段的getter和setter函数。 123456789101112131415161718192021// optional string name = 1; bool has_name() const; void clear_name(); static const int kNameFieldNumber = 1; const ::std::string&amp; name() const; void set_name(const ::std::string&amp; value); #if LANG_CXX11 void set_name(::std::string&amp;&amp; value); #endif void set_name(const char* value); void set_name(const char* value, size_t size); ::std::string* mutable_name(); ::std::string* release_name(); void set_allocated_name(::std::string* name); // optional int32 id = 2; bool has_id() const; void clear_id(); static const int kIdFieldNumber = 2; ::google::protobuf::int32 id() const; void set_id(::google::protobuf::int32 value); 4 序列化/反序列化 我们使用protobuf最终是要将消息进行序列化和反序列化，用于消息传输或存储。protobuf提供了以下序列化和反序列化API： 123456789101112class MessageLite &#123;public: //序列化： bool SerializeToOstream(ostream* output) const; bool SerializeToArray(void *data, int size) const; bool SerializeToString(string* output) const; //反序列化： bool ParseFromIstream(istream* input); bool ParseFromArray(const void* data, int size); bool ParseFromString(const string&amp; data);&#125;; 以下列举序列化和反序列化的代码示例： 4.1 序列化 12345678910111213141516171819202122void serialize_process() &#123; cout &lt;&lt; &quot;serialize_process&quot; &lt;&lt; endl; tutorial::Person person; person.set_name(&quot;Obama&quot;); person.set_id(1234); person.set_email(&quot;1234@qq.com&quot;); tutorial::Person::PhoneNumber *phone1 = person.add_phones(); phone1-&gt;set_number(&quot;110&quot;); phone1-&gt;set_type(tutorial::Person::MOBILE); tutorial::Person::PhoneNumber *phone2 = person.add_phones(); phone2-&gt;set_number(&quot;119&quot;); phone2-&gt;set_type(tutorial::Person::HOME); fstream output(&quot;person_file&quot;, ios::out | ios::trunc | ios::binary); if( !person.SerializeToOstream(&amp;output) ) &#123; cout &lt;&lt; &quot;Fail to SerializeToOstream.&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;person.ByteSizeLong() : &quot; &lt;&lt; person.ByteSizLong() &lt;&lt; endl;&#125; 4.2 反序列化 12345678910111213141516171819202122232425262728293031void parse_process() &#123; cout &lt;&lt; &quot;parse_process&quot; &lt;&lt; endl; tutorial::Person result; fstream input(&quot;person_file&quot;, ios::in | ios::binary); if(!result.ParseFromIstream(&amp;input)) &#123; cout &lt;&lt; &quot;Fail to ParseFromIstream.&quot; &lt;&lt; endl; &#125; cout &lt;&lt; result.name() &lt;&lt; endl; cout &lt;&lt; result.id() &lt;&lt; endl; cout &lt;&lt; Buy and Sell Domain Names() &lt;&lt; endl; for(int i = 0; i &lt; result.phones_size(); ++i) &#123; const tutorial::Person::PhoneNumber &amp;person_phone = result.phones(i); switch(person_phone.type()) &#123; case tutorial::Person::MOBILE : cout &lt;&lt; &quot;MOBILE phone : &quot;; break; case tutorial::Person::HOME : cout &lt;&lt; &quot;HOME phone : &quot;; break; case tutorial::Person::WORK : cout &lt;&lt; &quot;WORK phone : &quot;; break; default: cout &lt;&lt; &quot;phone type err.&quot; &lt;&lt; endl; &#125; cout &lt;&lt; person_phone.number() &lt;&lt; endl; &#125;&#125; 4.3 应用代码 12345678#include &quot;example.pb.h&quot;int main(int argc, char *argv[]) &#123; serialize_process(); parse_process(); google::protobuf::ShutdownProtobufLibrary(); //删除所有已分配的内存（Protobuf使用的堆内存） return 0;&#125; g++编译时添加链接 -lprotobuf -lpthread 即可。 https://github.com/protocolbuffers/protobuf https://zhuanlan.zhihu.com/p/641283776","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"C++库","slug":"C-库","permalink":"https://xie-peiquan.gitee.io/tags/C-%E5%BA%93/"}]},{"title":"1-glog的使用","slug":"C++那些事/1-glog的使用","date":"2023-11-01T07:16:37.000Z","updated":"2025-05-14T02:14:15.240Z","comments":true,"path":"2023/11/01/C++那些事/1-glog的使用/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/11/01/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/1-glog%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1 软件包介绍 glog是google提供的一个轻量级C/C++日志库，提供日志文件记录管理等功能。 2 软件包安装 123456git clone https://github.com/google/glog.gitsudo apt install autoconf automake libtoolcd glog &amp;&amp; mkdir build &amp;&amp; cd buildcmake ..makesudo make install 3 软件包使用 3.1 初始化glog 12345678910#include &lt;glog/logging.h&gt;#include &lt;glog/raw_logging.h&gt;int main(int argc, char** argv)&#123; FLAGS_log_dir = &quot;~/logs&quot;; //日志保存目录，需要已存在 google::InitGoogleLogging(&quot;main&quot;); //括号内是程序名 ... google::ShutdownGoogleLogging(); //必要，防止内存溢出 return 0;&#125; 3.2 等级记录 12345VLOG(4) &lt;&lt; &quot;[DEBUG] &quot; &lt;&lt; ...LOG(INFO) &lt;&lt; ...LOG(WARNING) &lt;&lt; ...LOG(ERROR) &lt;&lt; ...LOG(FATAL) &lt;&lt; ... 3.3 条件记录 12LOG_IF(INFO, cond) &lt;&lt; ...LOG_IF(ERROR, cond) &lt;&lt; ... 3.4 频次记录 123LOG_EVERY_N(INFO, freq) //每隔freq次记录一次LOG_EVERY_N(WARNING, freq)LOG_EVERY_N(ERROR, freq) 3.5 扩展参数 12345678FLAGS_logtostderr = true; //设置日志消息是否转到标准输出而不是日志文件FLAGS_alsologtostderr = true; //设置日志消息除了日志文件之外是否输出到标准输出FLAGS_colorlogtostderr = true; //设置记录到标准输出的颜色消息（如果终端支持）FLAGS_log_prefix = true; //设置日志前缀是否应该添加到每行输出FLAGS_logbufsecs = 0; //设置可以缓冲日志的最大秒数，0指实时输出FLAGS_max_log_size = 10; //设置最大日志文件大小（以MB为单位）,超过会对文件进行分割FLAGS_stop_logging_if_full_disk = true; //设置是否在磁盘已满时避免日志记录到磁盘FLAGS_minloglevel = google::GLOG_WARNING； //设置最小处理日志的级别 3.6 扩展函数 123google::SetLogDestination(google::GLOG_FATAL, &quot;~/logs/FATAL_&quot;); //FATAL级别的日志都存放到logs目录下且前缀为FATAL_google::SetLogFilenameExtension(&quot;logExtension&quot;); //在日志文件名中级别后添加一个扩展名,适用于所有严重级别google::SetStderrLogging(google::GLOG_INFO); //大于指定级别的日志都输出到标准输出 4 应用编译 g++ 编译添加链接 -lglog 即可。 https://github.com/google/glog https://www.cnblogs.com/xl2432/p/11825966.html","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"C++库","slug":"C-库","permalink":"https://xie-peiquan.gitee.io/tags/C-%E5%BA%93/"}]},{"title":"0-Gflags的使用","slug":"C++那些事/0-Gflags的使用","date":"2023-11-01T03:07:43.000Z","updated":"2025-05-14T02:14:15.244Z","comments":true,"path":"2023/11/01/C++那些事/0-Gflags的使用/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/11/01/C++%E9%82%A3%E4%BA%9B%E4%BA%8B/0-Gflags%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1 软件包介绍 Gflags是一种命令行解析工具(处理命令行参数的库)，主要用于C++程序 解析用命令行执行可执行文件时传入的参数。 Gflags支持的参数定义类型如下: 123456DEFINE_bool: booleanDEFINE_int32: 32-bit integerDEFINE_int64: 64-bit integerDEFINE_uint64: unsigned 64-bit integerDEFINE_double: doubleDEFINE_string: C++ string 2 编译安装 12345git clone https://github.com/gflags/gflags.gitmkdir build &amp;&amp; cd buildcmake ..makemake install 2.1 交叉编译 12345678mkdir build &amp;&amp; cd buildcmake .. \\-DGFLAGS_NAMESPACE=gflags \\-DCMAKE_CXX_FLAGS=-fPIC \\-DBUILD_SHARED_LIBS=ON \\-DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc \\-DCMAKE_CXX_COMPILER=arm-linux-gnueabihf-g++make -j20 3 软件包使用 3.1 参数变量定义/声明 参数定义通过DEFINE_type宏实现，具体接口见 第1节，使用如下： 12//该宏的三个参数含义分别为：参数名，默认值，参数的帮助信息。DEFINE_bool(big_menu, true, &quot;Include &#x27;advanced&#x27; options in the menu listing&quot;); 参数声明通过 DECLARE_type宏实现，即将 第1节 的 DEFINE_ 改为 DECLARE_，一般将 DECLARE_type 放在头文件中。 1DECLARE_bool(big_menu) 运行程序时使用 ./app --port 17201 即可设置参数。 3.2 参数引用 参数引用通过在参数名前添加 FLAGS_ 引用，如：FLAGS_big_menu . 3.3 参数解析 参数解析一般放置于main函数入口对argc和argv 进行解析，使用如下： 12345678#include &lt;gflags/gflags.h&gt;int main(int argc, char** argv)&#123; gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true); ...... gflags::ShutDownCommandLineFlags(); return 0;&#125; 其中，argc 传递的参数个数，argv为命令行传递的参数表，第三个参数功能如下 ture: 函数处理完成后，argv中只保留argv[0]，argc会被设置为1。 false: argv和argc会被保留，但是注意函数会调整argv中的顺序。 3.4 参数检验 Gflags库支持用户定制对输入参数的检验函数，使用如下： 12345678static bool ValidatePort(const char* flagname, int32 value) &#123; if (value &gt; 0 &amp;&amp; value &lt; 32768) // value is ok return true; printf(&quot;Invalid value for --%s: %d\\n&quot;, flagname, (int)value); return false;&#125;DEFINE_int32(port, 0, &quot;What port to listen on&quot;);static const bool port_dummy = gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort); 3.5 设定程序 help /version 信息 12gflags::SetVersionString(string_type);gflags::SetUsageMessage(string_type); 运行程序时使用 ./app --version 和 ./app --help 即可访问版本和帮助信息。 注意，对于bool类型置为false, 在参数前面添加no, 如 --nobig_menu 3.6 从文件加载参数 配置文件 app.conf 配置信息格式如下： 123--host=172.16.12.10--port=8955--sign=false 运行程序时使用 ./app --flagfile=app.conf 来加载参数文件。 4 程序编译 g++ 编译添加链接 -lgflags 即可。 https://gflags.github.io/gflags https://blog.csdn.net/kenjianqi1647/article/details/106598057","categories":[{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"C++库","slug":"C-库","permalink":"https://xie-peiquan.gitee.io/tags/C-%E5%BA%93/"}]},{"title":"11-发布ROS功能包","slug":"ROS1/11-发布ROS功能包","date":"2023-09-19T06:59:50.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/09/19/ROS1/11-发布ROS功能包/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/19/ROS1/11-%E5%8F%91%E5%B8%83ROS%E5%8A%9F%E8%83%BD%E5%8C%85/","excerpt":"","text":"当我们开发完某个功能包，要将功能包发布出去。如果是带源码发布，直接将工作空间下 src 目录下的整个功能包源码直接拷贝出去，重新编译运行即可。有时候我们不想公开源码，希望不带源码发布，怎么处理呢？ROS提供了相关的工具支持，具体如下： 1 catkin_make install 1.1 修改CMakeLists 在功能包下的CMakeLists文件里，找到以下项进行修改： 将编译好的可执行文件，依赖库拷贝到 install 的 lib/ 和 bin/ 目录下： 123456## Mark executables and/or libraries for installation install(TARGETS talker_node listener_node ARCHIVE DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125; LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125; RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125; ) 将头文件拷贝到 install 的 include/ 目录下，非必要。 123456## Mark cpp header files for installation install(DIRECTORY include/$&#123;PROJECT_NAME&#125;/ DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125; FILES_MATCHING PATTERN &quot;*.h&quot; PATTERN &quot;.svn&quot; EXCLUDE ) 将其他资源文件拷贝到 install 的share/ 目录下，如 urdf mesh rviz ，其下的所有子目录的文件也会拷贝过去，非必要。 123456789101112install(DIRECTORY model DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125; )install(DIRECTORY urdf DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125; )install(DIRECTORY mesh DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125; )install(DIRECTORY rviz DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125; ) 将 launch 文件拷贝到 install 的 launch/ 目录下，非必要。 123456## Mark other files for installation (e.g. launch and bag files, etc.)install(FILES launch/bringup.launch DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;/launch) 将 python 脚本拷贝到 install 的 lib/ 目录下，非必要。 遗憾的是，ROS并未对发布的 python 脚本进行任何加密，哪怕是转成 pyc 文件，所以用 C++ 写吧哈哈… 当然也并非没有其他方法，可以借助 pyinstaller 工具把 python 脚本打包（pyinstaller -F -w xxx.py）成可执行文件，放到 install 的 lib/ 目录下，我初步验证是可以的。当然 pyinstaller 本身也并不安全，关于python源码的保护，或许还有其他方法？ 123456## Mark executable scripts (Python etc.) for installation install(PROGRAMS scripts/talker.py scripts/listener.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125; ) 1.2 生成 install 目录 在工作空间下执行 catkin_make install 则会生成 install 目录，目录内容如下。发布后 source 该目录下的 setup.bash 便可以运行。当然运行的前提是同处理器架构，不同处理器架构得用交叉编译，后续再补一节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465install├── _setup_util.py├── env.sh├── include│ └── learning_service│ ├── Person.h│ ├── PersonRequest.h│ └── PersonResponse.h├── lib│ ├── learning_service│ │ ├── person_client│ │ ├── person_server│ │ ├── turtle_command_server│ │ └── turtle_spawn│ ├── pkgconfig│ │ └── learning_service.pc│ └── python3│ └── dist-packages│ └── learning_service│ ├── __init__.py│ ├── __pycache__│ │ └── __init__.cpython-38.pyc│ └── srv│ ├── _Person.py│ ├── __init__.py│ └── __pycache__│ ├── _Person.cpython-38.pyc│ └── __init__.cpython-38.pyc├── local_setup.bash├── local_setup.sh├── local_setup.zsh├── setup.bash├── setup.sh├── setup.zsh└── share ├── common-lisp │ └── ros │ └── learning_service │ └── srv │ ├── Person.lisp │ ├── _package.lisp │ ├── _package_Person.lisp │ └── learning_service-srv.asd ├── gennodejs │ └── ros │ └── learning_service │ ├── _index.js │ └── srv │ ├── Person.js │ └── _index.js ├── learning_service │ ├── cmake │ │ ├── learning_service-msg-extras.cmake │ │ ├── learning_service-msg-paths.cmake │ │ ├── learning_serviceConfig-version.cmake │ │ └── learning_serviceConfig.cmake │ ├── package.xml │ └── srv │ └── Person.srv └── roseus └── ros └── learning_service ├── manifest.l └── srv └── Person.l 2 bloom-generate 从上节可以发现 catkin_make install 生成出来的 install 目录很庞大，有很多冗余的文件。并且以那种形式发布出去的功能包，每次运行都得 source 一下，有没有办法让我们的功能包安装进ROS的系统目录呢？ bloom-generate 提供了更简单的方法，其将源码编译成一个ROS的二进制安装包，安装时将可执行文件等必要文件注入到ROS系统目录下，在功能包的管理上更方便，具体如下： 2.1 修改CMakeLists 由于bloom-generate 同样借助 catkin 编译，因此我们同样需要修改 CMakeLists 文件，步骤跟以上一模一样，这里不再赘述。 2.2 编译二进制安装包 1234安装工具：sudo apt install python-bloom fakerootcd 到功能包目录下，运行以下命令：bloom-generate rosdebian --os-name ubuntu --ros-distro noeticfakeroot debian/rules binary 2.3 安装与卸载 12sudo apt install ros-noetic-xxxx.debsudo apt remove ros-noetic-xxxx 3 遗留问题 以上两种方式发布功能包还是有问题，暂且把它记下来，等搞明白了再做更新。 如果需要不对 python 开源，如何保护？ 自定义的 msg , srv, action 接口都会跟着发布出去，如果不开源，如何保护？ http://wiki.ros.org/cn/ROS/Tutorials","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"10-动态参数机制简汇","slug":"ROS1/10-动态参数机制简汇","date":"2023-09-18T09:16:20.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/09/18/ROS1/10-动态参数机制简汇/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/18/ROS1/10-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 动态参数的作用 ​ ROS中的参数服务器无法在线动态更新，也就是说如果Listener不主动查询参数值，就无法获知Talker是否已经修改了参数。这就对ROS参数服务器的使用造成了很大的局限，很多场景下我们还是需要动态更新参数的机制，例如参数调试、功能切换等，所以ROS提供了另外一个非常有用的功能包 —— dynamic_reconfigure，实现这种动态配置参数的机制。 ​ 动态重配置的重点是提供一种标准的方法，将节点的一个子集参数公开给外部重配置。使用客户端程序，例如gui，可以向节点查询一组可动态配置的参数，包括它们的名称、类型、范围，并向用户提供一个自定义接口。 ​ 以下介绍如何给功能包添加动态参数。 2 添加动态参数 2.1 添加 cfg 文件 在功能包下新建 cfg 目录，并新建 cfg 文件（其实是python脚本），记得给 cfg 文件添加可执行权限。这里以典型的pid.cfg文件为例，内容如下： 1234567891011121314151617#!/usr/bin/env pythonPACKAGE = &quot;learning_topic&quot; #所属功能包名 #初始化ROS，并导入参数生成器from dynamic_reconfigure.parameter_generator_catkin import *#初始化参数生成器gen = ParameterGenerator()#定义需动态配置的参数，格式为#gen.add(name , type, level, description, default, min, max)gen.add(&quot;KP&quot;, double_t, 0, &quot;KP_param&quot;, 225.0, 0, 500)gen.add(&quot;KI&quot;, double_t, 0, &quot;KI_param&quot;, 150.0, 0, 300)gen.add(&quot;KD&quot;, double_t, 0, &quot;KD_param&quot;, 50.0, 0, 300)#生成必要文件并退出#dynamic_PID为运行时的节点名，pid为生成文件的前缀exit(gen.generate(PACKAGE, &quot;dynamic_PID&quot;, &quot;pid&quot;)) 参数解释： gen.add(name , type, level, description, default, min, max) – name：参数名，使用字符串描述； – type：定义参数的类型，可以是int_t, double_t, str_t, 或者bool_t； – level：需要传入参数动态配置回调函数中的掩码，在回调函数中会修改所有参数的掩码，表示参数已经进行修改； – description：描述参数作用的字符串； – default：设置参数的默认值； – min：可选，设置参数的最小值，对于字符串和布尔类型值不生效； – max：可选，设置参数的较大值，对于字符串和布尔类型值不生效； gen.generate(PACKAGE, &quot;dynamic_PID&quot;, &quot;pid&quot;) dynamic_PID：为运行时的节点名。 pid：为生成文件的前缀，如pidConfig，该前缀需要与配置文件名相同。 补python版本： 123456789101112131415161718#! /usr/bin/env pythonimport rospyfrom dynamic_reconfigure.server import Serverfrom learning_topic.cfg import pidConfigdef dp_callback(config,level): rospy.loginfo(&quot;Reconfigure Request:%d %d %d&quot;, config.KP, config.KI, config.KD ) return configif __name__ == &quot;__main__&quot;: rospy.init_node(&quot;pid_app&quot;) server = Server(pidConfig, dp_callback) rospy.loginfo(&quot;Spinning node&quot;) rospy.spin() 2.2 编译修改 cmake修改：在CmakeLists找到如下项进行修改： 12generate_dynamic_reconfigure_options(... cfg/pid.cfg)find_package(... dynamic_reconfigure) catkin_make 后便可在devel/include 目录下发现 pidConfig.h 头文件. 3 应用节点编写 3.1 添加动态参数应用节点 在功能包 src 目录下新增 pid_app.cpp 文件，内容如下： 1234567891011121314151617181920212223242526272829#include &lt;ros/ros.h&gt;#include &lt;dynamic_reconfigure/server.h&gt;#include &lt;learning_topic/pidConfig.h&gt;//定义回调函数，当客户端请求修改参数时，服务端即可跳转到回调函数中进行处理。//传入值有两个，一个是参数更新的配置值，一个是表示参数修改的掩码void callback(learning_topic::pidConfig &amp;config, uint32_t level) &#123; ROS_INFO(&quot;Reconfigure Request: %f %f %f&quot;, config.KP, config.KI, config.KD);&#125;int main(int argc, char **argv)&#123; //初始化ROS节点 ros::init(argc, argv, &quot;pid_app&quot;); //创建了一个参数动态配置的服务端实例，参数配置的类型就是配置文件中描述的类型 //该服务端实例会监听客户端的参数配置请求。 dynamic_reconfigure::Server&lt;learning_topic::pidConfig&gt; server; dynamic_reconfigure::Server&lt;learning_topic::pidConfig&gt;::CallbackType f; //并将回调函数和服务端绑定 f = boost::bind(&amp;callback, _1, _2); server.setCallback(f); ROS_INFO(&quot;Spinning node&quot;); ros::spin(); return 0;&#125; 3.2 编译修改 cmake修改：在CmakeLists末尾添加如下修改： 123add_executable(pid_app src/pid_app.cpp)target_link_libraries(pid_app $&#123;catkin_LIBRARIES&#125;)add_dependencies(pid_app $&#123;PROJECT_NAME&#125;_gencfg) 3.3 GUI动态调参 123终端1：roscore终端2：rosrun learning_topic pid_app终端3：rosrun rqt_reconfigure rqt_reconfigure 效果如下： http://wiki.ros.org/cn/ROS/Tutorials https://blog.csdn.net/weixin_43569276/article/details/102928817","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"9-action通信机制简汇","slug":"ROS1/9-action通信机制简汇","date":"2023-09-15T09:12:07.000Z","updated":"2025-05-14T02:14:15.308Z","comments":true,"path":"2023/09/15/ROS1/9-action通信机制简汇/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/15/ROS1/9-action%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"action实现了一种类似于service的请求/响应通讯机制，区别在于action带有反馈机制，用来不断向客户端反馈任务的进度，并且还支持在任务中途中止运行。操作起来就像这样子，客户端给服务端抛出一个目标，然后客户端就可以去干别的事情了，在任务执行期间，客户端会以消息的形式，周期性地接收到来自服务端的进度反馈，如果没有终止任务的话这个过程会一直延续到收到最终的结果。当然也可以随时终止当前的操作，开始一个全新的操作。 1 action的实现机制 action 的 client和server之间通过actionlib定义的“action protocol”进行通讯。这种通讯协议是基于ROS的 topic 机制实现的，为用户提供了client和server的接口，接口如下图所示： goal：client 发送任务目标 cancel：client 请求取消任务 status：server通知client当前的状态 feedback：server周期反馈任务运行的监控数据 result：server向client发送任务的执行结果，这个topic只会发布一次。 2 自定义接口 2.1 action文件编写 在 ros_ws/src/hello/action目录下创建 DoDishes.action接口文件，注意首字母必须大写。接口示例如下： 12345678# Define the goaluint32 dishwasher_id---# Define the resultuint32 total_dishes_cleaned---# Define a feedback messagefloat32 percent_complete 2.2 编译修改 CMakeLists修改：在对应位置进行如下修改：(查找对应项改，不要改变各项的顺序) 123find_package(catkin REQUIRED ... genmsg actionlib_msgs actionlib)add_action_files(DIRECTORY action FILES DoDishes.action)generate_messages(DEPENDENCIES ... actionlib_msgs) package.xml修改：在对应位置添加如下： 1234&lt;build_depend&gt;actionlib&lt;/build_depend&gt;&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;&lt;exec_depend&gt;actionlib&lt;/exec_depend&gt;&lt;exec_depend&gt;actionlib_msgs&lt;/exec_depend&gt; 编译完成之后会在 devel/share/hello/msg/ 目录下产生相关的.msg文件： 2 action Client（CPP） 注意要将**DoDishesAction **的前缀修改为自己创建的功能包名字。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;actionlib/client/simple_action_client.h&gt;#include &quot;hello/DoDishesAction.h&quot;typedef actionlib::SimpleActionClient&lt;hello::DoDishesAction&gt; Client;// 当action完成后会调用次回调函数一次void doneCb(const actionlib::SimpleClientGoalState&amp; state, const hello::DoDishesResultConstPtr&amp; result)&#123; ROS_INFO(&quot;Yay! The dishes are now clean&quot;); ros::shutdown();&#125;// 当action激活后会调用次回调函数一次void activeCb()&#123; ROS_INFO(&quot;Goal just went active&quot;);&#125;// 收到feedback后调用的回调函数void feedbackCb(const hello::DoDishesFeedbackConstPtr&amp; feedback)&#123; ROS_INFO(&quot; percent_complete : %f &quot;, feedback-&gt;percent_complete);&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;do_dishes_client&quot;); // 定义一个客户端 Client client(&quot;do_dishes&quot;, true); // 等待服务器端 ROS_INFO(&quot;Waiting for action server to start.&quot;); client.waitForServer(); ROS_INFO(&quot;Action server started, sending goal.&quot;); // 创建一个action的goal hello::DoDishesGoal goal; goal.dishwasher_id = 1; // 发送action的goal给服务器端，并且设置回调函数 client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb); ros::spin(); return 0;&#125; 3 action Client（Python） 123456789101112131415161718#! /usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;my_pkg_name&#x27;)import rospyimport actionlibfrom chores.msg import DoDishesAction, DoDishesGoalif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;do_dishes_client&#x27;) client = actionlib.SimpleActionClient(&#x27;do_dishes&#x27;, DoDishesAction) client.wait_for_server() goal = DoDishesGoal() # Fill in the goal here client.send_goal(goal) client.wait_for_result(rospy.Duration.from_sec(5.0)) 4 action Server（CPP） 123456789101112131415161718192021222324252627282930313233343536#include &lt;ros/ros.h&gt;#include &lt;actionlib/server/simple_action_server.h&gt;#include &quot;hello/DoDishesAction.h&quot;typedef actionlib::SimpleActionServer&lt;hello::DoDishesAction&gt; Server;// 收到action的goal后调用的回调函数void execute(const hello::DoDishesGoalConstPtr&amp; goal, Server* as)&#123; ros::Rate r(1); hello::DoDishesFeedback feedback; ROS_INFO(&quot;Dishwasher %d is working.&quot;, goal-&gt;dishwasher_id); // 假设洗盘子的进度，并且按照1hz的频率发布进度feedback for(int i=1; i&lt;=10; i++) &#123; feedback.percent_complete = i * 10; as-&gt;publishFeedback(feedback); r.sleep(); &#125; // 当action完成后，向客户端返回结果 ROS_INFO(&quot;Dishwasher %d finish working.&quot;, goal-&gt;dishwasher_id); as-&gt;setSucceeded();&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;do_dishes_server&quot;); ros::NodeHandle n; // 定义一个服务器 Server server(n, &quot;do_dishes&quot;, boost::bind(&amp;execute, _1, &amp;server), false); // 服务器开始运行 server.start(); ros::spin(); return 0;&#125; 5 action Server（Python） 1234567891011121314151617181920212223#! /usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;my_pkg_name&#x27;)import rospyimport actionlibfrom chores.msg import DoDishesActionclass DoDishesServer: def __init__(self): self.server = actionlib.SimpleActionServer(&#x27;do_dishes&#x27;, DoDishesAction, self.execute, False) self.server.start() def execute(self, goal): # Do lots of awesome groundbreaking robot stuff here self.server.set_succeeded()if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;do_dishes_server&#x27;) server = DoDishesServer() rospy.spin() http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"8-坐标变换TF简述","slug":"ROS1/8-坐标变换TF简述","date":"2023-09-15T03:16:23.000Z","updated":"2025-05-14T02:14:15.308Z","comments":true,"path":"2023/09/15/ROS1/8-坐标变换TF简述/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/15/ROS1/8-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2TF%E7%AE%80%E8%BF%B0/","excerpt":"","text":"在一个机器人系统中，一般会存在多个部件，每个部件可能会有自己的运动轨迹，这样在一个机器人中就存在多个坐标系。通常，我们会根据坐标系间的差距来驱动某个部件的运动，这里就存在坐标变换。这里简单举例，如下图(古月居)，我们常见的ROS小车激光雷达测距，假设这里只存在车身和雷达两个部件，这里有两个坐标系：车身坐标系（base_link）和雷达坐标系（base_laser）。雷达测距的结果是墙面相对于雷达坐标系的距离，而通常我们需要车身相对于墙面的距离，这里就需要将雷达距离转换为车身距离。 1 TF 功能包 ROS中的TF功能包为我们提供坐标变换功能，可以帮助我们免去复杂的坐标转换。以下为TF常用命令： rosrun tf tf_echo node1 node2 该命令可用于查看两个坐标系之间的差距。 rosrun rviz rviz -d 'rospack find turtle_tf' /rviz/turtle_rviz.rviz 可视化坐标系之间的关系。 2 坐标系广播（CPP） 1234567891011121314151617181920212223242526272829303132#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;#include &lt;turtlesim/Pose.h&gt;std::string turtle_name;void poseCallback(const turtlesim::PoseConstPtr&amp; msg)&#123; // 创建tf的广播器 static tf::TransformBroadcaster br; // 初始化tf数据 tf::Transform transform; transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) ); tf::Quaternion q; q.setRPY(0, 0, msg-&gt;theta); transform.setRotation(q); // 广播world与海龟坐标系之间的tf数据 br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;world&quot;, turtle_name));&#125;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_broadcaster&quot;); turtle_name = argv[1]; // 订阅海龟的位姿话题 ros::NodeHandle node; ros::Subscriber sub = node.subscribe(turtle_name+&quot;/pose&quot;, 10, &amp;poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125;; cmake修改，在CMakeLists里面找到以下项并修改： 1234567find_package(catkin REQUIRED COMPONENTS ...... tf turtlesim)add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)target_link_libraries(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;) 3 坐标系广播（Python） 12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport tfimport turtlesim.msgdef handle_turtle_pose(msg, turtlename): br = tf.TransformBroadcaster() br.sendTransform((msg.x, msg.y, 0), tf.transformations.quaternion_from_euler(0, 0, msg.theta), rospy.Time.now(), turtlename, &quot;world&quot;)if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_broadcaster&#x27;) turtlename = rospy.get_param(&#x27;~turtle&#x27;) rospy.Subscriber(&#x27;/%s/pose&#x27; % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename) rospy.spin() 4 坐标系监听（CPP） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_listener&quot;); // 创建节点句柄 ros::NodeHandle node; // 请求产生turtle2 ros::service::waitForService(&quot;/spawn&quot;); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); turtlesim::Spawn srv; add_turtle.call(srv); // 创建发布turtle2速度控制指令的发布者 ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle2/cmd_vel&quot;, 10); // 创建tf的监听器 tf::TransformListener listener; ros::Rate rate(10.0); while (node.ok()) &#123; // 获取turtle1与turtle2坐标系之间的tf数据 tf::StampedTransform transform; try &#123; listener.waitForTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), ros::Duration(3.0)); listener.lookupTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), transform); &#125; catch (tf::TransformException &amp;ex) &#123; ROS_ERROR(&quot;%s&quot;,ex.what()); ros::Duration(1.0).sleep(); continue; &#125; // 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令 geometry_msgs::Twist vel_msg; vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(), transform.getOrigin().x()); vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) + pow(transform.getOrigin().y(), 2)); turtle_vel.publish(vel_msg); rate.sleep(); &#125; return 0;&#125;; 5 坐标系监听（Python） 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport mathimport tfimport geometry_msgs.msgimport turtlesim.srvif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_listener&#x27;) listener = tf.TransformListener() rospy.wait_for_service(&#x27;spawn&#x27;) spawner = rospy.ServiceProxy(&#x27;spawn&#x27;, turtlesim.srv.Spawn) spawner(4, 2, 0, &#x27;turtle2&#x27;) turtle_vel = rospy.Publisher(&#x27;turtle2/cmd_vel&#x27;, geometry_msgs.msg.Twist,queue_size=1) rate = rospy.Rate(10.0) while not rospy.is_shutdown(): try: (trans,rot) = listener.lookupTransform(&#x27;/turtle2&#x27;, &#x27;/turtle1&#x27;, rospy.Time(0)) except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException): continue angular = 4 * math.atan2(trans[1], trans[0]) linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2) cmd = geometry_msgs.msg.Twist() cmd.linear.x = linear cmd.angular.z = angular turtle_vel.publish(cmd) rate.sleep() http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"7-launch启动节点","slug":"ROS1/7-launch启动节点","date":"2023-09-14T16:46:30.000Z","updated":"2025-05-14T02:14:15.292Z","comments":true,"path":"2023/09/15/ROS1/7-launch启动节点/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/15/ROS1/7-launch%E5%90%AF%E5%8A%A8%E8%8A%82%E7%82%B9/","excerpt":"","text":"1 基本语法 &lt;launch&gt; launch文件中的根元素采用&lt;launch&gt;标签定义 &lt;node&gt; 启动节点，格式： 1&lt;node pkg=&quot;package-name&quot; name=&quot;node-name&quot; type=&quot;exec-name&quot;/&gt; 其中，pkg 是节点所在功能包名称，type是节点的可执行文件名称，name是节点运行时名称，可取代源码中的节点名。除此之外，还有output参数，可控制日志是否打印在终端里面；respawn可以控制节点如果挂掉是否要重新拉起；required可以控制某个节点是否要启动；ns可以给节点添加域名空间；args可以给节点输入参数。 &lt;param&gt; / &lt;rosparam&gt; 设置ROS系统运行中的参数，存储在参数服务器中。格式： 12设置某个值形式：&lt;param name=&quot;output_frame&quot; value=&quot;odom&quot;/&gt;加载参数文件形式：&lt;rosparam file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; 注：写在&lt;node&gt;里面的 param 其在参数服务器的名字为 node-name/param-name,多了node-name的前缀。 &lt;arg&gt; launch文件内部的局部变量，仅限于launch文件使用，格式： 1234&lt;arg name=&quot;arg-name&quot; default=&quot;arg-value&quot;/&gt;调用：&lt;param name=&quot;foo&quot; value=&quot;$(arg arg-name)&quot;/&gt;&lt;node pkg=&quot;package-name&quot; name=&quot;node-name&quot; type=&quot;exec-name&quot; args=&quot;$(arg arg-name)&quot;/&gt; &lt;remap&gt; 重映射ROS计算图资源的命名，格式： 1&lt;remap from=&quot;/turtlebot/cmd_vel&quot; to=&quot;/cmd_vel&quot;/&gt; &lt;include&gt; 包含其他 launch 文件，类似C语言中的头文件包含，格式： 1&lt;include file=&quot;$(dirname)/other.launch&quot;/&gt; 2 创建 launch 文件 在 ros_ws/src/hello/launch 目录下创建 simple.launch文件。 1234&lt;launch&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_subscriber&quot; name=&quot;talker&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_publisher&quot; name=&quot;listener&quot; output=&quot;screen&quot; /&gt; &lt;/launch&gt; 3 运行 launch文件 1234cd ros_wscatkin_makesource devel/setup.bashroslaunch &lt;pack-name&gt; &lt;launch-name&gt;","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"6-param通信机制简汇","slug":"ROS1/6-param通信机制简汇","date":"2023-09-14T09:46:29.000Z","updated":"2025-05-14T02:14:15.292Z","comments":true,"path":"2023/09/14/ROS1/6-param通信机制简汇/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/14/ROS1/6-param%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 全局参数模型 1.1 全局参数配置（CPP） 1234567891011121314151617181920212223242526272829#include &lt;string&gt;#include &lt;ros/ros.h&gt;#include &lt;std_srvs/Empty.h&gt;int main(int argc, char **argv)&#123; int red, green, blue; // ROS节点初始化 ros::init(argc, argv, &quot;parameter_config&quot;); // 创建节点句柄 ros::NodeHandle node; // 读取背景颜色参数 ros::param::get(&quot;/background_r&quot;, red); ros::param::get(&quot;/background_g&quot;, green); ros::param::get(&quot;/background_b&quot;, blue); ROS_INFO(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue); // 设置背景颜色参数 ros::param::set(&quot;/background_r&quot;, 255); ros::param::set(&quot;/background_g&quot;, 255); ros::param::set(&quot;/background_b&quot;, 255); ROS_INFO(&quot;Set Backgroud Color[255, 255, 255]&quot;); // 调用服务，刷新背景颜色 ros::service::waitForService(&quot;/clear&quot;); ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(&quot;/clear&quot;); std_srvs::Empty srv; clear_background.call(srv); sleep(1); return 0;&#125; 1.2 全局参数配置（Python） 与CPP类似，只是API稍微不同，get / set接口如下： 12red = rospy.get_param(&#x27;/background_r&#x27;)rospy.set_param(&quot;/background_r&quot;, 255)","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"5-service通信机制简汇","slug":"ROS1/5-service通信机制简汇","date":"2023-09-14T08:26:35.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/09/14/ROS1/5-service通信机制简汇/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/14/ROS1/5-service%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 Client（CPP） 123456789101112131415161718192021222324252627#include &lt;ros/ros.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;turtle_spawn&quot;); // 创建节点句柄 ros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service（阻塞） ros::service::waitForService(&quot;/spawn&quot;); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); // 初始化turtlesim::Spawn的请求数据 turtlesim::Spawn srv; srv.request.x = 2.0; srv.request.y = 2.0; srv.request.name = &quot;turtle2&quot;; // 请求服务调用 ROS_INFO(&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;, srv.request.x, srv.request.y, srv.request.name.c_str()); //同步阻塞 add_turtle.call(srv); // 显示服务调用结果 ROS_INFO(&quot;Spwan turtle successfully [name:%s]&quot;, srv.response.name.c_str()); return 0;&#125;; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(turtle_spawn src/turtle_spawn.cpp)target_link_libraries(turtle_spawn $&#123;catkin_LIBRARIES&#125;) 2 Client（Python） 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-import sysimport rospyfrom turtlesim.srv import Spawn if __name__ == &quot;__main__&quot;: # ROS节点初始化 rospy.init_node(&#x27;turtle_spawn&#x27;) # 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/spawn&#x27;) try: add_turtle = rospy.ServiceProxy(&#x27;/spawn&#x27;, Spawn) # 请求服务调用，输入请求数据 # 也可以调用 add_turtle.call() response = add_turtle(2.0, 2.0, 0.0, &quot;turtle2&quot;) return response.name except rospy.ServiceException as e: print (&quot;Service call failed: %s&quot;%e) cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/turtle_spawn.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 3 Server（CPP） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;std_srvs/Trigger.h&gt;// service回调函数，输入参数req，输出参数resbool commandCallback(std_srvs::Trigger::Request &amp;req, std_srvs::Trigger::Response &amp;res)&#123; // 设置反馈数据 res.success = true; res.message = &quot;Change turtle command state!&quot;; return true;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;turtle_command_server&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/turtle_command的server，注册回调函数commandCallback ros::ServiceServer command_service = n.advertiseService(&quot;/turtle_command&quot;, commandCallback); // 循环等待回调函数 ROS_INFO(&quot;Ready to receive turtle command.&quot;); // 设置循环的频率 ros::Rate loop_rate(10); while(ros::ok()) &#123; // 查看一次回调函数队列 ros::spinOnce(); // 业务代码..... //按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(turtle_command_server src/turtle_command_server.cpp)target_link_libraries(turtle_command_server $&#123;catkin_LIBRARIES&#125;) 4 Server（Python） 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyimport thread,timefrom std_srvs.srv import Trigger, TriggerResponsedef command_thread(): while True: if pubCommand: vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 turtle_vel_pub.publish(vel_msg) time.sleep(0.1)def commandCallback(req): global pubCommand pubCommand = bool(1-pubCommand) # 显示请求数据 rospy.loginfo(&quot;Publish turtle velocity command![%d]&quot;, pubCommand) # 反馈数据 return TriggerResponse(1, &quot;Change turtle command state!&quot;)if __name__ == &quot;__main__&quot;: # ROS节点初始化 rospy.init_node(&#x27;turtle_command_server&#x27;) # 创建一个名为/turtle_command的server，注册回调函数commandCallback s = rospy.Service(&#x27;/turtle_command&#x27;, Trigger, commandCallback) # 循环等待回调函数 print &quot;Ready to receive turtle command.&quot; # 由于python没有spinOnce()接口，因此新启一个线程 thread.start_new_thread(command_thread, ()) rospy.spin() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/turtle_command_server.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 5 自定义接口 5.1 srv文件编写 在 ros_ws/src/hello/srv目录下创建 Person.srv 接口文件，注意首字母必须大写。接口示例如下： 12345string nameuint8 ageuint8 sex---string result 接口中，— 以上为request内容，以下为response内容。 编译修改： CMakeLists修改：在对应位置进行如下修改： 1234find_package(...... message_generation)add_message_files(FILES Person.srv)generate_messages(DEPENDENCIES std_msgs)catkin_package(...... message_runtime) package.xml修改：在对应位置添加如下： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 自定义接口需经过编译形成C++和Python的引用文件，可以在devel/include里面找到C++所需的.h接口文件。 5.2 C/S代码编写 Client / Server 代码与前几节几乎一模一样，这里不再赘述。 编译修改： 由于应用代码对接口产生依赖，因此在编译应用代码时，也应添加相应的依赖（Python不需要）： 1add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp) http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"4-topic通信机制简汇","slug":"ROS1/4-topic通信机制简汇","date":"2023-09-13T08:26:35.000Z","updated":"2025-05-14T02:14:15.292Z","comments":true,"path":"2023/09/13/ROS1/4-topic通信机制简汇/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/13/ROS1/4-topic%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 Publisher（CPP） 12345678910111213141516171819202122232425262728#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;publisher&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 ros::Publisher = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10); // 设置循环的频率 ros::Rate loop_rate(10); while (ros::ok()) &#123; // 初始化geometry_msgs::Twist类型的消息 geometry_msgs::Twist vel_msg; vel_msg.linear.x = 0.5; vel_msg.angular.z = 0.2; // 发布消息 turtle_vel_pub.publish(vel_msg); ROS_INFO(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z); // 按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(publisher src/publisher.cpp)target_link_libraries(publisher $&#123;catkin_LIBRARIES&#125;) 2 Publisher（Python） 123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom geometry_msgs.msg import Twist# ROS节点初始化rospy.init_node(&#x27;publisher&#x27;, anonymous=True)# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)#设置循环的频率rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) rate.sleep() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/publisher.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 3 Subscriber（C++） 123456789101112131415161718192021222324#include &lt;ros/ros.h&gt;#include &quot;turtlesim/Pose.h&quot;// 接收到订阅的消息后，会进入消息回调函数// turtlesim::Pose为消息类型，来源于 #include &quot;turtlesim/Pose.h&quot;void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg-&gt;x, msg-&gt;y);&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;subscriber&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;, 10, poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(subscriber src/subscriber.cpp)target_link_libraries(subscriber $&#123;catkin_LIBRARIES&#125;) 4 Subscriber（Python） 123456789101112131415#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)# ROS节点初始化rospy.init_node(&#x27;subscriber&#x27;, anonymous=True)# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback# Pose为消息类型，来源于 from turtlesim.msg import Poserospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)# 循环等待回调函数rospy.spin() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/subscriber.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 5 自定义接口 5.1 msg文件编写 在 ros_ws/src/hello/msg目录下创建 Person.msg 接口文件，注意首字母必须大写。接口示例如下： 12345678string nameuint8 sexuint8 age# 以下相当于宏uint8 unknown = 0uint8 male = 1uint8 female = 2 编译修改： CMakeLists修改：在对应位置进行如下修改： 1234find_package(...... message_generation)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs)catkin_package(...... message_runtime) package.xml修改：在对应位置添加如下： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 自定义接口需经过编译形成C++和Python的引用文件，可以在devel/include里面找到C++所需的.h接口文件。 5.2 发布/订阅代码编写 发布/订阅代码与前几节几乎一模一样，这里不再赘述。对于接口里面的宏的引用，在C++里面这样引用：learning_topic::Person::male; Python里面这样引用：Person.male 。 编译修改： 由于应用代码对接口产生依赖，因此在编译应用代码时，也应添加相应的依赖（Python不需要）： 1add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp) http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"ROS1零碎笔记","slug":"ROS1/ROS1零碎笔记","date":"2023-09-11T03:22:55.000Z","updated":"2025-05-14T02:14:15.312Z","comments":true,"path":"2023/09/11/ROS1/ROS1零碎笔记/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/11/ROS1/ROS1%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ros::spin 和 ros::spinOnce 的区别 这俩函数学名叫ROS消息回调处理函数，即消息回调要经过他俩中一个才能回调执行。 两者区别在于 spin 有进无出，一直阻塞等待消息到来才去回调处理函数；而 **spinOnce ** 查询一次消息队列，不管有没有消息都会往下执行，spinOnce 往往需要考虑调用消息的时机，调用频率，以及消息池的大小，这些都要根据现实情况协调好，不然会造成数据丢包或者延迟的错误。 while(1) 和 while(ros::ok())的区别 最大的区别在于，进程接收ctrl-C指令时，while(1)的程序中止退出，而while(ros::ok())则是跳出循环，注意此时程序并未中止，继续执行循环体外的清理工作。这里同时列出while(ros::ok())会在什么情况下退出： 程序接收到 Ctrl-C 信号 本节点被一个同名同姓的节点从网络中踢出 程序中调用 ros::shutdown() 程序中所有的 ros::NodeHandles 都被销毁 消息结构查询 https://wiki.ros.org/+消息包名 功能包查询 https://index.ros.org/ API查询 http://wiki.ros.org/APIs","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"3-ROS1快速开始","slug":"ROS1/3-ROS1快速开始","date":"2023-09-10T01:17:43.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/09/10/ROS1/3-ROS1快速开始/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/10/ROS1/3-ROS1%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"0 安装 工作环境：x86_64 + ubuntu20.04 + ros-noetic 12345678sudo mkdir /etc/apt/sources.list.d/sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt updatesudo apt install ros-noetic-ros-baseecho &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrcsudo apt install python3-rosinstall python3-rosinstall-generator python3-wstool -y 1 创建功能包 1.1 创建工作空间 123mkdir -p ros_ws/srccd ros_ws/srccatkin_init_workspace 1.2 创建功能包 12catkin_create_pkg hello std_msgs roscpp rospy格式：catkin_create_pkg &lt;pkg_name&gt; &lt;depend&gt; &lt;depend&gt; 1.3 编译工作空间 12cd ..catkin_make 1.4 激活环境变量 1source devel/setup.bash 注：同一个工作空间不能有同名功能包；不同工作空间可以有同名功能包。 2 编写CPP节点 2.1 创建节点文件 在 ros_ws/src/hello/src 目录下创建hello.cpp 节点文件。 2.1 节点代码 12345678910111213#include &lt;ros/ros.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;hello_node&quot;); // 创建节点句柄 ros::NodeHandle n; ROS_INFO(&quot;Hello world.&quot;); ros::spin(); return 0;&#125; 2.2 修改CmakeLists 修改 ros_ws/src/hello/src/CmakeLists，找到以下项，并进行如下修改： 1234567## 编译节点源码，hello_node为节点可执行文件名字，可以与源码指定的节点名字一致add_executable(hello_node src/hello.cpp)## 添加链接库target_link_libraries(hello_node $&#123;catkin_LIBRARIES&#125;) 2.3 编译运行 1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello_node 3 编写Python节点 3.1 创建节点文件 在 ros_ws/src/hello/scripts 目录下创建hello.py节点文件。 2.1 节点代码 12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-import rospy if __name__ == &#x27;__main__&#x27;: # ROS节点初始化 rospy.init_node(&#x27;hello_node_py&#x27;) rospy.loginfo(&#x27;hello world.&#x27;) rospy.spin() 2.2 修改CmakeLists 修改 ros_ws/src/hello/src/CmakeLists，找到以下项，并进行如下修改： 12345## 添加节点python脚本，python无需编译，只需添加到路径即可catkin_install_python(PROGRAMS scripts/hello.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 2.3 编译运行 1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello.py http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"2-ROS1命令汇总","slug":"ROS1/2-ROS1命令汇总","date":"2023-09-09T10:38:55.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/09/09/ROS1/2-ROS1命令汇总/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/09/ROS1/2-ROS1%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"","text":"命令一页纸：https://blog-images-submit.oss-cn-beijing.aliyuncs.com/ROS1/ROScheatsheet_catkin.pdf 1 node相关命令 rosnode list rosnode info &lt;node_name&gt; rosnode ping &lt;node_name&gt; rosnode ping --all rosnode kill &lt;node_name&gt; rosnode kill --all 2 topic相关命令 rostopic list rostopic type &lt;topic_name&gt; rostopic info &lt;topic_name&gt; 查看话题具体信息(消息类型，发布/订阅者) rostopic echo &lt;topic_name&gt; 实时查看话题内容 rostopic hz &lt;topic_name&gt; rostopic bw &lt;topic_name&gt; rostopic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;message_content&gt; 3 msg相关命令 rosmsg show &lt;msg_name&gt; 查看消息格式 5 service相关命令 rosservice list rosservice call &lt;ser_name&gt; rosservice type &lt;ser_name&gt; rosservice find rosservice uri 6 param相关命令 rosparam set rosparam get rosparam load rosparam delete rosparam list 7 pkg相关命令 rospack find &lt;pkg_name&gt; rospack list 8 run节点： rosrun &lt;pkg_name&gt; &lt;node_name&gt; 9 记录运行 话题记录：rosbag record -a -O cmd_record 话题复现：rosbag play cmd_record.bag 10 可视化： rqt: rqt_console 终端控制台 rqt_plot 绘制波形曲线 rqt_graph 查看节点关联关系 rqt_image_view 查看摄像头图像 rviz： 可用于构建机器人模型、坐标、点云、图像、导航、运动规划等等。 gazebo: 用于三维物理仿真 http://wiki.ros.org/cn/ROS/Tutorials","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"1-ROS概览","slug":"ROS1/1-ROS概览","date":"2023-09-03T08:26:33.000Z","updated":"2025-05-14T02:14:15.264Z","comments":true,"path":"2023/09/03/ROS1/1-ROS概览/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/09/03/ROS1/1-ROS%E6%A6%82%E8%A7%88/","excerpt":"","text":"ROS: Robot Operating System ROS已经成为机器人领域的普遍标准. ROS包含：通信框架 + 开发工具 + 应用功能 + 生态系统 开发工具包括：CLI命令，rqt，Rviz，TF-Tree，Gazebo仿真等等。 应用功能包括：导航Navigation，建图SLAM，机械臂规划Movelt等等。 生态系统包括：发行版，软件源，wiki，Blog等等。 相关概念： 节点（Node）-- 执行单元 执行具体任务的进程、独立运行的可执行文件。 不同节点可使用不同的编程语言，可分布式运行在不同的主机。 节点在系统中的名称必须是唯一的。 节点管理器（ROS Master）-- 控制中心 为节点提供命名和注册服务。 跟踪和记录话题/服务通信，辅助节点相互查找、建立连接。 提供参数服务器，节点使用该服务器存储和检索运行时的参数。 话题（Topic）-- 异步通信机制 节点间用来传输数据的重要总线。 使用发布/订阅模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一。 消息（Message） – 话题接口 具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义的类型。 使用编程语言无关的.msg文件定义，编译过程中生成对应的代码文件。 服务（Service）-- 同步通信机制 使用客户端/服务端（C/S）模型，客户端发送请求数据，服务器完成处理后返回应答数据。 使用编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件。 话题和服务的区别： 参数（Parameter）-- 全局共享字典 可通过网络访问的共享、多变量字典。 节点使用此服务器来存储和检索运行时的参数。 适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。 功能包（Package） ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。 功能包清单（Package Manifest） 记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。 元功能包（Meta Package） 组织多个用于同一目的的功能包 http://wiki.ros.org/cn/ROS/Tutorials https://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"}]},{"title":"7-ROS2通信汇总(Python篇)","slug":"ROS2基础/7-ROS2 通信汇总(Python篇)","date":"2023-08-20T09:29:55.000Z","updated":"2025-05-14T02:14:15.264Z","comments":true,"path":"2023/08/20/ROS2基础/7-ROS2 通信汇总(Python篇)/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/7-ROS2%20%E9%80%9A%E4%BF%A1%E6%B1%87%E6%80%BB(Python%E7%AF%87)/","excerpt":"","text":"1 topic发布与订阅 发布端接口： 12publisher_ = node.create_publisher(msg_type,&quot;topic_name&quot;, 10) publisher_.publish(msg) 订阅者接口： 1subscribe_ = node.create_subscription(msg_type, &quot;topic_name&quot;, recv_callback, 10) 2 service发送和接收 client 接口： 1234client = node.create_client(srv_type,&quot;srv_name&quot;)while not client.wait_for_service(1.0): node.get_logger().warn(&quot;等待服务&quot;)client.call_async(request) # .add_done_callback(reponse_callback) server 接口： 1234server = node.create_service(srv_type,&quot;srv_name&quot;, request_callback)def request_callback(request, response): ...... return response 3 action控制与执行 执行 接口： 123456789101112from rclpy.action import ActionServerfrom rclpy.action.server import ServerGoalHandleaction_server_ = ActionServer( node, action_type, &quot;action_name&quot;, execute_callback # ,callback_group=MutuallyExclusiveCallbackGroup() )def execute_callback(goal_handle: ServerGoalHandle): ... ... result = action_type.Result() result = ... return result 控制 接口： 12345678910111213141516from rclpy.action import ActionClientaction_client_ = ActionClient(node, action_type, &#x27;action_name&#x27;)goal_msg = MoveRobot.Goal()goal_msg = ...action_client_.wait_for_server()send_goal_future = action_client_.send_goal_async(goal_msg,feedback_callback=feedback_callback)send_goal_future.add_done_callback(goal_response_callback)def feedback_callback(feedback_msg): feedback = feedback_msg.feedback ... def goal_response_callback(future): goal_handle = future.result() get_result_future = goal_handle.get_result_async() get_result_future.add_done_callback(get_result_callback)","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"6-ROS2 接口介绍","slug":"ROS2基础/6-ROS2 接口介绍","date":"2023-08-20T09:29:45.000Z","updated":"2025-05-14T02:14:15.268Z","comments":true,"path":"2023/08/20/ROS2基础/6-ROS2 接口介绍/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/6-ROS2%20%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"ROS2提供了四种通信方式，包括：话题（topic）、服务（service）、动作（action）和 参数（parameter）。通信会涉及到接口，我们可以通过 ros2 interface list 列出ROS2提供的所有接口，通过 ros2 interface show &lt;interface_name&gt; 或 ros2 interface proto &lt;message_name&gt; 查看接口的具体格式。但是，当我们不能在内置接口中找到适合于我们项目的接口时，我们需要自定义接口。以下讲解如何自定义接口。 1 接口格式 1.1 topic接口格式 接口存放路径：interface_pkg/msg/Xxx.msg 12string namesensor_msgs/Image image #支持嵌套 1.2 service接口格式 接口存放路径：interface_pkg/srv/Xxx.srv 12345string nameint32 aint64 b---int32 ret # 返回值 1.3 action接口格式 接口存放路径：interface_pkg/action/Xxx.action 12345int32 target # 目标值 ---int32[] sequence # 差值---int32[] partial_sequence # 当前值 2 创建接口 2.1 创建接口功能包 1ros2 pkg create example_test_interfaces --build-type ament_cmake --dependencies rosidl_default_generators 其中，–build-type 参数值必须为 ament_cmake； --dependencies 指定功能包依赖，rosidl_default_generators必须添加，其他根据自己接口依赖添加即可，当然也可以通过事后修改 package.xml 添加依赖。创建完后可看见新增接口文件夹，目录如下： 2.2 添加接口文件 将自己定义的接口放入 example_test_interfaces 文件夹合适位置，注意要按照上一节的接口格式来定义和存放接口。我们这个先定义一个简单的 topic 接口，在 example_test_interfaces 下新建 msg 目录，并在 msg 目录下新建 Test.msg 文件(首字母大写)，内容如下： 123string nameuint32 valuebool flag 2.3 修改CMakeLists文件 在CMakeLists里面添加要编译的接口，为什么接口也要编译？其实ROS需要将 msg、srv、action文件转换为Python和C++的头文件，这样我们的节点代码才能读取接口。CMakeLists修改如下： 12345678# 查找依赖，有新增需添加find_package(rosidl_default_generators REQUIRED)# 生成接口头文件rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/Test.msg&quot; # DEPENDENCIES geometry_msgs # 有依赖需要添加) 2.4 修改package.xml文件 12在 &lt;depend&gt;rosidl_default_generators&lt;/depend&gt; 下面添加：&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 2.5 编译接口包 12cd workspacecolcon build --packages-select example_test_interfaces 2.6 查看测试 12source install/setup.bashros2 interface show example_test_interfaces/msg/Test","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"5-ROS2创建第一个节点","slug":"ROS2基础/5-ROS2创建第一个节点","date":"2023-08-20T09:29:31.000Z","updated":"2025-05-14T02:14:15.264Z","comments":true,"path":"2023/08/20/ROS2基础/5-ROS2创建第一个节点/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/5-ROS2%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"1 创建cpp节点 1.1 创建工作空间 1mkdir -p workspace/src/ 1.2 创建功能包 12cd workspace/srcros2 pkg create example_cpp --build-type ament_cmake --dependencies rclcpp 此时可以看到ROS2为我们创建了example_cpp文件夹，且该文件夹下包含include、src、CMakeLists.txt、package.xml 文件及目录。其中，src和include目录放节点源码和相应的头文件，CMakeLists.txt是编译节点源码的配置文件，package.xml是该功能包的配置文件。 1.3 创建节点 在功能包的src目录下创建节点文件 mynode.cpp，该文件的main函数则为该节点的入口。cpp文件代码如下： 12345678910111213141516#include &quot;rclcpp/rclcpp.hpp&quot;int main(int argc, char **argv)&#123; /* 初始化rclcpp */ rclcpp::init(argc, argv); /*创建一个名为test_node的节点*/ auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;test_node&quot;); /*利用RCLCPP 打印*/ RCLCPP_INFO(node-&gt;get_logger(), &quot;Hello World. test_node start.&quot;); /* 运行节点，并检测退出信号 Ctrl+C*/ rclcpp::spin(node); /* 停止运行 */ rclcpp::shutdown(); return 0;&#125; 1.4 修改CMakeLists 将mynode.cpp 添加到CMakeLists中，让cmake编译节点并安装节点。在CMakeLists末尾添加以下配置： 1234567add_executable(test_node src/mynode.cpp)ament_target_dependencies(test_node rclcpp)install(TARGETS test_node DESTINATION lib/$&#123;PROJECT_NAME&#125;) 1.5 编译功能包 12cd workspacecolcon build --packages-select example_cpp 1.6 source环境 1source install/setup.bash 1.7 运行节点 1ros2 run example_cpp test_node 2 创建python节点 2.1 创建工作空间 1mkdir -p workspace/src/ 2.2 创建功能包 12cd workspace/srcros2 pkg create example_py --build-type ament_python --dependencies rclpy 此时可以看到ROS2为我们创建了example_py文件夹，且该文件夹下包含example_py、resource、test、package.xml、setup.py、setup.cfg文件及目录。其中，example_py文件夹放我们的节点代码。 2.3 创建节点 在功能包的example_py目录下创建节点文件 mynode.py，该文件的main函数则为该节点的入口。python文件代码如下： 123456789101112import rclpyfrom rclpy.node import Nodedef main(args=None): # 初始化rclpy rclpy.init(args=args) # 创建一个test_node node = Node(&quot;test_node_py&quot;) node.get_logger().info(&quot;Hello World. node_py start.&quot;) # 保持节点运行 rclpy.spin(node) rclpy.shutdown() 2.4 修改 setup.py 在setup文件中声明该python节点，以及指定该节点的入口。这样之后使用colcon build才能检测到该节点，从而将其添加到install目录下。修改如下： 123456 entry_points=&#123; &#x27;console_scripts&#x27;: [ &quot;test_node_py = example_py.mynode:main&quot; ], &#125;,) 2.5 编译功能包 12cd workspacecolcon build --packages-select example_py 2.6 source环境 1source install/setup.bash 2.7 运行节点 1ros2 run example_py test_node_py","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"4-ROS2命令行汇总","slug":"ROS2基础/4-ROS2命令行汇总","date":"2023-08-20T09:29:21.000Z","updated":"2025-05-14T02:14:15.264Z","comments":true,"path":"2023/08/20/ROS2基础/4-ROS2命令行汇总/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/4-ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B1%87%E6%80%BB/","excerpt":"","text":"0 节点运行命令 命令格式： ros2 run &lt;package_name&gt; &lt;node_name&gt; 1 pkg相关命令 1.1 ros2 pkg create 命令功能：创建功能包并指定包相关参数 命令格式：ros2 pkg create &lt;pkgname&gt; –build-type &lt;ament_python&gt; –node-name &lt;xx_node&gt; –dependencies &lt;rclpy&gt; 参数列表： 参数 参数作用 参数示例 –build-type 指定编译类型 ament_python / ament_cmake –node-name 指定要生成的源码文件，可以后期创建 xxx.py / xxx.cpp –dependencies 指定依赖模块 rclpy / std_msgs / sensor_msgs 1.2 ros2 pkg list 命令功能：查看系统中功能包列表 命令格式：ros2 pkg list 注意：记得要通过source指令将自己的功能包添加到ROS2环境中。 1.3 ros2 pkg executables 命令功能：查看功能包内所有可执行节点 命令格式：ros2 pkg executables &lt;package_name&gt; 2 node相关命令 2.1 ros2 node list 命令功能： 查看当前域内（ROS_DOMAIN_ID）的节点列表 命令格式： ros2 node list 2.2 ros2 node info 命令功能： 查看节点详细信息，包括订阅、发布的消息，开启的服务和动作等 命令格式： ros2 node info &lt;node_name&gt; 3 topic相关命令 3.1 ros2 topic list 命令功能：列出域内可使用的topic列表 命令格式：ros2 topic list 3.2 ros2 topic info 命令功能：显示主题消息类型，订阅者数量，发布者数量等 命令格式：ros2 topic info &lt;topic_name&gt; 3.3 ros2 topic type 命令功能：查看主题消息类型 命令格式：ros2 topic type &lt;topic_name&gt; 3.4 ros2 topic find 命令功能：按消息类型查找相关主题 命令格式：ros2 topic find &lt;message_type&gt; 3.5 ros2 topic hz 命令功能：显示主题平均发布频率 命令格式：ros2 topic hz &lt;topic_name&gt; 3.6 ros2 topic bw 命令功能：显示所查阅主题的带宽 命令格式：ros2 topic bw &lt;topic_name&gt; 3.7 ros2 topic delay 命令功能：通过header中的时间戳计算消息延迟 命令格式：ros2 topic delay &lt;topic_name&gt; 3.8 ros2 topic echo 命令功能：在控制台显示主题消息 命令格式：ros2 topic echo &lt;topic_name&gt; 3.9 ros2 topic pub 命令功能：通过命令行发布指定主题消息 命令格式：ros2 topic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;message_content&gt; 命令示例：ros2 topic pub control_node/action geometry_msgs/msg/TwistStamped “{header: {stamp:{sec: 0, nanosec: 0}, frame_id: control_node}, twist: {linear: {x: 0.3, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}}” 4 interface相关命令 4.1 ros2 interface list 命令功能：按类显示系统内所有的接口，包括消息（Messages）、服务（Services）、动作（Actions） 命令格式：ros2 interface list 4.3 ros2 interface packages 命令功能：显示所有接口包 命令格式：ros2 interface packages 4.2 ros2 interface package 命令功能：显示指定接口包内的子接口 命令格式：ros2 interface package &lt;interface_pkg&gt; 4.3 ros2 interface show 命令功能：显示指定接口的详细内容 命令格式：ros2 interface show &lt;interface_name&gt; 4.4 ros2 interface proto 命令功能：显示消息模板 命令格式：ros2 interface proto &lt;message_name&gt;","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"3-ROS2系统架构","slug":"ROS2基础/3-ROS2系统架构","date":"2023-08-20T09:29:19.000Z","updated":"2025-05-14T02:14:15.264Z","comments":true,"path":"2023/08/20/ROS2基础/3-ROS2系统架构/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/3-ROS2%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1 ROS2总体架构图 1.1 DDS实现层 DDS，全称 Data Distribution Service (数据分发服务)。是由对象管理组 (OMG) 于 2003 年发布并于 2007 年修订的开分布式系统标准。 通过类似于ROS中的话题发布和订阅形式来进行通信，同时提供了丰富的服务质量管理来保证可靠性、持久性、传输设置等。 DDS实现层其实就是对不同常见的DDS接口进行再次的封装，让其保持统一性，为DDS抽象层提供统一的API。 1.2 DDS抽象层（rmw） 这一层将DDS实现层进一步的封装，使得DDS更容易使用。原因在于DDS需要大量的设置和配置（分区，主题名称，发现模式，消息创建,…），这些设置都是在ROS2的抽象层中完成的。 2 DDS 通信模型 DDS的模型是非常容易理解，我们可以定义话题的数据结构（类似于ROS2中的接口类型）。下图中的例子: Pos：一个编号id的车子的位置x,y DDS的参与者(Participant)通过发布和订阅主题数据进行通信。 DDS的应用层通过DDS进行数据订阅发布，DDS通过传输层进行数据的收发。 2.1. DDS的优势与劣势 **优势** 发布/订阅模型：简单解耦，可以轻松实现系统解耦 性能：在发布/订阅模式中，与请求/回复模式相比，延迟更低，吞吐量更高。 远程参与者的自动发现：此机制是 DDS 的主要功能之一。通信是匿名的、解耦的，开发者不必担心远程参与者的本地化。 丰富的 Qos 参数集，允许调整通信的各个方面：可靠性、持久性、冗余、寿命、传输设置、资源… 实时发布订阅协议 ( RTPS )：该协议几乎可以通过任何传输实现，允许在 UDP、TCP、共享内存和用户传输中使用 DDS，并实现不同 DDS 实现之间的真正互操作性。 劣势 API复杂，DDS 的灵活性是以复杂性为代价的。 系统开销相对较大，有待数据论证。 社区支持问题，但ROS2近两年来使用DDS后社区表现还是不错的。 2.2 ROS2使用DDS的几个理由 DDS已经应用在军事、潜艇各个领域，稳定性实时性经过实际检验。 使用DDS需要维护的代码要少得多，可以让ROS2开发人员腾出手专注机器人开发。 DDS有定义好的行为和规范并且有完善的文档。 DDS提供了推荐的用例和软件API，有较好的语言支持。","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"1-ROS2安装(armhf篇)","slug":"ROS2基础/1-ROS2安装(armhf篇)","date":"2023-08-20T09:29:18.000Z","updated":"2025-05-14T02:14:15.256Z","comments":true,"path":"2023/08/20/ROS2基础/1-ROS2安装(armhf篇)/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/1-ROS2%E5%AE%89%E8%A3%85(armhf%E7%AF%87)/","excerpt":"","text":"由于ROS官方并没有提供armhf CPU架构的ROS2二进制安装文件，本篇整理了从ROS2源码编译安装的方法。本篇安装环境如下： CPU架构：armv7l 操作系统：ubuntu20.04 1 更换镜像源（可选） 更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源 这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。armv7l / ubuntu20.04的源如下： mv /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源 这里同样采用清华的pip源，可加速python第三方库的下载（后面需要），命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale 12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库 12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装编译工具 123456789101112131415161718192021222324252627sudo apt update &amp;&amp; sudo apt install -y \\ libbullet-dev \\ python3-pip \\ python3-pytest-cov \\ ros-dev-tools# install some pip packages needed for testingpython3 -m pip install -U \\ argcomplete \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest# install Fast-RTPS dependenciessudo apt install --no-install-recommends -y \\ libasio-dev \\ libtinyxml2-dev# install Cyclone DDS dependenciessudo apt install --no-install-recommends -y \\ libcunit1-dev 5 获取ROS2源码 12345mkdir -p ~/ros2_foxy/srccd ~/ros2_foxywget https://raw.githubusercontent.com/ros2/ros2/foxy/ros2.repos --no-check-certificate## github下载不稳定，可自行修改repos文件，添加代理前缀 https://ghproxy.com/vcs import --input ./ros2.repos src 6 使用Rosdep安装依赖 1234sudo apt upgradecd /etc/ros/rosdep/sources.list.d &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/github-raw/ros/rosdistro/master/rosdep/sources.list.d/20-default.listrosdep updaterosdep install --from-paths src --ignore-src -y --skip-keys &quot;fastcdr rti-connext-dds-5.3.1 urdfdom_headers&quot; 7 编译ROS2源码 12cd ~/ros2_foxy/colcon build --symlink-install 8 设置环境变量 1. ~/ros2_foxy/install/local_setup.bash 9 测试 1234567## 运行talker. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_cpp talker## 新起另一个终端，运行listener. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_py listener","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"2-ROS2安装(X86篇)","slug":"ROS2基础/2-ROS2安装(X86篇)","date":"2023-08-20T09:29:10.000Z","updated":"2025-05-14T02:14:15.256Z","comments":true,"path":"2023/08/20/ROS2基础/2-ROS2安装(X86篇)/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/2-ROS2%E5%AE%89%E8%A3%85(X86%E7%AF%87)/","excerpt":"","text":"本篇安装环境如下： CPU架构：amd_64 操作系统：ubuntu20.04 1 更换镜像源（可选） 更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源 这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。amd_64/ ubuntu20.04的源如下： mv /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源 这里同样采用清华的pip源，可加速python第三方库的下载，命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale 12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库 12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装ROS2 1sudo apt install ros-foxy-desktop python3-colcon-common-extensions 5 设置环境变量 12source /opt/ros/foxy/setup.bashecho &quot; source /opt/ros/foxy/setup.bash&quot; &gt;&gt; ~/.bashrc 6 测试 6.1 你说我听 12345## 运行talkerros2 run demo_nodes_cpp talker## 新起另一个终端，运行listenerros2 run demo_nodes_py listener 6.2 小海龟 12345## 运行海龟界面ros2 run turtlesim turtlesim_node## 新启一个终端，运行遥控器ros2 run turtlesim turtle_teleop_key","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"5-模型调参","slug":"pytorch基础/5-模型调参","date":"2023-07-26T09:21:38.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2023/07/26/pytorch基础/5-模型调参/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/5-%E6%A8%A1%E5%9E%8B%E8%B0%83%E5%8F%82/","excerpt":"","text":"1 超参数 超参数是可调整的参数，让你控制模型优化过程。不同的超参数值会影响模型的训练和收敛率。 常用的超参数如下： epoch : 在整个数据集上迭代的次数。 batch : 每一次更新参数（反向传播）所用到的数据样本数。 学习率 : 每个batch 更新模型参数的步进幅度。 123learning_rate = 1e-3batch_size = 64epochs = 5 2 损失函数 当遇到一些训练数据时，我们未经训练的网络很可能不会给出正确的答案。损失函数衡量的是获得的结果与目标值的不相似程度，它是我们在训练期间想要最小化的损失函数。为了计算损失，我们使用给定数据样本的输入进行预测，并与真实数据标签值进行比较。 常见的损失函数包括用于回归任务的nn.MSELoss（均方误差）和用于分类的nn.NLLLoss（负对数似然）。nn.CrossEntropyLoss结合了nn.LogSoftmax和nn.NLLLoss。 我们将模型的输出对数传递给 nn.CrossEntropyLoss，它将对对数进行标准化处理并计算预测误差。 12# Initialize the loss functionloss_fn = nn.CrossEntropyLoss() 3 优化器 优化是在每个训练步骤中调整模型参数以减少模型误差的过程。优化算法定义了这个过程是如何进行的（在这个例子中，我们使用随机梯度下降法）。所有的优化逻辑都被封装在优化器对象中。在这里，我们使用SGD优化器；此外，PyTorch中还有许多不同的优化器，如Adam和RMSProp，它们对不同类型的模型和数据有更好的效果。 我们通过注册需要训练的模型参数来初始化优化器，并传入学习率超参数。 1optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) 4 调参过程 我们定义了train_loop和test_loop，train_loop负责循环我们的优化代码，test_loop负责根据测试数据评估模型的性能。 12345678910111213141516171819202122232425262728293031def train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;)def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;) 123456789loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)epochs = 10for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 请确保在推理前调用model.eval()方法，以将dropout和batch normalization层设置为eval模式。如果不这样做，将产生不一致的推理结果。 5 保存&amp;加载 5.1 保存状态字典 123torch.save(model.state_dict(), &#x27;model_weights.pth&#x27;)model = Model_Net() # 需要实例化训练时相同的类model.load_state_dict(torch.load(&#x27;model_weights.pth&#x27;)) 5.2 保存整个模型类 123# 这种方法在序列化模型时使用Python的pickle模块，所以它在加载模型时，依赖于实际的可用的类定义。torch.save(model, &#x27;model.pth&#x27;)model = torch.load(&#x27;model.pth&#x27;) 5.3 导出ONNX模型 123# 由于PyTorch执行图的动态性质，导出过程必须遍历执行图以产生持久的ONNX模型。出于这个原因，应该向导出程序传递一个适当大小的测试变量。input_image = torch.zeros((1,3,224,224))onnx.export(model, input_image, &#x27;model.onnx&#x27;) 5.4 导出JIT模型 该种方法加载模型时无需 模型类，导出 JIT 模型的方式有两种：trace 和 script。 采用 torch.jit.trace 的方式来导出 JIT 模型，这种方式会根据一个输入将模型跑一遍，然后记录下执行过程。这种方式的问题在于对于有分支判断的模型不能很好的应对，因为一个输入不能覆盖到所有的分支。但是在我们 ResNet50 模型中不会遇到分支判断，因此这里是合适的。 12345# trace 方法保存example_input = torch.rand(1, 3, 224, 224)jit_model = torch.jit.trace(model, example_input)torch.jit.save(jit_model, &#x27;resnet50_jit.pth&#x27;)module = torch.jit.load(&#x27;resnet50_jit.pth&#x27;) 如果模型有 if else 等分支语句, 应该用script方法保存模型。 1234# script 方法保存script_module = torch.jit.script(model) torch.jit.save(script_module, &#x27;model.pth&#x27;)module = torch.jit.load(&#x27;model.pth&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"4-模型搭建","slug":"pytorch基础/4-模型搭建","date":"2023-07-26T09:18:44.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2023/07/26/pytorch基础/4-模型搭建/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/4-%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1 神经网络搭建 1.1 通过 forward 构建 我们可以通过继承 nn.Module，构建我们自己的类来定义我们的神经网络。其中，我们在__init__方法中实现各个子Module的初始化，并在forward 方法中组织这些子Module，形成神经网络。 12345678910111213141516171819class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)logits = model(input_image) 1.2 通过 Sequential 构建 nn.Sequential是一个有序模块的容器。数据以定义的顺序通过所有的模块。你可以使用 序列容器来组建一个快速的网络。 1234567seq_modules = nn.Sequential( flatten, layer1, nn.ReLU(), nn.Linear(20, 10))logits = seq_modules(input_image) 2 模型参数 神经网络中的许多层都是参数化的，也就是说，层相关的权重和偏置在训练中被优化。nn.Module的子类会自动跟踪你的模型对象中定义的所有字段，并使用你的模型的 parameters() 或 named_parameters() 方法访问所有参数。 在这个例子中，我们遍历每个参数，并打印其大小和预览其值。 1234print(&quot;Model structure: &quot;, model, &quot;\\n\\n&quot;)for name, param in model.named_parameters(): print(f&quot;Layer: &#123;name&#125; | Size: &#123;param.size()&#125; | Values : &#123;param[:2]&#125; \\n&quot;) 3 反向传播 在训练神经网络时，最常使用的算法是反向传播算法。在这种算法中，参数（模型权重）是根据损失函数相对于给定参数的梯度来调整的。 3.1 自动梯度计算 为了计算这些梯度，PyTorch有一个内置的微分引擎，叫做torch.autograd。它支持对任何计算图的梯度进行自动计算。考虑最简单的单层神经网络，输入x，参数w和b，以及一些损失函数。 **在这个网络中，w和b是参数，我们需要进行优化。因此，我们需要能够计算损失值相对于这些变量的梯度（梯度只对于模型参数有意义）。**为了做到这一点，我们设置了这些tensor的 requires_grad 属性。它可以在PyTorch中以如下方式定义： 12345678910111213# 正向传播import torchx = torch.ones(5) # input tensory = torch.zeros(3) # expected outputw = torch.randn(5, 3, requires_grad=True) # 需要更新的weightb = torch.randn(3, requires_grad=True) # 需要更新的biasz = torch.matmul(x, w)+bloss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)#反向传播loss.backward() #该步骤包含对梯度的自动计算，梯度值通过以下查看。print(w.grad)print(b.grad) 3.2 autograd的机制 首先了解tensor有哪些属性： data : 被包装的张量 grad : 存储data的梯度 grad_fn : 创建 Tensor的 Function，是自动求导的关键 requires_grad：指示是否需要梯度 is_leaf : 指示是否是叶子结点 dtype：张量的数据类型 shape：张量的形状，如(64，3，224，224) device：张量所在设备，GPU/CPU Tensor和Function互相结合就可以构建一个记录有整个计算过程的有向无环图(Directed Acyclic Graph，DAG)。每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function。 DAG的节点是Function对象，边表示数据依赖，从输出指向输入。 **每当对Tensor施加一个运算的时候，就会产生一个Function对象，它产生运算的结果，记录运算的发生，并且记录运算的输入。**Tensor使用.grad_fn属性记录这个计算图的入口。反向传播过程中，autograd引擎会按照逆序，通过Function的backward依次计算梯度。 注意事项 （1）梯度不自动清零，如果不清零梯度会累加，所以需要在每次梯度后人为清零。 （2）依赖于叶子结点的结点，requires_grad默认为True。 （3）叶子结点不可执行in-place，因为其他节点在计算梯度时需要用到叶子节点，所以叶子地址中的值不得改变否则会是其他节点求梯度时出错。所以叶子节点不能进行原位计算。 （4）在 y.backward()时，如果 y 是标量量，则不需要为backward()传⼊入任何参数；否则，需要传⼊一个与y同形的Tensor。 （5）只能获得计算图的叶子节点的grad属性，这些节点的requires_grad属性设置为True。对于图中的所有其他节点，梯度将不可用。 （6）只能在一个给定的图上使用一次backward来进行梯度计算。如果需要在同一个图上进行多次backward调用，需要在backward调用中传递 retain_graph=True。 （7）在PyTorch中，DAG是动态的。需要注意的是，图是从头开始重新创建的；在每次调用.backward()后，autograd开始填充一个新的图。这正是允许你在模型中使用控制流语句的原因；如果需要，你可以在每次迭代时改变形状、大小和操作。 3.3 禁用梯度跟踪 123456789101112# 方法一：利用torch.no_grad()块包围正向传播代码with torch.no_grad(): z = torch.matmul(x, w)+b# 方法二：利用detach方法z = torch.matmul(x, w)+bz_det = z.detach()# 方法三：设置requires_gradfor name, param in model.named_parameters(): param.requires_grad = False","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"3-数据准备","slug":"pytorch基础/3-数据准备","date":"2023-07-25T06:38:09.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2023/07/25/pytorch基础/3-数据准备/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/25/pytorch%E5%9F%BA%E7%A1%80/3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87/","excerpt":"","text":"1 Dataset 1.1 图像（path+label形式） 12345678910111213141516171819202122232425import osimport pandas as pdfrom torchvision.io import read_imagefrom torchvision import datasetsfrom torchvision import transformsclass CustomImageDataset(Dataset): def __init__(self, annotations_file, img_dir, transform=None, target_transform=None): self.img_labels = pd.read_csv(annotations_file) self.img_dir = img_dir self.transform = transform self.target_transform = target_transform def __len__(self): return len(self.img_labels) def __getitem__(self, idx): img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0]) image = read_image(img_path) label = self.img_labels.iloc[idx, 1] if self.transform: image = self.transform(image) if self.target_transform: label = self.target_transform(label) return image, label 1.2 图像（文件夹名为label 形式） 12345data_dir = &#x27;data/hymenoptera_data&#x27;train_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;train&quot;) ,data_transforms[&quot;train&quot;])val_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;val&quot;) ,data_transforms[&quot;val&quot;]) 1.3 图像（在线拉取） 12345train_data = datasets.MNIST(root=&#x27;data&#x27;, train=True, download=True, transform=data_transforms[&quot;train&quot;], target_transform=xxx) 1.4 图片转换 1234567891011121314151617# input变换data_transforms = transforms.Compose([ transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ])# RandomResizedCrop: 随机长宽比裁剪# RandomHorizontalFlip: 随机水平翻转# RandomVerticalFlip: 随机垂直翻转# ToTensor: 转换为tensor# Normalize: 像素值进行归一化处理# target 变换# 把整数变成一个one-hot的tensortarget_transform = Lambda(lambda y: torch.zeros(10, dtype=torch.float) \\ .scatter_(dim=0, index=torch.tensor(y), value=1)) 2 DataLoader 123456train_dataloader = torch.utils.data.DataLoader(train_data, batch_size=64, shuffle=True, num_workers=4)for batch, (X, y) in enumerate(train_dataloader): X, y = X.to(device), y.to(device)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"2-tensor基础","slug":"pytorch基础/2-tensor操作","date":"2023-07-25T06:26:52.000Z","updated":"2025-05-14T02:14:15.368Z","comments":true,"path":"2023/07/25/pytorch基础/2-tensor操作/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/25/pytorch%E5%9F%BA%E7%A1%80/2-tensor%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1 tensor属性 1.1 tensor初始化 1234shape = (2,3,)rand_tensor = torch.rand(shape)ones_tensor = torch.ones(shape)zeros_tensor = torch.zeros(shape) 1.2 tensor性质 1234tensor = torch.rand(3,4)print(f&quot;Shape of tensor: &#123;tensor.shape&#125;&quot;)print(f&quot;Datatype of tensor: &#123;tensor.dtype&#125;&quot;)print(f&quot;Device tensor is stored on: &#123;tensor.device&#125;&quot;) 2 对象转换 2.1 list – tensor 123456data = [[1, 2], [3, 4]]# list--&gt; tensor# 数据类型是自动推断出来x_tensor = torch.tensor(data)# tensor--&gt; listx_list = x_tensor.tolist() 2.2 numpy – tensor 12345np_array = np.array(data)# numpy --&gt; tensorx_tensor = torch.from_numpy(np_array)# tensor --&gt; numpyx_numpy = x_tensor.numpy() 2.3 tensor – tensor 12x_ones = torch.ones_like(x_data) # retains the properties of x_datax_rand = torch.rand_like(x_data, dtype=torch.float) # overrides the datatype of x_data 3 运算&amp;操作 3.1 矩阵乘法 1234y1 = tensor @ tensor.Ty2 = tensor.matmul(tensor.T)y3 = torch.rand_like(tensor)torch.matmul(tensor, tensor.T, out=y3) 3.2 矩阵点乘 12345z1 = tensor * tensorz2 = tensor.mul(tensor)z3 = torch.rand_like(tensor)torch.mul(tensor, tensor, out=z3) 3.3 矩阵拼接 1234# 指定的dim 数量增加，除了dim之外的dim需要相同才行t1 = torch.cat([tensor, tensor, tensor], dim=1)# 两个要进行stack的tensor的dim数量应该相同，stack操作之后得到的结果会多出一维，即dim的数量会+1。t1 = torch.stack([tensor, tensor, tensor], dim=1) 3.4 矩阵升降维 123456# 升维。插入指定维度，值为1tensor.unsqueeze(dim=0)# 降维。压缩指定维度，该维度值必须为1# 当dim不指定时，压缩所有维度值为1的维tensor.squeeze(dim=0)tensor.squeeze()","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"1-pytorch快速开始","slug":"pytorch基础/1-pytorch快速开始","date":"2023-07-24T10:01:37.000Z","updated":"2025-05-14T02:14:15.364Z","comments":true,"path":"2023/07/24/pytorch基础/1-pytorch快速开始/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/24/pytorch%E5%9F%BA%E7%A1%80/1-pytorch%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"0 导库 123456import torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambda, Composeimport matplotlib.pyplot as plt 1 数据准备 torchvision.datasets模块包含了许多真实世界的视觉数据的数据集对象，如CIFAR、COCO。以下通过datasets在线加载FashionMNIST数据集。 123456789101112131415# Download training data from open datasets.training_data = datasets.FashionMNIST( root=&quot;data&quot;, train=True, download=True, transform=ToTensor(),)# Download test data from open datasets.test_data = datasets.FashionMNIST( root=&quot;data&quot;, train=False, download=True, transform=ToTensor(),) 将dataset装载入DataLoader中，DataLoader可认为是一个数据迭代器，其支持数据的自动批处理、采样、洗牌和多进程数据加载。这里定义一个 batch=64，即dataloader可迭代的每个元素将返回一个批次，包括64个元素的特征和标签。 123456789batch_size = 64# Create data loaders.train_dataloader = DataLoader(training_data, batch_size=batch_size)test_dataloader = DataLoader(test_data, batch_size=batch_size)for X, y in test_dataloader: print(&quot;Shape of X [N, C, H, W]: &quot;, X.shape) print(&quot;Shape of y: &quot;, y.shape, y.dtype) break 2 创建模型 为了在PyTorch中定义一个神经网络，我们创建一个继承自nn.Module的类。我们在__init__函数中定义网络的层，并在forward函数中指定数据将如何通过网络。为了加速神经网络的操作，如果有GPU的话，我们把它移到GPU上。 1234567891011121314151617181920212223# Get cpu or gpu device for training.device = &quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;# Define modelclass NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10) ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)print(model) 3 优化模型参数 3.1 模型训练函数 12345678910111213141516171819202122loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)def train(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) model.train() for batch, (X, y) in enumerate(dataloader): X, y = X.to(device), y.to(device) # Compute prediction error pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;) 3.2 模型评估函数 1234567891011121314def test(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) model.eval() test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;)1 3.3 启动训练&amp;评估 123456epochs = 5for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train(train_dataloader, model, loss_fn, optimizer) test(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 4 保存模型 12torch.save(model.state_dict(), &quot;model.pth&quot;)print(&quot;Saved PyTorch Model State to model.pth&quot;) 5 加载模型 12model = NeuralNetwork()model.load_state_dict(torch.load(&quot;model.pth&quot;)) 6 模型推理 12345678910111213141516171819classes = [ &quot;T-shirt/top&quot;, &quot;Trouser&quot;, &quot;Pullover&quot;, &quot;Dress&quot;, &quot;Coat&quot;, &quot;Sandal&quot;, &quot;Shirt&quot;, &quot;Sneaker&quot;, &quot;Bag&quot;, &quot;Ankle boot&quot;,]model.eval()x, y = test_data[0][0], test_data[0][1]with torch.no_grad(): pred = model(x) predicted, actual = classes[pred[0].argmax(0)], classes[y] print(f&#x27;Predicted: &quot;&#123;predicted&#125;&quot;, Actual: &quot;&#123;actual&#125;&quot;&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-07-23T10:23:20.000Z","updated":"2025-05-14T02:14:14.756Z","comments":true,"path":"2023/07/23/hello-world/","link":"","permalink":"https://xie-peiquan.gitee.io/2023/07/23/hello-world/","excerpt":"","text":"今天坑坑洼洼可算是把网站给搭好了，看着简洁漂亮的首页，想着以后就有专属自己的网站，就很开心。背景图是《权游》里面的某一幕的简画，守夜人面对夜鬼的来袭，背水一战，颇为壮观。 为什么要做个人博客呢？说实话，没有特别的理由。或许是出于新鲜感；或许是工作太无聊；或许是外界太嘈杂，想在数字世界中寻找一片净土；或许是想把有趣的、新奇的东西系统地放进来，有一天可以带朋友来参观，看！这是我曾经的快乐和珍藏。 现实世界有太多约束，说话做事写文章处处存在隐形的规矩，这些规矩容易消磨本身藏在事物的乐趣。我想，在这里就少点规矩吧，说说废话，吹吹牛逼又怎么样呢？有时候写点生活感悟也不怕别人说我假正经。嗯，没错，这是我的展厅！当然，对于涉及实操性或理论性的文章，行文还是遵从逻辑，便于理解和回顾。 那么，第一篇写点啥呢，emmm…","categories":[{"name":"建站","slug":"建站","permalink":"https://xie-peiquan.gitee.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"建站","slug":"建站","permalink":"https://xie-peiquan.gitee.io/tags/%E5%BB%BA%E7%AB%99/"}]}],"categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://xie-peiquan.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"社会科学","slug":"社会科学","permalink":"https://xie-peiquan.gitee.io/categories/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"},{"name":"先贤文集","slug":"先贤文集","permalink":"https://xie-peiquan.gitee.io/categories/%E5%85%88%E8%B4%A4%E6%96%87%E9%9B%86/"},{"name":"信号处理算法","slug":"信号处理算法","permalink":"https://xie-peiquan.gitee.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"},{"name":"STL源码笔记","slug":"STL源码笔记","permalink":"https://xie-peiquan.gitee.io/categories/STL%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"},{"name":"C++那些事","slug":"C-那些事","permalink":"https://xie-peiquan.gitee.io/categories/C-%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"数据库","slug":"数据库","permalink":"https://xie-peiquan.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"音乐","slug":"音乐","permalink":"https://xie-peiquan.gitee.io/categories/%E9%9F%B3%E4%B9%90/"},{"name":"C++并发编程基础","slug":"C-并发编程基础","permalink":"https://xie-peiquan.gitee.io/categories/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/categories/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/categories/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/categories/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/categories/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"https://xie-peiquan.gitee.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://xie-peiquan.gitee.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"机器学习","slug":"机器学习","permalink":"https://xie-peiquan.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"并行计算","slug":"并行计算","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"毛泽东选集","slug":"毛泽东选集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/"},{"name":"文集","slug":"文集","permalink":"https://xie-peiquan.gitee.io/tags/%E6%96%87%E9%9B%86/"},{"name":"通俗信号处理","slug":"通俗信号处理","permalink":"https://xie-peiquan.gitee.io/tags/%E9%80%9A%E4%BF%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"STL","slug":"STL","permalink":"https://xie-peiquan.gitee.io/tags/STL/"},{"name":"CLI程序","slug":"CLI程序","permalink":"https://xie-peiquan.gitee.io/tags/CLI%E7%A8%8B%E5%BA%8F/"},{"name":"线程局部变量","slug":"线程局部变量","permalink":"https://xie-peiquan.gitee.io/tags/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"name":"日志记录","slug":"日志记录","permalink":"https://xie-peiquan.gitee.io/tags/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"},{"name":"IO复用","slug":"IO复用","permalink":"https://xie-peiquan.gitee.io/tags/IO%E5%A4%8D%E7%94%A8/"},{"name":"SQLite","slug":"SQLite","permalink":"https://xie-peiquan.gitee.io/tags/SQLite/"},{"name":"聊点音乐","slug":"聊点音乐","permalink":"https://xie-peiquan.gitee.io/tags/%E8%81%8A%E7%82%B9%E9%9F%B3%E4%B9%90/"},{"name":"MySQL","slug":"MySQL","permalink":"https://xie-peiquan.gitee.io/tags/MySQL/"},{"name":"CMake","slug":"CMake","permalink":"https://xie-peiquan.gitee.io/tags/CMake/"},{"name":"并发编程","slug":"并发编程","permalink":"https://xie-peiquan.gitee.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"混合编程","slug":"混合编程","permalink":"https://xie-peiquan.gitee.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"C++库","slug":"C-库","permalink":"https://xie-peiquan.gitee.io/tags/C-%E5%BA%93/"},{"name":"ROS1","slug":"ROS1","permalink":"https://xie-peiquan.gitee.io/tags/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"https://xie-peiquan.gitee.io/tags/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"https://xie-peiquan.gitee.io/tags/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"https://xie-peiquan.gitee.io/tags/%E5%BB%BA%E7%AB%99/"}]}