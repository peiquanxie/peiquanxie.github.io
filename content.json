{"meta":{"title":"PQ.XIE BLOG","subtitle":"","description":"个人博客","author":"PQ.XIE","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-07-22T02:40:44.436Z","updated":"2023-07-22T02:40:44.436Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-07-28T09:11:55.709Z","updated":"2023-07-28T09:11:55.709Z","comments":true,"path":"baidu_verify_codeva-3bR1bjdnkE.html","permalink":"http://example.com/baidu_verify_codeva-3bR1bjdnkE.html","excerpt":"","text":"e522504a2b93d12f0dc162fcc0572c79"},{"title":"","date":"2023-07-28T09:26:16.461Z","updated":"2023-07-28T09:26:16.461Z","comments":true,"path":"googlef847041eb4e8ca77.html","permalink":"http://example.com/googlef847041eb4e8ca77.html","excerpt":"","text":"google-site-verification: googlef847041eb4e8ca77.html"},{"title":"","date":"2023-07-26T09:27:47.030Z","updated":"2023-07-26T09:27:47.030Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系方式邮箱：&#50;&#49;&#50;&#57;&#53;&#x31;&#x36;&#x39;&#50;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d; 版权声明站点内的所有原创内容（包括但不限于文章、图像等）除特别声明外均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，任何人都可以自由传播，但不得用于商用且必须署名并以相同方式分享。本站部分内容转载于网络，有出处的已在文中署名作者并附加原文链接，出处已不可寻的皆已标注来源于网络。若您认为本站点有部分内容侵犯了您的权益，请在电邮告知，我将认真处理。"},{"title":"所有分类","date":"2023-07-22T02:37:26.591Z","updated":"2023-07-22T02:37:26.591Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-26T09:31:42.263Z","updated":"2023-07-26T09:31:42.263Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-22T02:37:59.687Z","updated":"2023-07-22T02:37:59.687Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"9-action通信机制简汇","slug":"ROS1/9-action通信机制简汇","date":"2023-09-04T09:12:07.398Z","updated":"2023-09-04T09:12:07.454Z","comments":true,"path":"2023/09/04/ROS1/9-action通信机制简汇/","link":"","permalink":"http://example.com/2023/09/04/ROS1/9-action%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"action实现了一种类似于service的请求&#x2F;响应通讯机制，区别在于action带有反馈机制，用来不断向客户端反馈任务的进度，并且还支持在任务中途中止运行。操作起来就像这样子，客户端给服务端抛出一个目标，然后客户端就可以去干别的事情了，在任务执行期间，客户端会以消息的形式，周期性地接收到来自服务端的进度反馈，如果没有终止任务的话这个过程会一直延续到收到最终的结果。当然也可以随时终止当前的操作，开始一个全新的操作。 1 action的实现机制action 的 client和server之间通过actionlib定义的“action protocol”进行通讯。这种通讯协议是基于ROS的 topic 机制实现的，为用户提供了client和server的接口，接口如下图所示： goal：client 发送任务目标 cancel：client 请求取消任务 status：server通知client当前的状态 feedback：server周期反馈任务运行的监控数据 result：server向client发送任务的执行结果，这个topic只会发布一次。 2 自定义接口2.1 action文件编写在 ros_ws&#x2F;src&#x2F;hello&#x2F;action目录下创建 DoDishes.action接口文件，注意首字母必须大写。接口示例如下： 12345678# Define the goaluint32 dishwasher_id---# Define the resultuint32 total_dishes_cleaned---# Define a feedback messagefloat32 percent_complete 2.2 编译修改 CMakeLists修改：在对应位置进行如下修改：(查找对应项改，不要改变各项的顺序) 123find_package(catkin REQUIRED ... genmsg actionlib_msgs actionlib)add_action_files(DIRECTORY action FILES DoDishes.action)generate_messages(DEPENDENCIES ... actionlib_msgs) package.xml修改：在对应位置添加如下： 1234&lt;build_depend&gt;actionlib&lt;/build_depend&gt;&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;&lt;exec_depend&gt;actionlib&lt;/exec_depend&gt;&lt;exec_depend&gt;actionlib_msgs&lt;/exec_depend&gt; 编译完成之后会在 devel&#x2F;share&#x2F;hello&#x2F;msg&#x2F; 目录下产生相关的.msg文件： 2 action Client（CPP）注意要将**DoDishesAction **的前缀修改为自己创建的功能包名字。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;actionlib/client/simple_action_client.h&gt;#include &quot;hello/DoDishesAction.h&quot;typedef actionlib::SimpleActionClient&lt;hello::DoDishesAction&gt; Client;// 当action完成后会调用次回调函数一次void doneCb(const actionlib::SimpleClientGoalState&amp; state, const hello::DoDishesResultConstPtr&amp; result)&#123; ROS_INFO(&quot;Yay! The dishes are now clean&quot;); ros::shutdown();&#125;// 当action激活后会调用次回调函数一次void activeCb()&#123; ROS_INFO(&quot;Goal just went active&quot;);&#125;// 收到feedback后调用的回调函数void feedbackCb(const hello::DoDishesFeedbackConstPtr&amp; feedback)&#123; ROS_INFO(&quot; percent_complete : %f &quot;, feedback-&gt;percent_complete);&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;do_dishes_client&quot;); // 定义一个客户端 Client client(&quot;do_dishes&quot;, true); // 等待服务器端 ROS_INFO(&quot;Waiting for action server to start.&quot;); client.waitForServer(); ROS_INFO(&quot;Action server started, sending goal.&quot;); // 创建一个action的goal hello::DoDishesGoal goal; goal.dishwasher_id = 1; // 发送action的goal给服务器端，并且设置回调函数 client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb); ros::spin(); return 0;&#125; 3 action Client（Python）123456789101112131415161718#! /usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;my_pkg_name&#x27;)import rospyimport actionlibfrom chores.msg import DoDishesAction, DoDishesGoalif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;do_dishes_client&#x27;) client = actionlib.SimpleActionClient(&#x27;do_dishes&#x27;, DoDishesAction) client.wait_for_server() goal = DoDishesGoal() # Fill in the goal here client.send_goal(goal) client.wait_for_result(rospy.Duration.from_sec(5.0)) 4 action Server（CPP）123456789101112131415161718192021222324252627282930313233343536#include &lt;ros/ros.h&gt;#include &lt;actionlib/server/simple_action_server.h&gt;#include &quot;hello/DoDishesAction.h&quot;typedef actionlib::SimpleActionServer&lt;hello::DoDishesAction&gt; Server;// 收到action的goal后调用的回调函数void execute(const hello::DoDishesGoalConstPtr&amp; goal, Server* as)&#123; ros::Rate r(1); hello::DoDishesFeedback feedback; ROS_INFO(&quot;Dishwasher %d is working.&quot;, goal-&gt;dishwasher_id); // 假设洗盘子的进度，并且按照1hz的频率发布进度feedback for(int i=1; i&lt;=10; i++) &#123; feedback.percent_complete = i * 10; as-&gt;publishFeedback(feedback); r.sleep(); &#125; // 当action完成后，向客户端返回结果 ROS_INFO(&quot;Dishwasher %d finish working.&quot;, goal-&gt;dishwasher_id); as-&gt;setSucceeded();&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, &quot;do_dishes_server&quot;); ros::NodeHandle n; // 定义一个服务器 Server server(n, &quot;do_dishes&quot;, boost::bind(&amp;execute, _1, &amp;server), false); // 服务器开始运行 server.start(); ros::spin(); return 0;&#125; 5 action Server（Python）1234567891011121314151617181920212223#! /usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;my_pkg_name&#x27;)import rospyimport actionlibfrom chores.msg import DoDishesActionclass DoDishesServer: def __init__(self): self.server = actionlib.SimpleActionServer(&#x27;do_dishes&#x27;, DoDishesAction, self.execute, False) self.server.start() def execute(self, goal): # Do lots of awesome groundbreaking robot stuff here self.server.set_succeeded()if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;do_dishes_server&#x27;) server = DoDishesServer() rospy.spin() http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"8-坐标变换TF简述","slug":"ROS1/8-坐标变换TF简述","date":"2023-09-04T03:16:23.916Z","updated":"2023-09-04T03:16:23.964Z","comments":true,"path":"2023/09/04/ROS1/8-坐标变换TF简述/","link":"","permalink":"http://example.com/2023/09/04/ROS1/8-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2TF%E7%AE%80%E8%BF%B0/","excerpt":"","text":"在一个机器人系统中，一般会存在多个部件，每个部件可能会有自己的运动轨迹，这样在一个机器人中就存在多个坐标系。通常，我们会根据坐标系间的差距来驱动某个部件的运动，这里就存在坐标变换。这里简单举例，如下图(古月居)，我们常见的ROS小车激光雷达测距，假设这里只存在车身和雷达两个部件，这里有两个坐标系：车身坐标系（base_link）和雷达坐标系（base_laser）。雷达测距的结果是墙面相对于雷达坐标系的距离，而通常我们需要车身相对于墙面的距离，这里就需要将雷达距离转换为车身距离。 1 TF 功能包ROS中的TF功能包为我们提供坐标变换功能，可以帮助我们免去复杂的坐标转换。以下为TF常用命令： rosrun tf tf_echo node1 node2 该命令可用于查看两个坐标系之间的差距。rosrun rviz rviz -d &#39;rospack find turtle_tf&#39; /rviz/turtle_rviz.rviz 可视化坐标系之间的关系。 2 坐标系广播（CPP）1234567891011121314151617181920212223242526272829303132#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;#include &lt;turtlesim/Pose.h&gt;std::string turtle_name;void poseCallback(const turtlesim::PoseConstPtr&amp; msg)&#123; // 创建tf的广播器 static tf::TransformBroadcaster br; // 初始化tf数据 tf::Transform transform; transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) ); tf::Quaternion q; q.setRPY(0, 0, msg-&gt;theta); transform.setRotation(q); // 广播world与海龟坐标系之间的tf数据 br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;world&quot;, turtle_name));&#125;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_broadcaster&quot;); turtle_name = argv[1]; // 订阅海龟的位姿话题 ros::NodeHandle node; ros::Subscriber sub = node.subscribe(turtle_name+&quot;/pose&quot;, 10, &amp;poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125;; cmake修改，在CMakeLists里面找到以下项并修改： 1234567find_package(catkin REQUIRED COMPONENTS ...... tf turtlesim)add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)target_link_libraries(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;) 3 坐标系广播（Python）12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport tfimport turtlesim.msgdef handle_turtle_pose(msg, turtlename): br = tf.TransformBroadcaster() br.sendTransform((msg.x, msg.y, 0), tf.transformations.quaternion_from_euler(0, 0, msg.theta), rospy.Time.now(), turtlename, &quot;world&quot;)if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_broadcaster&#x27;) turtlename = rospy.get_param(&#x27;~turtle&#x27;) rospy.Subscriber(&#x27;/%s/pose&#x27; % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename) rospy.spin() 4 坐标系监听（CPP）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_listener&quot;); // 创建节点句柄 ros::NodeHandle node; // 请求产生turtle2 ros::service::waitForService(&quot;/spawn&quot;); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); turtlesim::Spawn srv; add_turtle.call(srv); // 创建发布turtle2速度控制指令的发布者 ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle2/cmd_vel&quot;, 10); // 创建tf的监听器 tf::TransformListener listener; ros::Rate rate(10.0); while (node.ok()) &#123; // 获取turtle1与turtle2坐标系之间的tf数据 tf::StampedTransform transform; try &#123; listener.waitForTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), ros::Duration(3.0)); listener.lookupTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), transform); &#125; catch (tf::TransformException &amp;ex) &#123; ROS_ERROR(&quot;%s&quot;,ex.what()); ros::Duration(1.0).sleep(); continue; &#125; // 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令 geometry_msgs::Twist vel_msg; vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(), transform.getOrigin().x()); vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) + pow(transform.getOrigin().y(), 2)); turtle_vel.publish(vel_msg); rate.sleep(); &#125; return 0;&#125;; 5 坐标系监听（Python）1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-import roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport mathimport tfimport geometry_msgs.msgimport turtlesim.srvif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_listener&#x27;) listener = tf.TransformListener() rospy.wait_for_service(&#x27;spawn&#x27;) spawner = rospy.ServiceProxy(&#x27;spawn&#x27;, turtlesim.srv.Spawn) spawner(4, 2, 0, &#x27;turtle2&#x27;) turtle_vel = rospy.Publisher(&#x27;turtle2/cmd_vel&#x27;, geometry_msgs.msg.Twist,queue_size=1) rate = rospy.Rate(10.0) while not rospy.is_shutdown(): try: (trans,rot) = listener.lookupTransform(&#x27;/turtle2&#x27;, &#x27;/turtle1&#x27;, rospy.Time(0)) except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException): continue angular = 4 * math.atan2(trans[1], trans[0]) linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2) cmd = geometry_msgs.msg.Twist() cmd.linear.x = linear cmd.angular.z = angular turtle_vel.publish(cmd) rate.sleep() http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"7-launch启动节点","slug":"ROS1/7-launch启动节点","date":"2023-09-03T16:46:30.237Z","updated":"2023-09-03T16:46:30.297Z","comments":true,"path":"2023/09/04/ROS1/7-launch启动节点/","link":"","permalink":"http://example.com/2023/09/04/ROS1/7-launch%E5%90%AF%E5%8A%A8%E8%8A%82%E7%82%B9/","excerpt":"","text":"1 基本语法 &lt;launch&gt; launch文件中的根元素采用&lt;launch&gt;标签定义 &lt;node&gt; 启动节点，格式： 1&lt;node pkg=&quot;package-name&quot; name=&quot;node-name&quot; type=&quot;exec-name&quot;/&gt; 其中，pkg 是节点所在功能包名称，type是节点的可执行文件名称，name是节点运行时名称，可取代源码中的节点名。除此之外，还有output参数，可控制日志是否打印在终端里面；respawn可以控制节点如果挂掉是否要重新拉起；required可以控制某个节点是否要启动；ns可以给节点添加域名空间；args可以给节点输入参数。 &lt;param&gt; &#x2F; &lt;rosparam&gt; 设置ROS系统运行中的参数，存储在参数服务器中。格式： 12设置某个值形式：&lt;param name=&quot;output_frame&quot; value=&quot;odom&quot;/&gt;加载参数文件形式：&lt;rosparam file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; 注：写在&lt;node&gt;里面的 param 其在参数服务器的名字为 node-name&#x2F;param-name,多了node-name的前缀。 &lt;arg&gt; launch文件内部的局部变量，仅限于launch文件使用，格式： 1234&lt;arg name=&quot;arg-name&quot; default=&quot;arg-value&quot;/&gt;调用：&lt;param name=&quot;foo&quot; value=&quot;$(arg arg-name)&quot;/&gt;&lt;node pkg=&quot;package-name&quot; name=&quot;node-name&quot; type=&quot;exec-name&quot; args=&quot;$(arg arg-name)&quot;/&gt; &lt;remap&gt; 重映射ROS计算图资源的命名，格式： 1&lt;remap from=&quot;/turtlebot/cmd_vel&quot; to=&quot;/cmd_vel&quot;/&gt; &lt;include&gt; 包含其他 launch 文件，类似C语言中的头文件包含，格式： 1&lt;include file=&quot;$(dirname)/other.launch&quot;/&gt; 2 创建 launch 文件在 ros_ws&#x2F;src&#x2F;hello&#x2F;launch 目录下创建 simple.launch文件。 1234&lt;launch&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_subscriber&quot; name=&quot;talker&quot; output=&quot;screen&quot; /&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_publisher&quot; name=&quot;listener&quot; output=&quot;screen&quot; /&gt; &lt;/launch&gt; 3 运行 launch文件1234cd ros_wscatkin_makesource devel/setup.bashroslaunch &lt;pack-name&gt; &lt;launch-name&gt;","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"6-param通信机制简汇","slug":"ROS1/6-param通信机制简汇","date":"2023-09-03T16:46:29.861Z","updated":"2023-09-03T16:46:29.969Z","comments":true,"path":"2023/09/04/ROS1/6-param通信机制简汇/","link":"","permalink":"http://example.com/2023/09/04/ROS1/6-param%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 全局参数模型 1.1 全局参数配置（CPP）1234567891011121314151617181920212223242526272829#include &lt;string&gt;#include &lt;ros/ros.h&gt;#include &lt;std_srvs/Empty.h&gt;int main(int argc, char **argv)&#123; int red, green, blue; // ROS节点初始化 ros::init(argc, argv, &quot;parameter_config&quot;); // 创建节点句柄 ros::NodeHandle node; // 读取背景颜色参数 ros::param::get(&quot;/background_r&quot;, red); ros::param::get(&quot;/background_g&quot;, green); ros::param::get(&quot;/background_b&quot;, blue); ROS_INFO(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue); // 设置背景颜色参数 ros::param::set(&quot;/background_r&quot;, 255); ros::param::set(&quot;/background_g&quot;, 255); ros::param::set(&quot;/background_b&quot;, 255); ROS_INFO(&quot;Set Backgroud Color[255, 255, 255]&quot;); // 调用服务，刷新背景颜色 ros::service::waitForService(&quot;/clear&quot;); ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(&quot;/clear&quot;); std_srvs::Empty srv; clear_background.call(srv); sleep(1); return 0;&#125; 1.2 全局参数配置（Python）与CPP类似，只是API稍微不同，get &#x2F; set接口如下： 12red = rospy.get_param(&#x27;/background_r&#x27;)rospy.set_param(&quot;/background_r&quot;, 255)","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"5-service通信机制简汇","slug":"ROS1/5-service通信机制简汇","date":"2023-09-03T08:26:35.431Z","updated":"2023-09-03T08:26:35.495Z","comments":true,"path":"2023/09/03/ROS1/5-service通信机制简汇/","link":"","permalink":"http://example.com/2023/09/03/ROS1/5-service%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 Client（CPP）123456789101112131415161718192021222324252627#include &lt;ros/ros.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;turtle_spawn&quot;); // 创建节点句柄 ros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service（阻塞） ros::service::waitForService(&quot;/spawn&quot;); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); // 初始化turtlesim::Spawn的请求数据 turtlesim::Spawn srv; srv.request.x = 2.0; srv.request.y = 2.0; srv.request.name = &quot;turtle2&quot;; // 请求服务调用 ROS_INFO(&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;, srv.request.x, srv.request.y, srv.request.name.c_str()); //同步阻塞 add_turtle.call(srv); // 显示服务调用结果 ROS_INFO(&quot;Spwan turtle successfully [name:%s]&quot;, srv.response.name.c_str()); return 0;&#125;; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(turtle_spawn src/turtle_spawn.cpp)target_link_libraries(turtle_spawn $&#123;catkin_LIBRARIES&#125;) 2 Client（Python）1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-import sysimport rospyfrom turtlesim.srv import Spawn if __name__ == &quot;__main__&quot;: # ROS节点初始化 rospy.init_node(&#x27;turtle_spawn&#x27;) # 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/spawn&#x27;) try: add_turtle = rospy.ServiceProxy(&#x27;/spawn&#x27;, Spawn) # 请求服务调用，输入请求数据 # 也可以调用 add_turtle.call() response = add_turtle(2.0, 2.0, 0.0, &quot;turtle2&quot;) return response.name except rospy.ServiceException as e: print (&quot;Service call failed: %s&quot;%e) cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/turtle_spawn.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 3 Server（CPP）12345678910111213141516171819202122232425262728293031323334353637#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;std_srvs/Trigger.h&gt;// service回调函数，输入参数req，输出参数resbool commandCallback(std_srvs::Trigger::Request &amp;req, std_srvs::Trigger::Response &amp;res)&#123; // 设置反馈数据 res.success = true; res.message = &quot;Change turtle command state!&quot;; return true;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;turtle_command_server&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/turtle_command的server，注册回调函数commandCallback ros::ServiceServer command_service = n.advertiseService(&quot;/turtle_command&quot;, commandCallback); // 循环等待回调函数 ROS_INFO(&quot;Ready to receive turtle command.&quot;); // 设置循环的频率 ros::Rate loop_rate(10); while(ros::ok()) &#123; // 查看一次回调函数队列 ros::spinOnce(); // 业务代码..... //按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(turtle_command_server src/turtle_command_server.cpp)target_link_libraries(turtle_command_server $&#123;catkin_LIBRARIES&#125;) 4 Server（Python）12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyimport thread,timefrom std_srvs.srv import Trigger, TriggerResponsedef command_thread(): while True: if pubCommand: vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 turtle_vel_pub.publish(vel_msg) time.sleep(0.1)def commandCallback(req): global pubCommand pubCommand = bool(1-pubCommand) # 显示请求数据 rospy.loginfo(&quot;Publish turtle velocity command![%d]&quot;, pubCommand) # 反馈数据 return TriggerResponse(1, &quot;Change turtle command state!&quot;)if __name__ == &quot;__main__&quot;: # ROS节点初始化 rospy.init_node(&#x27;turtle_command_server&#x27;) # 创建一个名为/turtle_command的server，注册回调函数commandCallback s = rospy.Service(&#x27;/turtle_command&#x27;, Trigger, commandCallback) # 循环等待回调函数 print &quot;Ready to receive turtle command.&quot; # 由于python没有spinOnce()接口，因此新启一个线程 thread.start_new_thread(command_thread, ()) rospy.spin() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/turtle_command_server.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 5 自定义接口5.1 srv文件编写在 ros_ws&#x2F;src&#x2F;hello&#x2F;srv目录下创建 Person.srv 接口文件，注意首字母必须大写。接口示例如下： 12345string nameuint8 ageuint8 sex---string result 接口中，— 以上为request内容，以下为response内容。 编译修改： CMakeLists修改：在对应位置进行如下修改： 1234find_package(...... message_generation)add_message_files(FILES Person.srv)generate_messages(DEPENDENCIES std_msgs)catkin_package(...... message_runtime) package.xml修改：在对应位置添加如下： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 自定义接口需经过编译形成C++和Python的引用文件，可以在devel&#x2F;include里面找到C++所需的.h接口文件。 5.2 C&#x2F;S代码编写Client &#x2F; Server 代码与前几节几乎一模一样，这里不再赘述。 编译修改：由于应用代码对接口产生依赖，因此在编译应用代码时，也应添加相应的依赖（Python不需要）： 1add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp) http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"4-topic通信机制简汇","slug":"ROS1/4-topic通信机制简汇","date":"2023-09-03T08:26:35.103Z","updated":"2023-09-03T08:26:35.163Z","comments":true,"path":"2023/09/03/ROS1/4-topic通信机制简汇/","link":"","permalink":"http://example.com/2023/09/03/ROS1/4-topic%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 Publisher（CPP）12345678910111213141516171819202122232425262728#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;publisher&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 ros::Publisher = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10); // 设置循环的频率 ros::Rate loop_rate(10); while (ros::ok()) &#123; // 初始化geometry_msgs::Twist类型的消息 geometry_msgs::Twist vel_msg; vel_msg.linear.x = 0.5; vel_msg.angular.z = 0.2; // 发布消息 turtle_vel_pub.publish(vel_msg); ROS_INFO(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z); // 按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(publisher src/publisher.cpp)target_link_libraries(publisher $&#123;catkin_LIBRARIES&#125;) 2 Publisher（Python）123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom geometry_msgs.msg import Twist# ROS节点初始化rospy.init_node(&#x27;publisher&#x27;, anonymous=True)# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)#设置循环的频率rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) rate.sleep() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/publisher.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 3 Subscriber（C++）123456789101112131415161718192021222324#include &lt;ros/ros.h&gt;#include &quot;turtlesim/Pose.h&quot;// 接收到订阅的消息后，会进入消息回调函数// turtlesim::Pose为消息类型，来源于 #include &quot;turtlesim/Pose.h&quot;void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg-&gt;x, msg-&gt;y);&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;subscriber&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;, 10, poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(subscriber src/subscriber.cpp)target_link_libraries(subscriber $&#123;catkin_LIBRARIES&#125;) 4 Subscriber（Python）123456789101112131415#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)# ROS节点初始化rospy.init_node(&#x27;subscriber&#x27;, anonymous=True)# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback# Pose为消息类型，来源于 from turtlesim.msg import Poserospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)# 循环等待回调函数rospy.spin() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/subscriber.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 5 自定义接口5.1 msg文件编写在 ros_ws&#x2F;src&#x2F;hello&#x2F;msg目录下创建 Person.msg 接口文件，注意首字母必须大写。接口示例如下： 12345678string nameuint8 sexuint8 age# 以下相当于宏uint8 unknown = 0uint8 male = 1uint8 female = 2 编译修改： CMakeLists修改：在对应位置进行如下修改： 1234find_package(...... message_generation)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs)catkin_package(...... message_runtime) package.xml修改：在对应位置添加如下： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 自定义接口需经过编译形成C++和Python的引用文件，可以在devel&#x2F;include里面找到C++所需的.h接口文件。 5.2 发布&#x2F;订阅代码编写发布&#x2F;订阅代码与前几节几乎一模一样，这里不再赘述。对于接口里面的宏的引用，在C++里面这样引用：learning_topic::Person::male; Python里面这样引用：Person.male 。 编译修改：由于应用代码对接口产生依赖，因此在编译应用代码时，也应添加相应的依赖（Python不需要）： 1add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp) http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"3-ROS1快速开始","slug":"ROS1/3-ROS1快速开始","date":"2023-09-03T08:26:34.687Z","updated":"2023-09-03T08:26:34.739Z","comments":true,"path":"2023/09/03/ROS1/3-ROS1快速开始/","link":"","permalink":"http://example.com/2023/09/03/ROS1/3-ROS1%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"1 创建功能包1.1 创建工作空间123mkdir -p ros_ws/srccd ros_ws/srccatkin_init_workspace 1.2 创建功能包12catkin_create_pkg hello std_msgs roscpp rospy格式：catkin_create_pkg &lt;pkg_name&gt; &lt;depend&gt; &lt;depend&gt; 1.3 编译工作空间12cd ..catkin_make 1.4 激活环境变量1source devel/setup.bash 注：同一个工作空间不能有同名功能包；不同工作空间可以有同名功能包。 2 编写CPP节点2.1 创建节点文件在 ros_ws&#x2F;src&#x2F;hello&#x2F;src 目录下创建hello.cpp 节点文件。 2.1 节点代码12345678910111213#include &lt;ros/ros.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;hello_node&quot;); // 创建节点句柄 ros::NodeHandle n; ROS_INFO(&quot;Hello world.&quot;); ros::spin(); return 0;&#125; 2.2 修改CmakeLists修改 ros_ws&#x2F;src&#x2F;hello&#x2F;src&#x2F;CmakeLists，找到以下项，并进行如下修改： 1234567## 编译节点源码，hello_node为节点可执行文件名字，可以与源码指定的节点名字一致add_executable(hello_node src/hello.cpp)## 添加链接库target_link_libraries(hello_node $&#123;catkin_LIBRARIES&#125;) 2.3 编译运行1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello_node 3 编写Python节点3.1 创建节点文件在 ros_ws&#x2F;src&#x2F;hello&#x2F;scripts 目录下创建hello.py节点文件。 2.1 节点代码12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-import rospy if __name__ == &#x27;__main__&#x27;: # ROS节点初始化 rospy.init_node(&#x27;hello_node_py&#x27;) rospy.loginfo(&#x27;hello world.&#x27;) rospy.spin() 2.2 修改CmakeLists修改 ros_ws&#x2F;src&#x2F;hello&#x2F;src&#x2F;CmakeLists，找到以下项，并进行如下修改： 12345## 添加节点python脚本，python无需编译，只需添加到路径即可catkin_install_python(PROGRAMS scripts/hello.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 2.3 编译运行1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello.py http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"2-ROS1命令汇总","slug":"ROS1/2-ROS1命令汇总","date":"2023-09-03T08:26:34.255Z","updated":"2023-09-04T02:03:07.561Z","comments":true,"path":"2023/09/03/ROS1/2-ROS1命令汇总/","link":"","permalink":"http://example.com/2023/09/03/ROS1/2-ROS1%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"","text":"1 node相关命令rosnode listrosnode info &lt;node_name&gt;rosnode ping &lt;node_name&gt;rosnode ping –allrosnode kill &lt;node_name&gt;rosnode kill –all 2 topic相关命令rostopic listrostopic type &lt;topic_name&gt;rostopic info &lt;topic_name&gt; 查看话题具体信息(消息类型，发布&#x2F;订阅者)rostopic echo &lt;topic_name&gt; 实时查看话题内容rostopic hz &lt;topic_name&gt;rostopic bw &lt;topic_name&gt;rostopic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;message_content&gt; 3 msg相关命令rosmsg show &lt;msg_name&gt; 查看消息格式 5 service相关命令rosservice listrosservice call &lt;ser_name&gt;rosservice type &lt;ser_name&gt;rosservice findrosservice uri 6 param相关命令rosparam setrosparam getrosparam loadrosparam deleterosparam list 7 pkg相关命令rospack find &lt;pkg_name&gt;rospack list 8 run节点：rosrun &lt;pkg_name&gt; &lt;node_name&gt; 9 记录运行话题记录：rosbag record -a -O cmd_record话题复现：rosbag play cmd_record.bag 10 可视化：rqt:rqt_console 终端控制台rqt_plot 绘制波形曲线rqt_graph 查看节点关联关系rqt_image_view 查看摄像头图像 rviz：可用于构建机器人模型、坐标、点云、图像、导航、运动规划等等。 gazebo:用于三维物理仿真 http://wiki.ros.org/cn/ROS/Tutorials","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"1-ROS概览","slug":"ROS1/1-ROS概览","date":"2023-09-03T08:26:33.919Z","updated":"2023-09-03T08:26:33.971Z","comments":true,"path":"2023/09/03/ROS1/1-ROS概览/","link":"","permalink":"http://example.com/2023/09/03/ROS1/1-ROS%E6%A6%82%E8%A7%88/","excerpt":"","text":"ROS: Robot Operating SystemROS已经成为机器人领域的普遍标准.ROS包含：通信框架 + 开发工具 + 应用功能 + 生态系统开发工具包括：CLI命令，rqt，Rviz，TF-Tree，Gazebo仿真等等。应用功能包括：导航Navigation，建图SLAM，机械臂规划Movelt等等。生态系统包括：发行版，软件源，wiki，Blog等等。 相关概念：节点（Node）– 执行单元 执行具体任务的进程、独立运行的可执行文件。 不同节点可使用不同的编程语言，可分布式运行在不同的主机。 节点在系统中的名称必须是唯一的。 节点管理器（ROS Master）– 控制中心 为节点提供命名和注册服务。 跟踪和记录话题&#x2F;服务通信，辅助节点相互查找、建立连接。 提供参数服务器，节点使用该服务器存储和检索运行时的参数。 话题（Topic）– 异步通信机制 节点间用来传输数据的重要总线。 使用发布&#x2F;订阅模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一。 消息（Message） – 话题接口 具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义的类型。 使用编程语言无关的.msg文件定义，编译过程中生成对应的代码文件。 服务（Service）– 同步通信机制 使用客户端&#x2F;服务端（C&#x2F;S）模型，客户端发送请求数据，服务器完成处理后返回应答数据。 使用编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件。 话题和服务的区别： 参数（Parameter）– 全局共享字典 可通过网络访问的共享、多变量字典。 节点使用此服务器来存储和检索运行时的参数。 适合存储静态、非二进制的配置参数，不适合存储动态配置的数据。 功能包（Package） ROS软件中的基本单元，包含节点源码、配置文件、数据定义等。 功能包清单（Package Manifest） 记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。 元功能包（Meta Package） 组织多个用于同一目的的功能包 http://wiki.ros.org/cn/ROS/Tutorialshttps://www.guyuehome.com/bubble/index","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"7-ROS2通信汇总(Python篇)","slug":"ROS2基础/7-ROS2 通信汇总(Python篇)","date":"2023-08-20T09:29:20.492Z","updated":"2023-08-20T09:29:20.540Z","comments":true,"path":"2023/08/20/ROS2基础/7-ROS2 通信汇总(Python篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/7-ROS2%20%E9%80%9A%E4%BF%A1%E6%B1%87%E6%80%BB(Python%E7%AF%87)/","excerpt":"","text":"1 topic发布与订阅发布端接口： 12publisher_ = node.create_publisher(msg_type,&quot;topic_name&quot;, 10) publisher_.publish(msg) 订阅者接口： 1subscribe_ = node.create_subscription(msg_type, &quot;topic_name&quot;, recv_callback, 10) 2 service发送和接收client 接口： 1234client = node.create_client(srv_type,&quot;srv_name&quot;)while not client.wait_for_service(1.0): node.get_logger().warn(&quot;等待服务&quot;)client.call_async(request) # .add_done_callback(reponse_callback) server 接口： 1234server = node.create_service(srv_type,&quot;srv_name&quot;, request_callback)def request_callback(request, response): ...... return response 3 action控制与执行执行 接口： 123456789101112from rclpy.action import ActionServerfrom rclpy.action.server import ServerGoalHandleaction_server_ = ActionServer( node, action_type, &quot;action_name&quot;, execute_callback # ,callback_group=MutuallyExclusiveCallbackGroup() )def execute_callback(goal_handle: ServerGoalHandle): ... ... result = action_type.Result() result = ... return result 控制 接口： 12345678910111213141516from rclpy.action import ActionClientaction_client_ = ActionClient(node, action_type, &#x27;action_name&#x27;)goal_msg = MoveRobot.Goal()goal_msg = ...action_client_.wait_for_server()send_goal_future = action_client_.send_goal_async(goal_msg,feedback_callback=feedback_callback)send_goal_future.add_done_callback(goal_response_callback)def feedback_callback(feedback_msg): feedback = feedback_msg.feedback ... def goal_response_callback(future): goal_handle = future.result() get_result_future = goal_handle.get_result_async() get_result_future.add_done_callback(get_result_callback)","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"6-ROS2 接口介绍","slug":"ROS2基础/6-ROS2 接口介绍","date":"2023-08-20T09:29:20.220Z","updated":"2023-08-20T09:29:20.268Z","comments":true,"path":"2023/08/20/ROS2基础/6-ROS2 接口介绍/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/6-ROS2%20%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"ROS2提供了四种通信方式，包括：话题（topic）、服务（service）、动作（action）和 参数（parameter）。通信会涉及到接口，我们可以通过 ros2 interface list 列出ROS2提供的所有接口，通过 ros2 interface show &lt;interface_name&gt; 或 ros2 interface proto &lt;message_name&gt; 查看接口的具体格式。但是，当我们不能在内置接口中找到适合于我们项目的接口时，我们需要自定义接口。以下讲解如何自定义接口。 1 接口格式1.1 topic接口格式接口存放路径：interface_pkg&#x2F;msg&#x2F;Xxx.msg 12string namesensor_msgs/Image image #支持嵌套 1.2 service接口格式接口存放路径：interface_pkg&#x2F;srv&#x2F;Xxx.srv 12345string nameint32 aint64 b---int32 ret # 返回值 1.3 action接口格式接口存放路径：interface_pkg&#x2F;action&#x2F;Xxx.action 12345int32 target # 目标值 ---int32[] sequence # 差值---int32[] partial_sequence # 当前值 2 创建接口2.1 创建接口功能包1ros2 pkg create example_test_interfaces --build-type ament_cmake --dependencies rosidl_default_generators 其中，–build-type 参数值必须为 ament_cmake； –dependencies 指定功能包依赖，rosidl_default_generators必须添加，其他根据自己接口依赖添加即可，当然也可以通过事后修改 package.xml 添加依赖。创建完后可看见新增接口文件夹，目录如下： 2.2 添加接口文件将自己定义的接口放入 example_test_interfaces 文件夹合适位置，注意要按照上一节的接口格式来定义和存放接口。我们这个先定义一个简单的 topic 接口，在 example_test_interfaces 下新建 msg 目录，并在 msg 目录下新建 Test.msg 文件(首字母大写)，内容如下： 123string nameuint32 valuebool flag 2.3 修改CMakeLists文件在CMakeLists里面添加要编译的接口，为什么接口也要编译？其实ROS需要将 msg、srv、action文件转换为Python和C++的头文件，这样我们的节点代码才能读取接口。CMakeLists修改如下： 12345678# 查找依赖，有新增需添加find_package(rosidl_default_generators REQUIRED)# 生成接口头文件rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/Test.msg&quot; # DEPENDENCIES geometry_msgs # 有依赖需要添加) 2.4 修改package.xml文件12在 &lt;depend&gt;rosidl_default_generators&lt;/depend&gt; 下面添加：&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 2.5 编译接口包12cd workspacecolcon build --packages-select example_test_interfaces 2.6 查看测试12source install/setup.bashros2 interface show example_test_interfaces/msg/Test","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"5-ROS2创建第一个节点","slug":"ROS2基础/5-ROS2创建第一个节点","date":"2023-08-20T09:29:19.940Z","updated":"2023-08-20T09:29:19.992Z","comments":true,"path":"2023/08/20/ROS2基础/5-ROS2创建第一个节点/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/5-ROS2%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"1 创建cpp节点1.1 创建工作空间1mkdir -p workspace/src/ 1.2 创建功能包12cd workspace/srcros2 pkg create example_cpp --build-type ament_cmake --dependencies rclcpp 此时可以看到ROS2为我们创建了example_cpp文件夹，且该文件夹下包含include、src、CMakeLists.txt、package.xml 文件及目录。其中，src和include目录放节点源码和相应的头文件，CMakeLists.txt是编译节点源码的配置文件，package.xml是该功能包的配置文件。 1.3 创建节点在功能包的src目录下创建节点文件 mynode.cpp，该文件的main函数则为该节点的入口。cpp文件代码如下： 12345678910111213141516#include &quot;rclcpp/rclcpp.hpp&quot;int main(int argc, char **argv)&#123; /* 初始化rclcpp */ rclcpp::init(argc, argv); /*创建一个名为test_node的节点*/ auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;test_node&quot;); /*利用RCLCPP 打印*/ RCLCPP_INFO(node-&gt;get_logger(), &quot;Hello World. test_node start.&quot;); /* 运行节点，并检测退出信号 Ctrl+C*/ rclcpp::spin(node); /* 停止运行 */ rclcpp::shutdown(); return 0;&#125; 1.4 修改CMakeLists将mynode.cpp 添加到CMakeLists中，让cmake编译节点并安装节点。在CMakeLists末尾添加以下配置： 1234567add_executable(test_node src/mynode.cpp)ament_target_dependencies(test_node rclcpp)install(TARGETS test_node DESTINATION lib/$&#123;PROJECT_NAME&#125;) 1.5 编译功能包12cd workspacecolcon build --packages-select example_cpp 1.6 source环境1source install/setup.bash 1.7 运行节点1ros2 run example_cpp test_node 2 创建python节点2.1 创建工作空间1mkdir -p workspace/src/ 2.2 创建功能包12cd workspace/srcros2 pkg create example_py --build-type ament_python --dependencies rclpy 此时可以看到ROS2为我们创建了example_py文件夹，且该文件夹下包含example_py、resource、test、package.xml、setup.py、setup.cfg文件及目录。其中，example_py文件夹放我们的节点代码。 2.3 创建节点在功能包的example_py目录下创建节点文件 mynode.py，该文件的main函数则为该节点的入口。python文件代码如下： 123456789101112import rclpyfrom rclpy.node import Nodedef main(args=None): # 初始化rclpy rclpy.init(args=args) # 创建一个test_node node = Node(&quot;test_node_py&quot;) node.get_logger().info(&quot;Hello World. node_py start.&quot;) # 保持节点运行 rclpy.spin(node) rclpy.shutdown() 2.4 修改 setup.py在setup文件中声明该python节点，以及指定该节点的入口。这样之后使用colcon build才能检测到该节点，从而将其添加到install目录下。修改如下： 123456 entry_points=&#123; &#x27;console_scripts&#x27;: [ &quot;test_node_py = example_py.mynode:main&quot; ], &#125;,) 2.5 编译功能包12cd workspacecolcon build --packages-select example_py 2.6 source环境1source install/setup.bash 2.7 运行节点1ros2 run example_py test_node_py","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"4-ROS2命令行汇总","slug":"ROS2基础/4-ROS2命令行汇总","date":"2023-08-20T09:29:19.576Z","updated":"2023-08-20T09:29:19.624Z","comments":true,"path":"2023/08/20/ROS2基础/4-ROS2命令行汇总/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/4-ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B1%87%E6%80%BB/","excerpt":"","text":"0 节点运行命令 命令格式： ros2 run &lt;package_name&gt; &lt;node_name&gt; 1 pkg相关命令1.1 ros2 pkg create 命令功能：创建功能包并指定包相关参数命令格式：ros2 pkg create &lt;pkgname&gt; –build-type &lt;ament_python&gt; –node-name &lt;xx_node&gt; –dependencies &lt;rclpy&gt;参数列表： 参数 参数作用 参数示例 –build-type 指定编译类型 ament_python &#x2F; ament_cmake –node-name 指定要生成的源码文件，可以后期创建 xxx.py &#x2F; xxx.cpp –dependencies 指定依赖模块 rclpy &#x2F; std_msgs &#x2F; sensor_msgs 1.2 ros2 pkg list 命令功能：查看系统中功能包列表命令格式：ros2 pkg list注意：记得要通过source指令将自己的功能包添加到ROS2环境中。 1.3 ros2 pkg executables 命令功能：查看功能包内所有可执行节点命令格式：ros2 pkg executables &lt;package_name&gt; 2 node相关命令2.1 ros2 node list 命令功能： 查看当前域内（ROS_DOMAIN_ID）的节点列表命令格式： ros2 node list 2.2 ros2 node info 命令功能： 查看节点详细信息，包括订阅、发布的消息，开启的服务和动作等命令格式： ros2 node info &lt;node_name&gt; 3 topic相关命令3.1 ros2 topic list 命令功能：列出域内可使用的topic列表命令格式：ros2 topic list 3.2 ros2 topic info 命令功能：显示主题消息类型，订阅者数量，发布者数量等命令格式：ros2 topic info &lt;topic_name&gt; 3.3 ros2 topic type 命令功能：查看主题消息类型命令格式：ros2 topic type &lt;topic_name&gt; 3.4 ros2 topic find 命令功能：按消息类型查找相关主题命令格式：ros2 topic find &lt;message_type&gt; 3.5 ros2 topic hz 命令功能：显示主题平均发布频率命令格式：ros2 topic hz &lt;topic_name&gt; 3.6 ros2 topic bw 命令功能：显示所查阅主题的带宽命令格式：ros2 topic bw &lt;topic_name&gt; 3.7 ros2 topic delay 命令功能：通过header中的时间戳计算消息延迟命令格式：ros2 topic delay &lt;topic_name&gt; 3.8 ros2 topic echo 命令功能：在控制台显示主题消息命令格式：ros2 topic echo &lt;topic_name&gt; 3.9 ros2 topic pub 命令功能：通过命令行发布指定主题消息命令格式：ros2 topic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;message_content&gt;命令示例：ros2 topic pub control_node&#x2F;action geometry_msgs&#x2F;msg&#x2F;TwistStamped “{header: {stamp:{sec: 0, nanosec: 0}, frame_id: control_node}, twist: {linear: {x: 0.3, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}}” 4 interface相关命令4.1 ros2 interface list 命令功能：按类显示系统内所有的接口，包括消息（Messages）、服务（Services）、动作（Actions）命令格式：ros2 interface list 4.3 ros2 interface packages 命令功能：显示所有接口包命令格式：ros2 interface packages 4.2 ros2 interface package 命令功能：显示指定接口包内的子接口命令格式：ros2 interface package &lt;interface_pkg&gt; 4.3 ros2 interface show 命令功能：显示指定接口的详细内容命令格式：ros2 interface show &lt;interface_name&gt; 4.4 ros2 interface proto 命令功能：显示消息模板命令格式：ros2 interface proto &lt;message_name&gt;","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"3-ROS2系统架构","slug":"ROS2基础/3-ROS2系统架构","date":"2023-08-20T09:29:19.124Z","updated":"2023-08-20T09:29:19.176Z","comments":true,"path":"2023/08/20/ROS2基础/3-ROS2系统架构/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/3-ROS2%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1 ROS2总体架构图 1.1 DDS实现层DDS，全称 Data Distribution Service (数据分发服务)。是由对象管理组 (OMG) 于 2003 年发布并于 2007 年修订的开分布式系统标准。通过类似于ROS中的话题发布和订阅形式来进行通信，同时提供了丰富的服务质量管理来保证可靠性、持久性、传输设置等。 DDS实现层其实就是对不同常见的DDS接口进行再次的封装，让其保持统一性，为DDS抽象层提供统一的API。 1.2 DDS抽象层（rmw）这一层将DDS实现层进一步的封装，使得DDS更容易使用。原因在于DDS需要大量的设置和配置（分区，主题名称，发现模式，消息创建,…），这些设置都是在ROS2的抽象层中完成的。 2 DDS 通信模型DDS的模型是非常容易理解，我们可以定义话题的数据结构（类似于ROS2中的接口类型）。下图中的例子: Pos：一个编号id的车子的位置x,y DDS的参与者(Participant)通过发布和订阅主题数据进行通信。 DDS的应用层通过DDS进行数据订阅发布，DDS通过传输层进行数据的收发。 2.1. DDS的优势与劣势**优势** 发布&#x2F;订阅模型：简单解耦，可以轻松实现系统解耦 性能：在发布&#x2F;订阅模式中，与请求&#x2F;回复模式相比，延迟更低，吞吐量更高。 远程参与者的自动发现：此机制是 DDS 的主要功能之一。通信是匿名的、解耦的，开发者不必担心远程参与者的本地化。 丰富的 Qos 参数集，允许调整通信的各个方面：可靠性、持久性、冗余、寿命、传输设置、资源…… 实时发布订阅协议 ( RTPS )：该协议几乎可以通过任何传输实现，允许在 UDP、TCP、共享内存和用户传输中使用 DDS，并实现不同 DDS 实现之间的真正互操作性。 劣势 API复杂，DDS 的灵活性是以复杂性为代价的。 系统开销相对较大，有待数据论证。 社区支持问题，但ROS2近两年来使用DDS后社区表现还是不错的。 2.2 ROS2使用DDS的几个理由 DDS已经应用在军事、潜艇各个领域，稳定性实时性经过实际检验。 使用DDS需要维护的代码要少得多，可以让ROS2开发人员腾出手专注机器人开发。 DDS有定义好的行为和规范并且有完善的文档。 DDS提供了推荐的用例和软件API，有较好的语言支持。","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"2-ROS2安装(X86篇)","slug":"ROS2基础/2-ROS2安装(X86篇)","date":"2023-08-20T09:29:18.740Z","updated":"2023-08-20T09:29:18.792Z","comments":true,"path":"2023/08/20/ROS2基础/2-ROS2安装(X86篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/2-ROS2%E5%AE%89%E8%A3%85(X86%E7%AF%87)/","excerpt":"","text":"本篇安装环境如下： CPU架构：amd_64操作系统：ubuntu20.04 1 更换镜像源（可选）更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。amd_64&#x2F; ubuntu20.04的源如下： mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bakvim &#x2F;etc&#x2F;apt&#x2F;sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源这里同样采用清华的pip源，可加速python第三方库的下载，命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装ROS21sudo apt install ros-foxy-desktop python3-colcon-common-extensions 5 设置环境变量12source /opt/ros/foxy/setup.bashecho &quot; source /opt/ros/foxy/setup.bash&quot; &gt;&gt; ~/.bashrc 6 测试6.1 你说我听12345## 运行talkerros2 run demo_nodes_cpp talker## 新起另一个终端，运行listenerros2 run demo_nodes_py listener 6.2 小海龟12345## 运行海龟界面ros2 run turtlesim turtlesim_node## 新启一个终端，运行遥控器ros2 run turtlesim turtle_teleop_key","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"1-ROS2安装(armhf篇)","slug":"ROS2基础/1-ROS2安装(armhf篇)","date":"2023-08-20T09:29:18.360Z","updated":"2023-08-20T09:29:18.408Z","comments":true,"path":"2023/08/20/ROS2基础/1-ROS2安装(armhf篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/1-ROS2%E5%AE%89%E8%A3%85(armhf%E7%AF%87)/","excerpt":"","text":"由于ROS官方并没有提供armhf CPU架构的ROS2二进制安装文件，本篇整理了从ROS2源码编译安装的方法。本篇安装环境如下： CPU架构：armv7l操作系统：ubuntu20.04 1 更换镜像源（可选）更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。armv7l &#x2F; ubuntu20.04的源如下： mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bakvim &#x2F;etc&#x2F;apt&#x2F;sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源这里同样采用清华的pip源，可加速python第三方库的下载（后面需要），命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装编译工具123456789101112131415161718192021222324252627sudo apt update &amp;&amp; sudo apt install -y \\ libbullet-dev \\ python3-pip \\ python3-pytest-cov \\ ros-dev-tools# install some pip packages needed for testingpython3 -m pip install -U \\ argcomplete \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest# install Fast-RTPS dependenciessudo apt install --no-install-recommends -y \\ libasio-dev \\ libtinyxml2-dev# install Cyclone DDS dependenciessudo apt install --no-install-recommends -y \\ libcunit1-dev 5 获取ROS2源码12345mkdir -p ~/ros2_foxy/srccd ~/ros2_foxywget https://raw.githubusercontent.com/ros2/ros2/foxy/ros2.repos --no-check-certificate## github下载不稳定，可自行修改repos文件，添加代理前缀 https://ghproxy.com/vcs import --input ./ros2.repos src 6 使用Rosdep安装依赖1234sudo apt upgradecd /etc/ros/rosdep/sources.list.d &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/github-raw/ros/rosdistro/master/rosdep/sources.list.d/20-default.listrosdep updaterosdep install --from-paths src --ignore-src -y --skip-keys &quot;fastcdr rti-connext-dds-5.3.1 urdfdom_headers&quot; 7 编译ROS2源码12cd ~/ros2_foxy/colcon build --symlink-install 8 设置环境变量1. ~/ros2_foxy/install/local_setup.bash 9 测试1234567## 运行talker. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_cpp talker## 新起另一个终端，运行listener. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_py listener","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"1-西方哲学摘录","slug":"哲学思考/1-西方哲学摘录","date":"2023-07-26T16:16:41.776Z","updated":"2023-07-26T16:20:24.385Z","comments":true,"path":"2023/07/27/哲学思考/1-西方哲学摘录/","link":"","permalink":"http://example.com/2023/07/27/%E5%93%B2%E5%AD%A6%E6%80%9D%E8%80%83/1-%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E6%91%98%E5%BD%95/","excerpt":"","text":"黑格尔哲学形而上学形而上学的根本特征是以思维（概念）规定感性（事物），在概念中确认哲学所追求的“最高原因的基本原理”。这种基本原理可以使人类经验中的各种各样的事物得到统一性的解释，或者可以被解释为某种普遍本质的各种具体表现，从而使思维实现其把握和解释世界的“全体自由性”。 黑格尔哲学特点黑格尔以辩证法改造形而上学，是通过对构成旧形而上学的抽象理性的批判，以概念的辩证运动实现思维规定感性的形而上学，把“全体的自由性”与“环节的必然性”统一起来，从而把形而上学构建成本体论、认识论和逻辑学相统一的辩证法。这就是黑格尔在哲学上的贡献，将辩证法和形而上学“合流”，也可以认为是形而上学的“完成”。 黑格尔概念辩证法的出发点是双重的，一是思维与存在的同一性，即概念是思维和存在同一的规定性；二是思维与存在的差别的内在的发生，即概念是在自身的辩证运动中所达到的思存同一性。 黑格尔哲学意义在哲学史意义上，黑格尔的概念辩证法，构成了一种双重的“何以可能”：一是“认识何以可能”的逻辑；二是“自由何以可能”的逻辑。前者把认识的可能性归结为概念的辩证运动，即思维与存在的统一展现为概念由抽象的同一到具体的同一的运动过程。后者把自由何以可能得问题同样归结为概念的辩证运动，即概念由抽象的普遍性（自在的全体的自由性）到具体的普遍性（环节的必然性）的运动过程。 为何要加入辩证法在黑格尔看来，之所以把形而上学改造成辩证法，是因为作为真理的哲学必须是使“心灵深入于这些内容，借他们而得到教训，增进力量”，“引导一个个体使之从它的未受教养状态变为有知识的，这是个任务”。“每个个体都必须走过普遍精神所走过的那些发展阶段”。 如何看待黑格尔思想黑格尔思想既是对传统形而上学的否定，又是对传统形而上学的完成。否定是因为它在思维规定感性的形而上学传统中，揭示了概念——思维规定感性的主体和实体的内在矛盾性，迫使形而上学于辩证法合流。完成是指它在思维规定感性的形而上学传统中，确认了概念（普遍理性）作为唯一的主体和实体的地位，又把辩证法变成了概念形而上学。 从深层的社会根源上看，黑格尔则是以哲学的方式表征了他所处资本主义社会的内在矛盾性：一方面，资产阶级除非使全部社会关系不断地革命化便不能生存下去，“否定”构成资本主义生产方式的内在要求；另一方面，资产阶级社会的商品交换原则的同一性构成全部社会生活的根本模式，“概念”成为规范一切生活领域的意识形态。 马克思哲学哲学使命的跃迁 “人的自我异化的神圣形象被揭穿之后，揭露非神圣形象的自我异化，就成为了为历史服务的哲学的迫切任务。于是对天国的批判就变成了对尘世的批判，对宗教的批判就变成对法的批判，对神学的批判就变成了对政治的批判。” 近代的西方历史，从经济形态上来说，是以市场经济取代自然经济的过程；从人的存在形态上说，是人从人对人的“依附性”存在转换为“以物的依赖性为基础的人的独立性”的过程；从文化形态上说，则是从“神学文化”转换为“哲学科学文化”的过程。这个历史过程所构成的时代精神的变革，是哲学使命的历史性转换的最重要的生活基础。 现代哲学使命两个“消解”和两种“归还”：近代以来的哲学是“消解”人在“神圣形象”中的“自我异化”，把异化给“神圣形象”的人的本质“归还”给人；现代哲学的使命则是“消解”人在“非神圣形象”中的“自我异化”，把异化给“非神圣形象”的人的本质“归还”给人。 如何理解第一种消解？自然经济所要求的是经济上禁欲，精神上蒙昧，政治上专制，从而造成人在“神圣形象”中的“自我异化”。而取代自然经济的市场经济反对禁欲而要求人的现实幸福，反对蒙昧而要求人的理性自由，反对专制而要求人的天赋人权，也即市场经济的三个基本取向：功利主义的价值取向，工具理性的思维取向，民主法治的政治取向。这三种基本取向也即马克思说的，以物的依赖性为基础的人的独立性。本质上，第一种消解是理性取代上帝的过程。 如何理解第二种消解？近代哲学又使人在“理性”中造成了新的“自我异化”，即把理性变成了凌驾于人之上的“本质主义的肆虐”。近代哲学本质上是以理论的方式表达了正在受“抽象”统治的近代以来的人的生存状态，也就是人的“独立性”建立在对物的依赖性的基础之上的生存状态。如果说近代哲学表征的是“理性的时代”，则现代哲学可概括为“理性的批判”，其表征的是“反省理性的时代”。","categories":[{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/categories/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"5-模型调参","slug":"pytorch基础/5-模型调参","date":"2023-07-26T09:21:38.260Z","updated":"2023-07-26T09:21:38.312Z","comments":true,"path":"2023/07/26/pytorch基础/5-模型调参/","link":"","permalink":"http://example.com/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/5-%E6%A8%A1%E5%9E%8B%E8%B0%83%E5%8F%82/","excerpt":"","text":"1 超参数超参数是可调整的参数，让你控制模型优化过程。不同的超参数值会影响模型的训练和收敛率。 常用的超参数如下： epoch : 在整个数据集上迭代的次数。 batch : 每一次更新参数（反向传播）所用到的数据样本数。 学习率 : 每个batch 更新模型参数的步进幅度。 123learning_rate = 1e-3batch_size = 64epochs = 5 2 损失函数当遇到一些训练数据时，我们未经训练的网络很可能不会给出正确的答案。损失函数衡量的是获得的结果与目标值的不相似程度，它是我们在训练期间想要最小化的损失函数。为了计算损失，我们使用给定数据样本的输入进行预测，并与真实数据标签值进行比较。 常见的损失函数包括用于回归任务的nn.MSELoss（均方误差）和用于分类的nn.NLLLoss（负对数似然）。nn.CrossEntropyLoss结合了nn.LogSoftmax和nn.NLLLoss。 我们将模型的输出对数传递给 nn.CrossEntropyLoss，它将对对数进行标准化处理并计算预测误差。 12# Initialize the loss functionloss_fn = nn.CrossEntropyLoss() 3 优化器优化是在每个训练步骤中调整模型参数以减少模型误差的过程。优化算法定义了这个过程是如何进行的（在这个例子中，我们使用随机梯度下降法）。所有的优化逻辑都被封装在优化器对象中。在这里，我们使用SGD优化器；此外，PyTorch中还有许多不同的优化器，如Adam和RMSProp，它们对不同类型的模型和数据有更好的效果。 我们通过注册需要训练的模型参数来初始化优化器，并传入学习率超参数。 1optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) 4 调参过程我们定义了train_loop和test_loop，train_loop负责循环我们的优化代码，test_loop负责根据测试数据评估模型的性能。 12345678910111213141516171819202122232425262728293031def train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;)def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;) 123456789loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)epochs = 10for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 请确保在推理前调用model.eval()方法，以将dropout和batch normalization层设置为eval模式。如果不这样做，将产生不一致的推理结果。 5 保存&amp;加载5.1 保存状态字典123torch.save(model.state_dict(), &#x27;model_weights.pth&#x27;)model = Model_Net() # 需要实例化训练时相同的类model.load_state_dict(torch.load(&#x27;model_weights.pth&#x27;)) 5.2 保存整个模型类123# 这种方法在序列化模型时使用Python的pickle模块，所以它在加载模型时，依赖于实际的可用的类定义。torch.save(model, &#x27;model.pth&#x27;)model = torch.load(&#x27;model.pth&#x27;) 5.3 导出ONNX模型123# 由于PyTorch执行图的动态性质，导出过程必须遍历执行图以产生持久的ONNX模型。出于这个原因，应该向导出程序传递一个适当大小的测试变量。input_image = torch.zeros((1,3,224,224))onnx.export(model, input_image, &#x27;model.onnx&#x27;) 5.4 导出JIT模型该种方法加载模型时无需 模型类，导出 JIT 模型的方式有两种：trace 和 script。 采用 torch.jit.trace 的方式来导出 JIT 模型，这种方式会根据一个输入将模型跑一遍，然后记录下执行过程。这种方式的问题在于对于有分支判断的模型不能很好的应对，因为一个输入不能覆盖到所有的分支。但是在我们 ResNet50 模型中不会遇到分支判断，因此这里是合适的。 12345# trace 方法保存example_input = torch.rand(1, 3, 224, 224)jit_model = torch.jit.trace(model, example_input)torch.jit.save(jit_model, &#x27;resnet50_jit.pth&#x27;)module = torch.jit.load(&#x27;resnet50_jit.pth&#x27;) 如果模型有 if else 等分支语句, 应该用script方法保存模型。 1234# script 方法保存script_module = torch.jit.script(model) torch.jit.save(script_module, &#x27;model.pth&#x27;)module = torch.jit.load(&#x27;model.pth&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"4-模型搭建","slug":"pytorch基础/4-模型搭建","date":"2023-07-26T09:18:44.419Z","updated":"2023-07-26T09:18:44.467Z","comments":true,"path":"2023/07/26/pytorch基础/4-模型搭建/","link":"","permalink":"http://example.com/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/4-%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1 神经网络搭建1.1 通过 forward 构建我们可以通过继承 nn.Module，构建我们自己的类来定义我们的神经网络。其中，我们在__init__方法中实现各个子Module的初始化，并在forward 方法中组织这些子Module，形成神经网络。 12345678910111213141516171819class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)logits = model(input_image) 1.2 通过 Sequential 构建nn.Sequential是一个有序模块的容器。数据以定义的顺序通过所有的模块。你可以使用 序列容器来组建一个快速的网络。 1234567seq_modules = nn.Sequential( flatten, layer1, nn.ReLU(), nn.Linear(20, 10))logits = seq_modules(input_image) 2 模型参数神经网络中的许多层都是参数化的，也就是说，层相关的权重和偏置在训练中被优化。nn.Module的子类会自动跟踪你的模型对象中定义的所有字段，并使用你的模型的 parameters() 或 named_parameters() 方法访问所有参数。 在这个例子中，我们遍历每个参数，并打印其大小和预览其值。 1234print(&quot;Model structure: &quot;, model, &quot;\\n\\n&quot;)for name, param in model.named_parameters(): print(f&quot;Layer: &#123;name&#125; | Size: &#123;param.size()&#125; | Values : &#123;param[:2]&#125; \\n&quot;) 3 反向传播在训练神经网络时，最常使用的算法是反向传播算法。在这种算法中，参数（模型权重）是根据损失函数相对于给定参数的梯度来调整的。 3.1 自动梯度计算为了计算这些梯度，PyTorch有一个内置的微分引擎，叫做torch.autograd。它支持对任何计算图的梯度进行自动计算。考虑最简单的单层神经网络，输入x，参数w和b，以及一些损失函数。 在这个网络中，w和b是参数，我们需要进行优化。因此，我们需要能够计算损失值相对于这些变量的梯度（梯度只对于模型参数有意义）。为了做到这一点，我们设置了这些tensor的 requires_grad 属性。它可以在PyTorch中以如下方式定义： 12345678910111213# 正向传播import torchx = torch.ones(5) # input tensory = torch.zeros(3) # expected outputw = torch.randn(5, 3, requires_grad=True) # 需要更新的weightb = torch.randn(3, requires_grad=True) # 需要更新的biasz = torch.matmul(x, w)+bloss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)#反向传播loss.backward() #该步骤包含对梯度的自动计算，梯度值通过以下查看。print(w.grad)print(b.grad) 3.2 autograd的机制首先了解tensor有哪些属性： data : 被包装的张量 grad : 存储data的梯度 grad_fn : 创建 Tensor的 Function，是自动求导的关键 requires_grad：指示是否需要梯度 is_leaf : 指示是否是叶子结点 dtype：张量的数据类型 shape：张量的形状，如(64，3，224，224) device：张量所在设备，GPU&#x2F;CPU Tensor和Function互相结合就可以构建一个记录有整个计算过程的有向无环图(Directed Acyclic Graph，DAG)。每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function。 DAG的节点是Function对象，边表示数据依赖，从输出指向输入。 每当对Tensor施加一个运算的时候，就会产生一个Function对象，它产生运算的结果，记录运算的发生，并且记录运算的输入。Tensor使用.grad_fn属性记录这个计算图的入口。反向传播过程中，autograd引擎会按照逆序，通过Function的backward依次计算梯度。 注意事项 （1）梯度不自动清零，如果不清零梯度会累加，所以需要在每次梯度后人为清零。（2）依赖于叶子结点的结点，requires_grad默认为True。（3）叶子结点不可执行in-place，因为其他节点在计算梯度时需要用到叶子节点，所以叶子地址中的值不得改变否则会是其他节点求梯度时出错。所以叶子节点不能进行原位计算。（4）在 y.backward()时，如果 y 是标量量，则不需要为backward()传⼊入任何参数；否则，需要传⼊一个与y同形的Tensor。 （5）只能获得计算图的叶子节点的grad属性，这些节点的requires_grad属性设置为True。对于图中的所有其他节点，梯度将不可用。 （6）只能在一个给定的图上使用一次backward来进行梯度计算。如果需要在同一个图上进行多次backward调用，需要在backward调用中传递 retain_graph&#x3D;True。 （7）在PyTorch中，DAG是动态的。需要注意的是，图是从头开始重新创建的；在每次调用.backward()后，autograd开始填充一个新的图。这正是允许你在模型中使用控制流语句的原因；如果需要，你可以在每次迭代时改变形状、大小和操作。 3.3 禁用梯度跟踪123456789101112# 方法一：利用torch.no_grad()块包围正向传播代码with torch.no_grad(): z = torch.matmul(x, w)+b# 方法二：利用detach方法z = torch.matmul(x, w)+bz_det = z.detach()# 方法三：设置requires_gradfor name, param in model.named_parameters(): param.requires_grad = False","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"3-数据准备","slug":"pytorch基础/3-数据准备","date":"2023-07-25T06:38:09.422Z","updated":"2023-07-25T06:38:09.474Z","comments":true,"path":"2023/07/25/pytorch基础/3-数据准备/","link":"","permalink":"http://example.com/2023/07/25/pytorch%E5%9F%BA%E7%A1%80/3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87/","excerpt":"","text":"1 Dataset1.1 图像（path+label形式）12345678910111213141516171819202122232425import osimport pandas as pdfrom torchvision.io import read_imagefrom torchvision import datasetsfrom torchvision import transformsclass CustomImageDataset(Dataset): def __init__(self, annotations_file, img_dir, transform=None, target_transform=None): self.img_labels = pd.read_csv(annotations_file) self.img_dir = img_dir self.transform = transform self.target_transform = target_transform def __len__(self): return len(self.img_labels) def __getitem__(self, idx): img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0]) image = read_image(img_path) label = self.img_labels.iloc[idx, 1] if self.transform: image = self.transform(image) if self.target_transform: label = self.target_transform(label) return image, label 1.2 图像（文件夹名为label 形式）12345data_dir = &#x27;data/hymenoptera_data&#x27;train_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;train&quot;) ,data_transforms[&quot;train&quot;])val_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;val&quot;) ,data_transforms[&quot;val&quot;]) 1.3 图像（在线拉取）12345train_data = datasets.MNIST(root=&#x27;data&#x27;, train=True, download=True, transform=data_transforms[&quot;train&quot;], target_transform=xxx) 1.4 图片转换1234567891011121314151617# input变换data_transforms = transforms.Compose([ transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ])# RandomResizedCrop: 随机长宽比裁剪# RandomHorizontalFlip: 随机水平翻转# RandomVerticalFlip: 随机垂直翻转# ToTensor: 转换为tensor# Normalize: 像素值进行归一化处理# target 变换# 把整数变成一个one-hot的tensortarget_transform = Lambda(lambda y: torch.zeros(10, dtype=torch.float) \\ .scatter_(dim=0, index=torch.tensor(y), value=1)) 2 DataLoader123456train_dataloader = torch.utils.data.DataLoader(train_data, batch_size=64, shuffle=True, num_workers=4)for batch, (X, y) in enumerate(train_dataloader): X, y = X.to(device), y.to(device)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"2-tensor基础","slug":"pytorch基础/2-tensor操作","date":"2023-07-24T09:18:03.276Z","updated":"2023-07-25T06:26:52.819Z","comments":true,"path":"2023/07/24/pytorch基础/2-tensor操作/","link":"","permalink":"http://example.com/2023/07/24/pytorch%E5%9F%BA%E7%A1%80/2-tensor%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1 tensor属性1.1 tensor初始化1234shape = (2,3,)rand_tensor = torch.rand(shape)ones_tensor = torch.ones(shape)zeros_tensor = torch.zeros(shape) 1.2 tensor性质1234tensor = torch.rand(3,4)print(f&quot;Shape of tensor: &#123;tensor.shape&#125;&quot;)print(f&quot;Datatype of tensor: &#123;tensor.dtype&#125;&quot;)print(f&quot;Device tensor is stored on: &#123;tensor.device&#125;&quot;) 2 对象转换2.1 list – tensor123456data = [[1, 2], [3, 4]]# list--&gt; tensor# 数据类型是自动推断出来x_tensor = torch.tensor(data)# tensor--&gt; listx_list = x_tensor.tolist() 2.2 numpy – tensor12345np_array = np.array(data)# numpy --&gt; tensorx_tensor = torch.from_numpy(np_array)# tensor --&gt; numpyx_numpy = x_tensor.numpy() 2.3 tensor – tensor12x_ones = torch.ones_like(x_data) # retains the properties of x_datax_rand = torch.rand_like(x_data, dtype=torch.float) # overrides the datatype of x_data 3 运算&amp;操作3.1 矩阵乘法1234y1 = tensor @ tensor.Ty2 = tensor.matmul(tensor.T)y3 = torch.rand_like(tensor)torch.matmul(tensor, tensor.T, out=y3) 3.2 矩阵点乘12345z1 = tensor * tensorz2 = tensor.mul(tensor)z3 = torch.rand_like(tensor)torch.mul(tensor, tensor, out=z3) 3.3 矩阵拼接1234# 指定的dim 数量增加，除了dim之外的dim需要相同才行t1 = torch.cat([tensor, tensor, tensor], dim=1)# 两个要进行stack的tensor的dim数量应该相同，stack操作之后得到的结果会多出一维，即dim的数量会+1。t1 = torch.stack([tensor, tensor, tensor], dim=1) 3.4 矩阵升降维123456# 升维。插入指定维度，值为1tensor.unsqueeze(dim=0)# 降维。压缩指定维度，该维度值必须为1# 当dim不指定时，压缩所有维度值为1的维tensor.squeeze(dim=0)tensor.squeeze()","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"1-pytorch快速开始","slug":"pytorch基础/1-pytorch快速开始","date":"2023-07-24T09:15:16.547Z","updated":"2023-07-24T10:01:37.638Z","comments":true,"path":"2023/07/24/pytorch基础/1-pytorch快速开始/","link":"","permalink":"http://example.com/2023/07/24/pytorch%E5%9F%BA%E7%A1%80/1-pytorch%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"0 导库123456import torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambda, Composeimport matplotlib.pyplot as plt 1 数据准备torchvision.datasets模块包含了许多真实世界的视觉数据的数据集对象，如CIFAR、COCO。以下通过datasets在线加载FashionMNIST数据集。 123456789101112131415# Download training data from open datasets.training_data = datasets.FashionMNIST( root=&quot;data&quot;, train=True, download=True, transform=ToTensor(),)# Download test data from open datasets.test_data = datasets.FashionMNIST( root=&quot;data&quot;, train=False, download=True, transform=ToTensor(),) 将dataset装载入DataLoader中，DataLoader可认为是一个数据迭代器，其支持数据的自动批处理、采样、洗牌和多进程数据加载。这里定义一个 batch&#x3D;64，即dataloader可迭代的每个元素将返回一个批次，包括64个元素的特征和标签。 123456789batch_size = 64# Create data loaders.train_dataloader = DataLoader(training_data, batch_size=batch_size)test_dataloader = DataLoader(test_data, batch_size=batch_size)for X, y in test_dataloader: print(&quot;Shape of X [N, C, H, W]: &quot;, X.shape) print(&quot;Shape of y: &quot;, y.shape, y.dtype) break 2 创建模型为了在PyTorch中定义一个神经网络，我们创建一个继承自nn.Module的类。我们在__init__函数中定义网络的层，并在forward函数中指定数据将如何通过网络。为了加速神经网络的操作，如果有GPU的话，我们把它移到GPU上。 1234567891011121314151617181920212223# Get cpu or gpu device for training.device = &quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;# Define modelclass NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10) ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)print(model) 3 优化模型参数3.1 模型训练函数12345678910111213141516171819202122loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)def train(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) model.train() for batch, (X, y) in enumerate(dataloader): X, y = X.to(device), y.to(device) # Compute prediction error pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;) 3.2 模型评估函数1234567891011121314def test(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) model.eval() test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;)1 3.3 启动训练&amp;评估123456epochs = 5for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train(train_dataloader, model, loss_fn, optimizer) test(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 4 保存模型12torch.save(model.state_dict(), &quot;model.pth&quot;)print(&quot;Saved PyTorch Model State to model.pth&quot;) 5 加载模型12model = NeuralNetwork()model.load_state_dict(torch.load(&quot;model.pth&quot;)) 6 模型推理12345678910111213141516171819classes = [ &quot;T-shirt/top&quot;, &quot;Trouser&quot;, &quot;Pullover&quot;, &quot;Dress&quot;, &quot;Coat&quot;, &quot;Sandal&quot;, &quot;Shirt&quot;, &quot;Sneaker&quot;, &quot;Bag&quot;, &quot;Ankle boot&quot;,]model.eval()x, y = test_data[0][0], test_data[0][1]with torch.no_grad(): pred = model(x) predicted, actual = classes[pred[0].argmax(0)], classes[y] print(f&#x27;Predicted: &quot;&#123;predicted&#125;&quot;, Actual: &quot;&#123;actual&#125;&quot;&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-07-21T10:28:18.087Z","updated":"2023-07-23T10:23:20.541Z","comments":true,"path":"2023/07/21/hello-world/","link":"","permalink":"http://example.com/2023/07/21/hello-world/","excerpt":"","text":"今天坑坑洼洼可算是把网站给搭好了，看着简洁漂亮的首页，想着以后就有专属自己的网站，就很开心。背景图是《权游》里面的某一幕的简画，守夜人面对夜鬼的来袭，背水一战，颇为壮观。 为什么要做个人博客呢？说实话，没有特别的理由。或许是出于新鲜感；或许是工作太无聊；或许是外界太嘈杂，想在数字世界中寻找一片净土；或许是想把有趣的、新奇的东西系统地放进来，有一天可以带朋友来参观，看！这是我曾经的快乐和珍藏。 现实世界有太多约束，说话做事写文章处处存在隐形的规矩，这些规矩容易消磨本身藏在事物的乐趣。我想，在这里就少点规矩吧，说说废话，吹吹牛逼又怎么样呢？有时候写点生活感悟也不怕别人说我假正经。嗯，没错，这是我的展厅！当然，对于涉及实操性或理论性的文章，行文还是遵从逻辑，便于理解和回顾。 那么，第一篇写点啥呢，emmm…","categories":[{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%99/"}]}],"categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/categories/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%99/"}]}