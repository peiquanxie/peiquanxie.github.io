{"meta":{"title":"PQ.XIE BLOG","subtitle":"","description":"个人博客","author":"PQ.XIE","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-07-22T02:40:44.436Z","updated":"2023-07-22T02:40:44.436Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-07-28T09:11:55.709Z","updated":"2023-07-28T09:11:55.709Z","comments":true,"path":"baidu_verify_codeva-3bR1bjdnkE.html","permalink":"http://example.com/baidu_verify_codeva-3bR1bjdnkE.html","excerpt":"","text":"e522504a2b93d12f0dc162fcc0572c79"},{"title":"","date":"2023-07-28T09:26:16.461Z","updated":"2023-07-28T09:26:16.461Z","comments":true,"path":"googlef847041eb4e8ca77.html","permalink":"http://example.com/googlef847041eb4e8ca77.html","excerpt":"","text":"google-site-verification: googlef847041eb4e8ca77.html"},{"title":"","date":"2023-07-26T09:27:47.030Z","updated":"2023-07-26T09:27:47.030Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系方式邮箱：&#x32;&#49;&#50;&#57;&#53;&#49;&#x36;&#57;&#x32;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d; 版权声明站点内的所有原创内容（包括但不限于文章、图像等）除特别声明外均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，任何人都可以自由传播，但不得用于商用且必须署名并以相同方式分享。本站部分内容转载于网络，有出处的已在文中署名作者并附加原文链接，出处已不可寻的皆已标注来源于网络。若您认为本站点有部分内容侵犯了您的权益，请在电邮告知，我将认真处理。"},{"title":"所有分类","date":"2023-07-22T02:37:26.591Z","updated":"2023-07-22T02:37:26.591Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-26T09:31:42.263Z","updated":"2023-07-26T09:31:42.263Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-22T02:37:59.687Z","updated":"2023-07-22T02:37:59.687Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"4-topic通信机制简汇","slug":"ROS1/4-topic通信机制简汇","date":"2023-09-03T04:02:50.574Z","updated":"2023-09-03T04:02:50.626Z","comments":true,"path":"2023/09/03/ROS1/4-topic通信机制简汇/","link":"","permalink":"http://example.com/2023/09/03/ROS1/4-topic%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%AE%80%E6%B1%87/","excerpt":"","text":"1 Publisher（CPP）12345678910111213141516171819202122232425262728#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;publisher&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 ros::Publisher = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10); // 设置循环的频率 ros::Rate loop_rate(10); while (ros::ok()) &#123; // 初始化geometry_msgs::Twist类型的消息 geometry_msgs::Twist vel_msg; vel_msg.linear.x = 0.5; vel_msg.angular.z = 0.2; // 发布消息 turtle_vel_pub.publish(vel_msg); ROS_INFO(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z); // 按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(publisher src/publisher.cpp)target_link_libraries(publisher $&#123;catkin_LIBRARIES&#125;) 2 Publisher（Python）123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom geometry_msgs.msg import Twist# ROS节点初始化rospy.init_node(&#x27;publisher&#x27;, anonymous=True)# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)#设置循环的频率rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) rate.sleep() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/publisher.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 3 Subscriber（C++）123456789101112131415161718192021222324#include &lt;ros/ros.h&gt;#include &quot;turtlesim/Pose.h&quot;// 接收到订阅的消息后，会进入消息回调函数// turtlesim::Pose为消息类型，来源于 #include &quot;turtlesim/Pose.h&quot;void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg-&gt;x, msg-&gt;y);&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;subscriber&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;, 10, poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; cmake修改：在CmakeLists最底部添加如下修改： 1234add_executable(subscriber src/subscriber.cpp)target_link_libraries(subscriber $&#123;catkin_LIBRARIES&#125;) 4 Subscriber（Python）123456789101112131415#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)# ROS节点初始化rospy.init_node(&#x27;subscriber&#x27;, anonymous=True)# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback# Pose为消息类型，来源于 from turtlesim.msg import Poserospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback)# 循环等待回调函数rospy.spin() cmake修改：找到catkin_install_python项，添加脚本。 1234catkin_install_python(PROGRAMS scripts/subscriber.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 5 自定义接口5.1 msg文件编写在 ros_ws&#x2F;src&#x2F;hello&#x2F;msg目录下创建 Person.msg 接口文件，注意首字母必须大写。接口示例如下： 12345678string nameuint8 sexuint8 age# 以下相当于宏uint8 unknown = 0uint8 male = 1uint8 female = 2 编译修改： CMakeLists修改：在对应位置进行如下修改： 1234find_package(...... message_generation)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs)catkin_package(...... message_runtime) package.xml修改：在对应位置添加如下： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 自定义接口需经过编译形成C++和Python的引用文件，可以在devel&#x2F;include里面找到C++所需的.h接口文件。 5.2 发布&#x2F;订阅代码编写发布&#x2F;订阅代码与前几节几乎一模一样，这里不再赘述。对于接口里面的宏的引用，在C++里面这样引用：learning_topic::Person::male; Python里面这样引用：Person.male 。 编译修改：由于应用代码对接口产生依赖，因此在编译应用代码时，也应添加相应的依赖（Python不需要）： 1add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"3-ROS1快速开始","slug":"ROS1/3-ROS1快速开始","date":"2023-09-03T04:02:50.158Z","updated":"2023-09-03T04:02:50.290Z","comments":true,"path":"2023/09/03/ROS1/3-ROS1快速开始/","link":"","permalink":"http://example.com/2023/09/03/ROS1/3-ROS1%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"1 创建功能包1.1 创建工作空间123mkdir -p ros_ws/srccd ros_ws/srccatkin_init_workspace 1.2 创建功能包12catkin_create_pkg hello std_msgs roscpp rospy格式：catkin_create_pkg &lt;pkg_name&gt; &lt;depend&gt; &lt;depend&gt; 1.3 编译工作空间12cd ..catkin_make 1.4 激活环境变量1source devel/setup.bash 注：同一个工作空间不能有同名功能包；不同工作空间可以有同名功能包。 2 编写CPP节点2.1 创建节点文件在 ros_ws&#x2F;src&#x2F;hello&#x2F;src 目录下创建hello.cpp 节点文件。 2.1 节点代码12345678910111213#include &lt;ros/ros.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;hello_node&quot;); // 创建节点句柄 ros::NodeHandle n; ROS_INFO(&quot;Hello world.&quot;); ros::spin(); return 0;&#125; 2.2 修改CmakeLists修改 ros_ws&#x2F;src&#x2F;hello&#x2F;src&#x2F;CmakeLists，找到以下项，并进行如下修改： 1234567## 编译节点源码，hello_node为节点可执行文件名字，可以与源码指定的节点名字一致add_executable(hello_node src/hello.cpp)## 添加链接库target_link_libraries(hello_node $&#123;catkin_LIBRARIES&#125;) 2.3 编译运行1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello_node 3 编写Python节点3.1 创建节点文件在 ros_ws&#x2F;src&#x2F;hello&#x2F;scripts 目录下创建hello.py节点文件。 2.1 节点代码12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-import rospy if __name__ == &#x27;__main__&#x27;: # ROS节点初始化 rospy.init_node(&#x27;hello_node_py&#x27;) rospy.loginfo(&#x27;hello world.&#x27;) rospy.spin() 2.2 修改CmakeLists修改 ros_ws&#x2F;src&#x2F;hello&#x2F;src&#x2F;CmakeLists，找到以下项，并进行如下修改： 12345## 添加节点python脚本，python无需编译，只需添加到路径即可catkin_install_python(PROGRAMS scripts/hello.py DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;) 2.3 编译运行1234cd ros_wscatkin_makesource devel/setup.bashrosrun hello hello.py http://wiki.ros.org/cn/ROS/Tutorials","categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"}]},{"title":"7-ROS2通信汇总(Python篇)","slug":"ROS2基础/7-ROS2 通信汇总(Python篇)","date":"2023-08-20T09:29:20.492Z","updated":"2023-08-20T09:29:20.540Z","comments":true,"path":"2023/08/20/ROS2基础/7-ROS2 通信汇总(Python篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/7-ROS2%20%E9%80%9A%E4%BF%A1%E6%B1%87%E6%80%BB(Python%E7%AF%87)/","excerpt":"","text":"1 topic发布与订阅发布端接口： 12publisher_ = node.create_publisher(msg_type,&quot;topic_name&quot;, 10) publisher_.publish(msg) 订阅者接口： 1subscribe_ = node.create_subscription(msg_type, &quot;topic_name&quot;, recv_callback, 10) 2 service发送和接收client 接口： 1234client = node.create_client(srv_type,&quot;srv_name&quot;)while not client.wait_for_service(1.0): node.get_logger().warn(&quot;等待服务&quot;)client.call_async(request) # .add_done_callback(reponse_callback) server 接口： 1234server = node.create_service(srv_type,&quot;srv_name&quot;, request_callback)def request_callback(request, response): ...... return response 3 action控制与执行执行 接口： 123456789101112from rclpy.action import ActionServerfrom rclpy.action.server import ServerGoalHandleaction_server_ = ActionServer( node, action_type, &quot;action_name&quot;, execute_callback # ,callback_group=MutuallyExclusiveCallbackGroup() )def execute_callback(goal_handle: ServerGoalHandle): ... ... result = action_type.Result() result = ... return result 控制 接口： 12345678910111213141516from rclpy.action import ActionClientaction_client_ = ActionClient(node, action_type, &#x27;action_name&#x27;)goal_msg = MoveRobot.Goal()goal_msg = ...action_client_.wait_for_server()send_goal_future = action_client_.send_goal_async(goal_msg,feedback_callback=feedback_callback)send_goal_future.add_done_callback(goal_response_callback)def feedback_callback(feedback_msg): feedback = feedback_msg.feedback ... def goal_response_callback(future): goal_handle = future.result() get_result_future = goal_handle.get_result_async() get_result_future.add_done_callback(get_result_callback)","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"6-ROS2 接口介绍","slug":"ROS2基础/6-ROS2 接口介绍","date":"2023-08-20T09:29:20.220Z","updated":"2023-08-20T09:29:20.268Z","comments":true,"path":"2023/08/20/ROS2基础/6-ROS2 接口介绍/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/6-ROS2%20%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"ROS2提供了四种通信方式，包括：话题（topic）、服务（service）、动作（action）和 参数（parameter）。通信会涉及到接口，我们可以通过 ros2 interface list 列出ROS2提供的所有接口，通过 ros2 interface show &lt;interface_name&gt; 或 ros2 interface proto &lt;message_name&gt; 查看接口的具体格式。但是，当我们不能在内置接口中找到适合于我们项目的接口时，我们需要自定义接口。以下讲解如何自定义接口。 1 接口格式1.1 topic接口格式接口存放路径：interface_pkg&#x2F;msg&#x2F;Xxx.msg 12string namesensor_msgs/Image image #支持嵌套 1.2 service接口格式接口存放路径：interface_pkg&#x2F;srv&#x2F;Xxx.srv 12345string nameint32 aint64 b---int32 ret # 返回值 1.3 action接口格式接口存放路径：interface_pkg&#x2F;action&#x2F;Xxx.action 12345int32 target # 目标值 ---int32[] sequence # 差值---int32[] partial_sequence # 当前值 2 创建接口2.1 创建接口功能包1ros2 pkg create example_test_interfaces --build-type ament_cmake --dependencies rosidl_default_generators 其中，–build-type 参数值必须为 ament_cmake； –dependencies 指定功能包依赖，rosidl_default_generators必须添加，其他根据自己接口依赖添加即可，当然也可以通过事后修改 package.xml 添加依赖。创建完后可看见新增接口文件夹，目录如下： 2.2 添加接口文件将自己定义的接口放入 example_test_interfaces 文件夹合适位置，注意要按照上一节的接口格式来定义和存放接口。我们这个先定义一个简单的 topic 接口，在 example_test_interfaces 下新建 msg 目录，并在 msg 目录下新建 Test.msg 文件(首字母大写)，内容如下： 123string nameuint32 valuebool flag 2.3 修改CMakeLists文件在CMakeLists里面添加要编译的接口，为什么接口也要编译？其实ROS需要将 msg、srv、action文件转换为Python和C++的头文件，这样我们的节点代码才能读取接口。CMakeLists修改如下： 12345678# 查找依赖，有新增需添加find_package(rosidl_default_generators REQUIRED)# 生成接口头文件rosidl_generate_interfaces($&#123;PROJECT_NAME&#125; &quot;msg/Test.msg&quot; # DEPENDENCIES geometry_msgs # 有依赖需要添加) 2.4 修改package.xml文件12在 &lt;depend&gt;rosidl_default_generators&lt;/depend&gt; 下面添加：&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 2.5 编译接口包12cd workspacecolcon build --packages-select example_test_interfaces 2.6 查看测试12source install/setup.bashros2 interface show example_test_interfaces/msg/Test","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"5-ROS2创建第一个节点","slug":"ROS2基础/5-ROS2创建第一个节点","date":"2023-08-20T09:29:19.940Z","updated":"2023-08-20T09:29:19.992Z","comments":true,"path":"2023/08/20/ROS2基础/5-ROS2创建第一个节点/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/5-ROS2%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"1 创建cpp节点1.1 创建工作空间1mkdir -p workspace/src/ 1.2 创建功能包12cd workspace/srcros2 pkg create example_cpp --build-type ament_cmake --dependencies rclcpp 此时可以看到ROS2为我们创建了example_cpp文件夹，且该文件夹下包含include、src、CMakeLists.txt、package.xml 文件及目录。其中，src和include目录放节点源码和相应的头文件，CMakeLists.txt是编译节点源码的配置文件，package.xml是该功能包的配置文件。 1.3 创建节点在功能包的src目录下创建节点文件 mynode.cpp，该文件的main函数则为该节点的入口。cpp文件代码如下： 12345678910111213141516#include &quot;rclcpp/rclcpp.hpp&quot;int main(int argc, char **argv)&#123; /* 初始化rclcpp */ rclcpp::init(argc, argv); /*创建一个名为test_node的节点*/ auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;test_node&quot;); /*利用RCLCPP 打印*/ RCLCPP_INFO(node-&gt;get_logger(), &quot;Hello World. test_node start.&quot;); /* 运行节点，并检测退出信号 Ctrl+C*/ rclcpp::spin(node); /* 停止运行 */ rclcpp::shutdown(); return 0;&#125; 1.4 修改CMakeLists将mynode.cpp 添加到CMakeLists中，让cmake编译节点并安装节点。在CMakeLists末尾添加以下配置： 1234567add_executable(test_node src/mynode.cpp)ament_target_dependencies(test_node rclcpp)install(TARGETS test_node DESTINATION lib/$&#123;PROJECT_NAME&#125;) 1.5 编译功能包12cd workspacecolcon build --packages-select example_cpp 1.6 source环境1source install/setup.bash 1.7 运行节点1ros2 run example_cpp test_node 2 创建python节点2.1 创建工作空间1mkdir -p workspace/src/ 2.2 创建功能包12cd workspace/srcros2 pkg create example_py --build-type ament_python --dependencies rclpy 此时可以看到ROS2为我们创建了example_py文件夹，且该文件夹下包含example_py、resource、test、package.xml、setup.py、setup.cfg文件及目录。其中，example_py文件夹放我们的节点代码。 2.3 创建节点在功能包的example_py目录下创建节点文件 mynode.py，该文件的main函数则为该节点的入口。python文件代码如下： 123456789101112import rclpyfrom rclpy.node import Nodedef main(args=None): # 初始化rclpy rclpy.init(args=args) # 创建一个test_node node = Node(&quot;test_node_py&quot;) node.get_logger().info(&quot;Hello World. node_py start.&quot;) # 保持节点运行 rclpy.spin(node) rclpy.shutdown() 2.4 修改 setup.py在setup文件中声明该python节点，以及指定该节点的入口。这样之后使用colcon build才能检测到该节点，从而将其添加到install目录下。修改如下： 123456 entry_points=&#123; &#x27;console_scripts&#x27;: [ &quot;test_node_py = example_py.mynode:main&quot; ], &#125;,) 2.5 编译功能包12cd workspacecolcon build --packages-select example_py 2.6 source环境1source install/setup.bash 2.7 运行节点1ros2 run example_py test_node_py","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"4-ROS2命令行汇总","slug":"ROS2基础/4-ROS2命令行汇总","date":"2023-08-20T09:29:19.576Z","updated":"2023-08-20T09:29:19.624Z","comments":true,"path":"2023/08/20/ROS2基础/4-ROS2命令行汇总/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/4-ROS2%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B1%87%E6%80%BB/","excerpt":"","text":"0 节点运行命令 命令格式： ros2 run &lt;package_name&gt; &lt;node_name&gt; 1 pkg相关命令1.1 ros2 pkg create 命令功能：创建功能包并指定包相关参数命令格式：ros2 pkg create &lt;pkgname&gt; –build-type &lt;ament_python&gt; –node-name &lt;xx_node&gt; –dependencies &lt;rclpy&gt;参数列表： 参数 参数作用 参数示例 –build-type 指定编译类型 ament_python &#x2F; ament_cmake –node-name 指定要生成的源码文件，可以后期创建 xxx.py &#x2F; xxx.cpp –dependencies 指定依赖模块 rclpy &#x2F; std_msgs &#x2F; sensor_msgs 1.2 ros2 pkg list 命令功能：查看系统中功能包列表命令格式：ros2 pkg list注意：记得要通过source指令将自己的功能包添加到ROS2环境中。 1.3 ros2 pkg executables 命令功能：查看功能包内所有可执行节点命令格式：ros2 pkg executables &lt;package_name&gt; 2 node相关命令2.1 ros2 node list 命令功能： 查看当前域内（ROS_DOMAIN_ID）的节点列表命令格式： ros2 node list 2.2 ros2 node info 命令功能： 查看节点详细信息，包括订阅、发布的消息，开启的服务和动作等命令格式： ros2 node info &lt;node_name&gt; 3 topic相关命令3.1 ros2 topic list 命令功能：列出域内可使用的topic列表命令格式：ros2 topic list 3.2 ros2 topic info 命令功能：显示主题消息类型，订阅者数量，发布者数量等命令格式：ros2 topic info &lt;topic_name&gt; 3.3 ros2 topic type 命令功能：查看主题消息类型命令格式：ros2 topic type &lt;topic_name&gt; 3.4 ros2 topic find 命令功能：按消息类型查找相关主题命令格式：ros2 topic find &lt;message_type&gt; 3.5 ros2 topic hz 命令功能：显示主题平均发布频率命令格式：ros2 topic hz &lt;topic_name&gt; 3.6 ros2 topic bw 命令功能：显示所查阅主题的带宽命令格式：ros2 topic bw &lt;topic_name&gt; 3.7 ros2 topic delay 命令功能：通过header中的时间戳计算消息延迟命令格式：ros2 topic delay &lt;topic_name&gt; 3.8 ros2 topic echo 命令功能：在控制台显示主题消息命令格式：ros2 topic echo &lt;topic_name&gt; 3.9 ros2 topic pub 命令功能：通过命令行发布指定主题消息命令格式：ros2 topic pub &lt;topic_name&gt; &lt;message_type&gt; &lt;message_content&gt;命令示例：ros2 topic pub control_node&#x2F;action geometry_msgs&#x2F;msg&#x2F;TwistStamped “{header: {stamp:{sec: 0, nanosec: 0}, frame_id: control_node}, twist: {linear: {x: 0.3, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}}” 4 interface相关命令4.1 ros2 interface list 命令功能：按类显示系统内所有的接口，包括消息（Messages）、服务（Services）、动作（Actions）命令格式：ros2 interface list 4.3 ros2 interface packages 命令功能：显示所有接口包命令格式：ros2 interface packages 4.2 ros2 interface package 命令功能：显示指定接口包内的子接口命令格式：ros2 interface package &lt;interface_pkg&gt; 4.3 ros2 interface show 命令功能：显示指定接口的详细内容命令格式：ros2 interface show &lt;interface_name&gt; 4.4 ros2 interface proto 命令功能：显示消息模板命令格式：ros2 interface proto &lt;message_name&gt;","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"3-ROS2系统架构","slug":"ROS2基础/3-ROS2系统架构","date":"2023-08-20T09:29:19.124Z","updated":"2023-08-20T09:29:19.176Z","comments":true,"path":"2023/08/20/ROS2基础/3-ROS2系统架构/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/3-ROS2%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1 ROS2总体架构图 1.1 DDS实现层DDS，全称 Data Distribution Service (数据分发服务)。是由对象管理组 (OMG) 于 2003 年发布并于 2007 年修订的开分布式系统标准。通过类似于ROS中的话题发布和订阅形式来进行通信，同时提供了丰富的服务质量管理来保证可靠性、持久性、传输设置等。 DDS实现层其实就是对不同常见的DDS接口进行再次的封装，让其保持统一性，为DDS抽象层提供统一的API。 1.2 DDS抽象层（rmw）这一层将DDS实现层进一步的封装，使得DDS更容易使用。原因在于DDS需要大量的设置和配置（分区，主题名称，发现模式，消息创建,…），这些设置都是在ROS2的抽象层中完成的。 2 DDS 通信模型DDS的模型是非常容易理解，我们可以定义话题的数据结构（类似于ROS2中的接口类型）。下图中的例子: Pos：一个编号id的车子的位置x,y DDS的参与者(Participant)通过发布和订阅主题数据进行通信。 DDS的应用层通过DDS进行数据订阅发布，DDS通过传输层进行数据的收发。 2.1. DDS的优势与劣势**优势** 发布&#x2F;订阅模型：简单解耦，可以轻松实现系统解耦 性能：在发布&#x2F;订阅模式中，与请求&#x2F;回复模式相比，延迟更低，吞吐量更高。 远程参与者的自动发现：此机制是 DDS 的主要功能之一。通信是匿名的、解耦的，开发者不必担心远程参与者的本地化。 丰富的 Qos 参数集，允许调整通信的各个方面：可靠性、持久性、冗余、寿命、传输设置、资源…… 实时发布订阅协议 ( RTPS )：该协议几乎可以通过任何传输实现，允许在 UDP、TCP、共享内存和用户传输中使用 DDS，并实现不同 DDS 实现之间的真正互操作性。 劣势 API复杂，DDS 的灵活性是以复杂性为代价的。 系统开销相对较大，有待数据论证。 社区支持问题，但ROS2近两年来使用DDS后社区表现还是不错的。 2.2 ROS2使用DDS的几个理由 DDS已经应用在军事、潜艇各个领域，稳定性实时性经过实际检验。 使用DDS需要维护的代码要少得多，可以让ROS2开发人员腾出手专注机器人开发。 DDS有定义好的行为和规范并且有完善的文档。 DDS提供了推荐的用例和软件API，有较好的语言支持。","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"2-ROS2安装(X86篇)","slug":"ROS2基础/2-ROS2安装(X86篇)","date":"2023-08-20T09:29:18.740Z","updated":"2023-08-20T09:29:18.792Z","comments":true,"path":"2023/08/20/ROS2基础/2-ROS2安装(X86篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/2-ROS2%E5%AE%89%E8%A3%85(X86%E7%AF%87)/","excerpt":"","text":"本篇安装环境如下： CPU架构：amd_64操作系统：ubuntu20.04 1 更换镜像源（可选）更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。amd_64&#x2F; ubuntu20.04的源如下： mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bakvim &#x2F;etc&#x2F;apt&#x2F;sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源这里同样采用清华的pip源，可加速python第三方库的下载，命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装ROS21sudo apt install ros-foxy-desktop python3-colcon-common-extensions 5 设置环境变量12source /opt/ros/foxy/setup.bashecho &quot; source /opt/ros/foxy/setup.bash&quot; &gt;&gt; ~/.bashrc 6 测试6.1 你说我听12345## 运行talkerros2 run demo_nodes_cpp talker## 新起另一个终端，运行listenerros2 run demo_nodes_py listener 6.2 小海龟12345## 运行海龟界面ros2 run turtlesim turtlesim_node## 新启一个终端，运行遥控器ros2 run turtlesim turtle_teleop_key","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"1-ROS2安装(armhf篇)","slug":"ROS2基础/1-ROS2安装(armhf篇)","date":"2023-08-20T09:29:18.360Z","updated":"2023-08-20T09:29:18.408Z","comments":true,"path":"2023/08/20/ROS2基础/1-ROS2安装(armhf篇)/","link":"","permalink":"http://example.com/2023/08/20/ROS2%E5%9F%BA%E7%A1%80/1-ROS2%E5%AE%89%E8%A3%85(armhf%E7%AF%87)/","excerpt":"","text":"由于ROS官方并没有提供armhf CPU架构的ROS2二进制安装文件，本篇整理了从ROS2源码编译安装的方法。本篇安装环境如下： CPU架构：armv7l操作系统：ubuntu20.04 1 更换镜像源（可选）更换镜像源可以加速各种依赖库下载速度，这里提供常用的 ubuntu镜像源 和 pip源。 1.1 更换ubuntu镜像源这里采用清华源，同学们可到该网站 https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 寻找自己系统版本对应的源。需要注意的是，大部分高校提供的源都是X86架构的，对于arm设备需要在源加上‘-ports’ 。armv7l &#x2F; ubuntu20.04的源如下： mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bakvim &#x2F;etc&#x2F;apt&#x2F;sources.list 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 1.2 更换 PIP 源这里同样采用清华的pip源，可加速python第三方库的下载（后面需要），命令行输入以下命令即可。 12pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepip config set global.trusted-host https://pypi.tuna.tsinghua.edu.cn 2 设置 locale12345sudo apt update &amp;&amp; sudo apt install localessudo locale-gen en_US en_US.UTF-8sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8export LANG=en_US.UTF-8locale # verify settings 3 添加ROS2 存储库12345678910111213# 1 确保启用universe存储库sudo apt install software-properties-commonsudo add-apt-repository universe# 2 添加ROS2 GPG 密钥sudo apt update &amp;&amp; sudo apt install curl -ysudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg# 3 添加存储库到 sources listecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null# 4 更新aptsudo apt apdate 4 安装编译工具123456789101112131415161718192021222324252627sudo apt update &amp;&amp; sudo apt install -y \\ libbullet-dev \\ python3-pip \\ python3-pytest-cov \\ ros-dev-tools# install some pip packages needed for testingpython3 -m pip install -U \\ argcomplete \\ flake8-blind-except \\ flake8-builtins \\ flake8-class-newline \\ flake8-comprehensions \\ flake8-deprecated \\ flake8-docstrings \\ flake8-import-order \\ flake8-quotes \\ pytest-repeat \\ pytest-rerunfailures \\ pytest# install Fast-RTPS dependenciessudo apt install --no-install-recommends -y \\ libasio-dev \\ libtinyxml2-dev# install Cyclone DDS dependenciessudo apt install --no-install-recommends -y \\ libcunit1-dev 5 获取ROS2源码12345mkdir -p ~/ros2_foxy/srccd ~/ros2_foxywget https://raw.githubusercontent.com/ros2/ros2/foxy/ros2.repos --no-check-certificate## github下载不稳定，可自行修改repos文件，添加代理前缀 https://ghproxy.com/vcs import --input ./ros2.repos src 6 使用Rosdep安装依赖1234sudo apt upgradecd /etc/ros/rosdep/sources.list.d &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/github-raw/ros/rosdistro/master/rosdep/sources.list.d/20-default.listrosdep updaterosdep install --from-paths src --ignore-src -y --skip-keys &quot;fastcdr rti-connext-dds-5.3.1 urdfdom_headers&quot; 7 编译ROS2源码12cd ~/ros2_foxy/colcon build --symlink-install 8 设置环境变量1. ~/ros2_foxy/install/local_setup.bash 9 测试1234567## 运行talker. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_cpp talker## 新起另一个终端，运行listener. ~/ros2_foxy/install/local_setup.bashros2 run demo_nodes_py listener","categories":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"}]},{"title":"1-西方哲学摘录","slug":"哲学思考/1-西方哲学摘录","date":"2023-07-26T16:16:41.776Z","updated":"2023-07-26T16:20:24.385Z","comments":true,"path":"2023/07/27/哲学思考/1-西方哲学摘录/","link":"","permalink":"http://example.com/2023/07/27/%E5%93%B2%E5%AD%A6%E6%80%9D%E8%80%83/1-%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E6%91%98%E5%BD%95/","excerpt":"","text":"黑格尔哲学形而上学形而上学的根本特征是以思维（概念）规定感性（事物），在概念中确认哲学所追求的“最高原因的基本原理”。这种基本原理可以使人类经验中的各种各样的事物得到统一性的解释，或者可以被解释为某种普遍本质的各种具体表现，从而使思维实现其把握和解释世界的“全体自由性”。 黑格尔哲学特点黑格尔以辩证法改造形而上学，是通过对构成旧形而上学的抽象理性的批判，以概念的辩证运动实现思维规定感性的形而上学，把“全体的自由性”与“环节的必然性”统一起来，从而把形而上学构建成本体论、认识论和逻辑学相统一的辩证法。这就是黑格尔在哲学上的贡献，将辩证法和形而上学“合流”，也可以认为是形而上学的“完成”。 黑格尔概念辩证法的出发点是双重的，一是思维与存在的同一性，即概念是思维和存在同一的规定性；二是思维与存在的差别的内在的发生，即概念是在自身的辩证运动中所达到的思存同一性。 黑格尔哲学意义在哲学史意义上，黑格尔的概念辩证法，构成了一种双重的“何以可能”：一是“认识何以可能”的逻辑；二是“自由何以可能”的逻辑。前者把认识的可能性归结为概念的辩证运动，即思维与存在的统一展现为概念由抽象的同一到具体的同一的运动过程。后者把自由何以可能得问题同样归结为概念的辩证运动，即概念由抽象的普遍性（自在的全体的自由性）到具体的普遍性（环节的必然性）的运动过程。 为何要加入辩证法在黑格尔看来，之所以把形而上学改造成辩证法，是因为作为真理的哲学必须是使“心灵深入于这些内容，借他们而得到教训，增进力量”，“引导一个个体使之从它的未受教养状态变为有知识的，这是个任务”。“每个个体都必须走过普遍精神所走过的那些发展阶段”。 如何看待黑格尔思想黑格尔思想既是对传统形而上学的否定，又是对传统形而上学的完成。否定是因为它在思维规定感性的形而上学传统中，揭示了概念——思维规定感性的主体和实体的内在矛盾性，迫使形而上学于辩证法合流。完成是指它在思维规定感性的形而上学传统中，确认了概念（普遍理性）作为唯一的主体和实体的地位，又把辩证法变成了概念形而上学。 从深层的社会根源上看，黑格尔则是以哲学的方式表征了他所处资本主义社会的内在矛盾性：一方面，资产阶级除非使全部社会关系不断地革命化便不能生存下去，“否定”构成资本主义生产方式的内在要求；另一方面，资产阶级社会的商品交换原则的同一性构成全部社会生活的根本模式，“概念”成为规范一切生活领域的意识形态。 马克思哲学哲学使命的跃迁 “人的自我异化的神圣形象被揭穿之后，揭露非神圣形象的自我异化，就成为了为历史服务的哲学的迫切任务。于是对天国的批判就变成了对尘世的批判，对宗教的批判就变成对法的批判，对神学的批判就变成了对政治的批判。” 近代的西方历史，从经济形态上来说，是以市场经济取代自然经济的过程；从人的存在形态上说，是人从人对人的“依附性”存在转换为“以物的依赖性为基础的人的独立性”的过程；从文化形态上说，则是从“神学文化”转换为“哲学科学文化”的过程。这个历史过程所构成的时代精神的变革，是哲学使命的历史性转换的最重要的生活基础。 现代哲学使命两个“消解”和两种“归还”：近代以来的哲学是“消解”人在“神圣形象”中的“自我异化”，把异化给“神圣形象”的人的本质“归还”给人；现代哲学的使命则是“消解”人在“非神圣形象”中的“自我异化”，把异化给“非神圣形象”的人的本质“归还”给人。 如何理解第一种消解？自然经济所要求的是经济上禁欲，精神上蒙昧，政治上专制，从而造成人在“神圣形象”中的“自我异化”。而取代自然经济的市场经济反对禁欲而要求人的现实幸福，反对蒙昧而要求人的理性自由，反对专制而要求人的天赋人权，也即市场经济的三个基本取向：功利主义的价值取向，工具理性的思维取向，民主法治的政治取向。这三种基本取向也即马克思说的，以物的依赖性为基础的人的独立性。本质上，第一种消解是理性取代上帝的过程。 如何理解第二种消解？近代哲学又使人在“理性”中造成了新的“自我异化”，即把理性变成了凌驾于人之上的“本质主义的肆虐”。近代哲学本质上是以理论的方式表达了正在受“抽象”统治的近代以来的人的生存状态，也就是人的“独立性”建立在对物的依赖性的基础之上的生存状态。如果说近代哲学表征的是“理性的时代”，则现代哲学可概括为“理性的批判”，其表征的是“反省理性的时代”。","categories":[{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/categories/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"5-模型调参","slug":"pytorch基础/5-模型调参","date":"2023-07-26T09:21:38.260Z","updated":"2023-07-26T09:21:38.312Z","comments":true,"path":"2023/07/26/pytorch基础/5-模型调参/","link":"","permalink":"http://example.com/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/5-%E6%A8%A1%E5%9E%8B%E8%B0%83%E5%8F%82/","excerpt":"","text":"1 超参数超参数是可调整的参数，让你控制模型优化过程。不同的超参数值会影响模型的训练和收敛率。 常用的超参数如下： epoch : 在整个数据集上迭代的次数。 batch : 每一次更新参数（反向传播）所用到的数据样本数。 学习率 : 每个batch 更新模型参数的步进幅度。 123learning_rate = 1e-3batch_size = 64epochs = 5 2 损失函数当遇到一些训练数据时，我们未经训练的网络很可能不会给出正确的答案。损失函数衡量的是获得的结果与目标值的不相似程度，它是我们在训练期间想要最小化的损失函数。为了计算损失，我们使用给定数据样本的输入进行预测，并与真实数据标签值进行比较。 常见的损失函数包括用于回归任务的nn.MSELoss（均方误差）和用于分类的nn.NLLLoss（负对数似然）。nn.CrossEntropyLoss结合了nn.LogSoftmax和nn.NLLLoss。 我们将模型的输出对数传递给 nn.CrossEntropyLoss，它将对对数进行标准化处理并计算预测误差。 12# Initialize the loss functionloss_fn = nn.CrossEntropyLoss() 3 优化器优化是在每个训练步骤中调整模型参数以减少模型误差的过程。优化算法定义了这个过程是如何进行的（在这个例子中，我们使用随机梯度下降法）。所有的优化逻辑都被封装在优化器对象中。在这里，我们使用SGD优化器；此外，PyTorch中还有许多不同的优化器，如Adam和RMSProp，它们对不同类型的模型和数据有更好的效果。 我们通过注册需要训练的模型参数来初始化优化器，并传入学习率超参数。 1optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) 4 调参过程我们定义了train_loop和test_loop，train_loop负责循环我们的优化代码，test_loop负责根据测试数据评估模型的性能。 12345678910111213141516171819202122232425262728293031def train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;)def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;) 123456789loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)epochs = 10for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 请确保在推理前调用model.eval()方法，以将dropout和batch normalization层设置为eval模式。如果不这样做，将产生不一致的推理结果。 5 保存&amp;加载5.1 保存状态字典123torch.save(model.state_dict(), &#x27;model_weights.pth&#x27;)model = Model_Net() # 需要实例化训练时相同的类model.load_state_dict(torch.load(&#x27;model_weights.pth&#x27;)) 5.2 保存整个模型类123# 这种方法在序列化模型时使用Python的pickle模块，所以它在加载模型时，依赖于实际的可用的类定义。torch.save(model, &#x27;model.pth&#x27;)model = torch.load(&#x27;model.pth&#x27;) 5.3 导出ONNX模型123# 由于PyTorch执行图的动态性质，导出过程必须遍历执行图以产生持久的ONNX模型。出于这个原因，应该向导出程序传递一个适当大小的测试变量。input_image = torch.zeros((1,3,224,224))onnx.export(model, input_image, &#x27;model.onnx&#x27;) 5.4 导出JIT模型该种方法加载模型时无需 模型类，导出 JIT 模型的方式有两种：trace 和 script。 采用 torch.jit.trace 的方式来导出 JIT 模型，这种方式会根据一个输入将模型跑一遍，然后记录下执行过程。这种方式的问题在于对于有分支判断的模型不能很好的应对，因为一个输入不能覆盖到所有的分支。但是在我们 ResNet50 模型中不会遇到分支判断，因此这里是合适的。 12345# trace 方法保存example_input = torch.rand(1, 3, 224, 224)jit_model = torch.jit.trace(model, example_input)torch.jit.save(jit_model, &#x27;resnet50_jit.pth&#x27;)module = torch.jit.load(&#x27;resnet50_jit.pth&#x27;) 如果模型有 if else 等分支语句, 应该用script方法保存模型。 1234# script 方法保存script_module = torch.jit.script(model) torch.jit.save(script_module, &#x27;model.pth&#x27;)module = torch.jit.load(&#x27;model.pth&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"4-模型搭建","slug":"pytorch基础/4-模型搭建","date":"2023-07-26T09:18:44.419Z","updated":"2023-07-26T09:18:44.467Z","comments":true,"path":"2023/07/26/pytorch基础/4-模型搭建/","link":"","permalink":"http://example.com/2023/07/26/pytorch%E5%9F%BA%E7%A1%80/4-%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1 神经网络搭建1.1 通过 forward 构建我们可以通过继承 nn.Module，构建我们自己的类来定义我们的神经网络。其中，我们在__init__方法中实现各个子Module的初始化，并在forward 方法中组织这些子Module，形成神经网络。 12345678910111213141516171819class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)logits = model(input_image) 1.2 通过 Sequential 构建nn.Sequential是一个有序模块的容器。数据以定义的顺序通过所有的模块。你可以使用 序列容器来组建一个快速的网络。 1234567seq_modules = nn.Sequential( flatten, layer1, nn.ReLU(), nn.Linear(20, 10))logits = seq_modules(input_image) 2 模型参数神经网络中的许多层都是参数化的，也就是说，层相关的权重和偏置在训练中被优化。nn.Module的子类会自动跟踪你的模型对象中定义的所有字段，并使用你的模型的 parameters() 或 named_parameters() 方法访问所有参数。 在这个例子中，我们遍历每个参数，并打印其大小和预览其值。 1234print(&quot;Model structure: &quot;, model, &quot;\\n\\n&quot;)for name, param in model.named_parameters(): print(f&quot;Layer: &#123;name&#125; | Size: &#123;param.size()&#125; | Values : &#123;param[:2]&#125; \\n&quot;) 3 反向传播在训练神经网络时，最常使用的算法是反向传播算法。在这种算法中，参数（模型权重）是根据损失函数相对于给定参数的梯度来调整的。 3.1 自动梯度计算为了计算这些梯度，PyTorch有一个内置的微分引擎，叫做torch.autograd。它支持对任何计算图的梯度进行自动计算。考虑最简单的单层神经网络，输入x，参数w和b，以及一些损失函数。 在这个网络中，w和b是参数，我们需要进行优化。因此，我们需要能够计算损失值相对于这些变量的梯度（梯度只对于模型参数有意义）。为了做到这一点，我们设置了这些tensor的 requires_grad 属性。它可以在PyTorch中以如下方式定义： 12345678910111213# 正向传播import torchx = torch.ones(5) # input tensory = torch.zeros(3) # expected outputw = torch.randn(5, 3, requires_grad=True) # 需要更新的weightb = torch.randn(3, requires_grad=True) # 需要更新的biasz = torch.matmul(x, w)+bloss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)#反向传播loss.backward() #该步骤包含对梯度的自动计算，梯度值通过以下查看。print(w.grad)print(b.grad) 3.2 autograd的机制首先了解tensor有哪些属性： data : 被包装的张量 grad : 存储data的梯度 grad_fn : 创建 Tensor的 Function，是自动求导的关键 requires_grad：指示是否需要梯度 is_leaf : 指示是否是叶子结点 dtype：张量的数据类型 shape：张量的形状，如(64，3，224，224) device：张量所在设备，GPU&#x2F;CPU Tensor和Function互相结合就可以构建一个记录有整个计算过程的有向无环图(Directed Acyclic Graph，DAG)。每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function。 DAG的节点是Function对象，边表示数据依赖，从输出指向输入。 每当对Tensor施加一个运算的时候，就会产生一个Function对象，它产生运算的结果，记录运算的发生，并且记录运算的输入。Tensor使用.grad_fn属性记录这个计算图的入口。反向传播过程中，autograd引擎会按照逆序，通过Function的backward依次计算梯度。 注意事项 （1）梯度不自动清零，如果不清零梯度会累加，所以需要在每次梯度后人为清零。（2）依赖于叶子结点的结点，requires_grad默认为True。（3）叶子结点不可执行in-place，因为其他节点在计算梯度时需要用到叶子节点，所以叶子地址中的值不得改变否则会是其他节点求梯度时出错。所以叶子节点不能进行原位计算。（4）在 y.backward()时，如果 y 是标量量，则不需要为backward()传⼊入任何参数；否则，需要传⼊一个与y同形的Tensor。 （5）只能获得计算图的叶子节点的grad属性，这些节点的requires_grad属性设置为True。对于图中的所有其他节点，梯度将不可用。 （6）只能在一个给定的图上使用一次backward来进行梯度计算。如果需要在同一个图上进行多次backward调用，需要在backward调用中传递 retain_graph&#x3D;True。 （7）在PyTorch中，DAG是动态的。需要注意的是，图是从头开始重新创建的；在每次调用.backward()后，autograd开始填充一个新的图。这正是允许你在模型中使用控制流语句的原因；如果需要，你可以在每次迭代时改变形状、大小和操作。 3.3 禁用梯度跟踪123456789101112# 方法一：利用torch.no_grad()块包围正向传播代码with torch.no_grad(): z = torch.matmul(x, w)+b# 方法二：利用detach方法z = torch.matmul(x, w)+bz_det = z.detach()# 方法三：设置requires_gradfor name, param in model.named_parameters(): param.requires_grad = False","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"3-数据准备","slug":"pytorch基础/3-数据准备","date":"2023-07-25T06:38:09.422Z","updated":"2023-07-25T06:38:09.474Z","comments":true,"path":"2023/07/25/pytorch基础/3-数据准备/","link":"","permalink":"http://example.com/2023/07/25/pytorch%E5%9F%BA%E7%A1%80/3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87/","excerpt":"","text":"1 Dataset1.1 图像（path+label形式）12345678910111213141516171819202122232425import osimport pandas as pdfrom torchvision.io import read_imagefrom torchvision import datasetsfrom torchvision import transformsclass CustomImageDataset(Dataset): def __init__(self, annotations_file, img_dir, transform=None, target_transform=None): self.img_labels = pd.read_csv(annotations_file) self.img_dir = img_dir self.transform = transform self.target_transform = target_transform def __len__(self): return len(self.img_labels) def __getitem__(self, idx): img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0]) image = read_image(img_path) label = self.img_labels.iloc[idx, 1] if self.transform: image = self.transform(image) if self.target_transform: label = self.target_transform(label) return image, label 1.2 图像（文件夹名为label 形式）12345data_dir = &#x27;data/hymenoptera_data&#x27;train_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;train&quot;) ,data_transforms[&quot;train&quot;])val_datasets = datasets.ImageFolder( os.path.join(data_dir, &quot;val&quot;) ,data_transforms[&quot;val&quot;]) 1.3 图像（在线拉取）12345train_data = datasets.MNIST(root=&#x27;data&#x27;, train=True, download=True, transform=data_transforms[&quot;train&quot;], target_transform=xxx) 1.4 图片转换1234567891011121314151617# input变换data_transforms = transforms.Compose([ transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ])# RandomResizedCrop: 随机长宽比裁剪# RandomHorizontalFlip: 随机水平翻转# RandomVerticalFlip: 随机垂直翻转# ToTensor: 转换为tensor# Normalize: 像素值进行归一化处理# target 变换# 把整数变成一个one-hot的tensortarget_transform = Lambda(lambda y: torch.zeros(10, dtype=torch.float) \\ .scatter_(dim=0, index=torch.tensor(y), value=1)) 2 DataLoader123456train_dataloader = torch.utils.data.DataLoader(train_data, batch_size=64, shuffle=True, num_workers=4)for batch, (X, y) in enumerate(train_dataloader): X, y = X.to(device), y.to(device)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"2-tensor基础","slug":"pytorch基础/2-tensor操作","date":"2023-07-24T09:18:03.276Z","updated":"2023-07-25T06:26:52.819Z","comments":true,"path":"2023/07/24/pytorch基础/2-tensor操作/","link":"","permalink":"http://example.com/2023/07/24/pytorch%E5%9F%BA%E7%A1%80/2-tensor%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1 tensor属性1.1 tensor初始化1234shape = (2,3,)rand_tensor = torch.rand(shape)ones_tensor = torch.ones(shape)zeros_tensor = torch.zeros(shape) 1.2 tensor性质1234tensor = torch.rand(3,4)print(f&quot;Shape of tensor: &#123;tensor.shape&#125;&quot;)print(f&quot;Datatype of tensor: &#123;tensor.dtype&#125;&quot;)print(f&quot;Device tensor is stored on: &#123;tensor.device&#125;&quot;) 2 对象转换2.1 list – tensor123456data = [[1, 2], [3, 4]]# list--&gt; tensor# 数据类型是自动推断出来x_tensor = torch.tensor(data)# tensor--&gt; listx_list = x_tensor.tolist() 2.2 numpy – tensor12345np_array = np.array(data)# numpy --&gt; tensorx_tensor = torch.from_numpy(np_array)# tensor --&gt; numpyx_numpy = x_tensor.numpy() 2.3 tensor – tensor12x_ones = torch.ones_like(x_data) # retains the properties of x_datax_rand = torch.rand_like(x_data, dtype=torch.float) # overrides the datatype of x_data 3 运算&amp;操作3.1 矩阵乘法1234y1 = tensor @ tensor.Ty2 = tensor.matmul(tensor.T)y3 = torch.rand_like(tensor)torch.matmul(tensor, tensor.T, out=y3) 3.2 矩阵点乘12345z1 = tensor * tensorz2 = tensor.mul(tensor)z3 = torch.rand_like(tensor)torch.mul(tensor, tensor, out=z3) 3.3 矩阵拼接1234# 指定的dim 数量增加，除了dim之外的dim需要相同才行t1 = torch.cat([tensor, tensor, tensor], dim=1)# 两个要进行stack的tensor的dim数量应该相同，stack操作之后得到的结果会多出一维，即dim的数量会+1。t1 = torch.stack([tensor, tensor, tensor], dim=1) 3.4 矩阵升降维123456# 升维。插入指定维度，值为1tensor.unsqueeze(dim=0)# 降维。压缩指定维度，该维度值必须为1# 当dim不指定时，压缩所有维度值为1的维tensor.squeeze(dim=0)tensor.squeeze()","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"1-pytorch快速开始","slug":"pytorch基础/1-pytorch快速开始","date":"2023-07-24T09:15:16.547Z","updated":"2023-07-24T10:01:37.638Z","comments":true,"path":"2023/07/24/pytorch基础/1-pytorch快速开始/","link":"","permalink":"http://example.com/2023/07/24/pytorch%E5%9F%BA%E7%A1%80/1-pytorch%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"","text":"0 导库123456import torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambda, Composeimport matplotlib.pyplot as plt 1 数据准备torchvision.datasets模块包含了许多真实世界的视觉数据的数据集对象，如CIFAR、COCO。以下通过datasets在线加载FashionMNIST数据集。 123456789101112131415# Download training data from open datasets.training_data = datasets.FashionMNIST( root=&quot;data&quot;, train=True, download=True, transform=ToTensor(),)# Download test data from open datasets.test_data = datasets.FashionMNIST( root=&quot;data&quot;, train=False, download=True, transform=ToTensor(),) 将dataset装载入DataLoader中，DataLoader可认为是一个数据迭代器，其支持数据的自动批处理、采样、洗牌和多进程数据加载。这里定义一个 batch&#x3D;64，即dataloader可迭代的每个元素将返回一个批次，包括64个元素的特征和标签。 123456789batch_size = 64# Create data loaders.train_dataloader = DataLoader(training_data, batch_size=batch_size)test_dataloader = DataLoader(test_data, batch_size=batch_size)for X, y in test_dataloader: print(&quot;Shape of X [N, C, H, W]: &quot;, X.shape) print(&quot;Shape of y: &quot;, y.shape, y.dtype) break 2 创建模型为了在PyTorch中定义一个神经网络，我们创建一个继承自nn.Module的类。我们在__init__函数中定义网络的层，并在forward函数中指定数据将如何通过网络。为了加速神经网络的操作，如果有GPU的话，我们把它移到GPU上。 1234567891011121314151617181920212223# Get cpu or gpu device for training.device = &quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;# Define modelclass NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10) ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork().to(device)print(model) 3 优化模型参数3.1 模型训练函数12345678910111213141516171819202122loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)def train(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) model.train() for batch, (X, y) in enumerate(dataloader): X, y = X.to(device), y.to(device) # Compute prediction error pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: &#123;loss:&gt;7f&#125; [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;) 3.2 模型评估函数1234567891011121314def test(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) model.eval() test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X, y = X.to(device), y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;)1 3.3 启动训练&amp;评估123456epochs = 5for t in range(epochs): print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;) train(train_dataloader, model, loss_fn, optimizer) test(test_dataloader, model, loss_fn)print(&quot;Done!&quot;) 4 保存模型12torch.save(model.state_dict(), &quot;model.pth&quot;)print(&quot;Saved PyTorch Model State to model.pth&quot;) 5 加载模型12model = NeuralNetwork()model.load_state_dict(torch.load(&quot;model.pth&quot;)) 6 模型推理12345678910111213141516171819classes = [ &quot;T-shirt/top&quot;, &quot;Trouser&quot;, &quot;Pullover&quot;, &quot;Dress&quot;, &quot;Coat&quot;, &quot;Sandal&quot;, &quot;Shirt&quot;, &quot;Sneaker&quot;, &quot;Bag&quot;, &quot;Ankle boot&quot;,]model.eval()x, y = test_data[0][0], test_data[0][1]with torch.no_grad(): pred = model(x) predicted, actual = classes[pred[0].argmax(0)], classes[y] print(f&#x27;Predicted: &quot;&#123;predicted&#125;&quot;, Actual: &quot;&#123;actual&#125;&quot;&#x27;)","categories":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-07-21T10:28:18.087Z","updated":"2023-07-23T10:23:20.541Z","comments":true,"path":"2023/07/21/hello-world/","link":"","permalink":"http://example.com/2023/07/21/hello-world/","excerpt":"","text":"今天坑坑洼洼可算是把网站给搭好了，看着简洁漂亮的首页，想着以后就有专属自己的网站，就很开心。背景图是《权游》里面的某一幕的简画，守夜人面对夜鬼的来袭，背水一战，颇为壮观。 为什么要做个人博客呢？说实话，没有特别的理由。或许是出于新鲜感；或许是工作太无聊；或许是外界太嘈杂，想在数字世界中寻找一片净土；或许是想把有趣的、新奇的东西系统地放进来，有一天可以带朋友来参观，看！这是我曾经的快乐和珍藏。 现实世界有太多约束，说话做事写文章处处存在隐形的规矩，这些规矩容易消磨本身藏在事物的乐趣。我想，在这里就少点规矩吧，说说废话，吹吹牛逼又怎么样呢？有时候写点生活感悟也不怕别人说我假正经。嗯，没错，这是我的展厅！当然，对于涉及实操性或理论性的文章，行文还是遵从逻辑，便于理解和回顾。 那么，第一篇写点啥呢，emmm…","categories":[{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%99/"}]}],"categories":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/categories/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/categories/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/categories/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/categories/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"ROS1","slug":"ROS1","permalink":"http://example.com/tags/ROS1/"},{"name":"ROS2基础","slug":"ROS2基础","permalink":"http://example.com/tags/ROS2%E5%9F%BA%E7%A1%80/"},{"name":"哲学笔记","slug":"哲学笔记","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"Pytorch基础","slug":"Pytorch基础","permalink":"http://example.com/tags/Pytorch%E5%9F%BA%E7%A1%80/"},{"name":"建站","slug":"建站","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%99/"}]}